// ==UserScript==
// @name         Tieba Remix
// @namespace    https://github.com/WiresawBlade/Tieba-Remix
// @version      0.4.1-beta
// @author       锯条
// @description  贴吧网页端重塑
// @license      MIT
// @icon         https://gitee.com/WiresawBlade/Tieba-Remix/raw/master/assets/images/main/icon16.png
// @icon64       https://gitee.com/WiresawBlade/Tieba-Remix/raw/master/assets/images/main/icon64.png
// @downloadURL  https://gitee.com/WiresawBlade/Tieba-Remix/raw/beta/build/tieba-remix.user.js
// @updateURL    https://gitee.com/WiresawBlade/Tieba-Remix/raw/beta/build/tieba-remix.user.js
// @match        *://tieba.baidu.com/*
// @match        *://jump.bdimg.com/*
// @match        *://jump2.bdimg.com/*
// @grant        GM_addElement
// @grant        GM_addStyle
// @grant        GM_deleteValue
// @grant        GM_getValue
// @grant        GM_info
// @grant        GM_listValues
// @grant        GM_openInTab
// @grant        GM_registerMenuCommand
// @grant        GM_setValue
// @grant        unsafeWindow
// @run-at       document-start
// ==/UserScript==

(e=>{if(typeof GM_addStyle=="function"){GM_addStyle(e);return}const o=document.createElement("style");o.textContent=e,document.head.append(o)})(` @charset "UTF-8";.user-button{box-sizing:border-box;padding:2px 8px;border:none;border-radius:6px;background:none;background-color:var(--default-background);box-shadow:0 0 0 1px var(--border-color);color:var(--default-fore);cursor:pointer;transition:.4s}.theme-style.user-button{color:var(--default-background)!important}.theme-style.user-button{background-color:var(--tieba-theme-color)}.theme-style.user-button:hover{background-color:var(--tieba-theme-hover)}.theme-style.user-button:active{background-color:var(--tieba-theme-active)}.unset-background.user-button{background-color:transparent;background-color:initial}.no-border.user-button{box-shadow:none}.user-button:hover{background-color:var(--default-hover)}.user-button:active{background-color:var(--default-active)}.user-button:focus{border-color:var(--tieba-theme-color);box-shadow:0 0 0 2px var(--tieba-theme-color)}html[data-v-a6de5a03]{padding:0;margin:0;text-align:justify}body[data-v-a6de5a03]{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar][data-v-a6de5a03]{overflow:hidden}div[data-v-a6de5a03],p[data-v-a6de5a03]{margin:0}select[data-v-a6de5a03]{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option[data-v-a6de5a03]{cursor:pointer}option[data-v-a6de5a03]:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a[data-v-a6de5a03]{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ[data-v-a6de5a03]{position:fixed!important;top:50%!important;left:50%!important}.dialogJ[data-v-a6de5a03]{transform:translate(-50%,-50%)}@keyframes kf-fade-in-a6de5a03{0%{opacity:0}to{opacity:1}}@keyframes kf-fade-out-a6de5a03{0%{opacity:1}to{opacity:0}}@keyframes kf-dialog-in-a6de5a03{0%{opacity:0;transform:scale(1.2)}to{opacity:1;transform:scale(1)}}@keyframes kf-zoom-in-a6de5a03{0%{transform:scale(.72)}to{transform:scale(1)}}@keyframes kf-fade-zoom-in-a6de5a03{0%{opacity:0;transform:scale(.72)}to{opacity:1;transform:scale(1)}}@keyframes stretch-a6de5a03{0%{padding:0 12px;opacity:0}50%{opacity:1}to{padding:8px 12px}}.check[data-v-a6de5a03]{color:var(--level-green-fore)}.warning[data-v-a6de5a03]{color:var(--warning-color)}.error[data-v-a6de5a03]{color:var(--error-color)}.toast-container[data-v-a6de5a03]{position:fixed;z-index:999;bottom:96px;left:50%;display:flex;max-height:60vh;align-items:center;padding:8px 12px;border:1px solid var(--border-color);border-radius:16px;animation:stretch-a6de5a03 .4s cubic-bezier(.18,.89,.32,1.6);background-color:var(--default-background);box-shadow:0 10px 24px #0003;gap:6px;text-overflow:ellipsis;transform:translate(-50%);transition:all ease .4s}.toast-container .toast-icon[data-v-a6de5a03]{font-size:18px}.toast-container .toast-content[data-v-a6de5a03]{overflow:hidden;max-width:80vw;max-height:60vh;padding:0 6px;text-align:left;text-overflow:ellipsis;white-space:pre-wrap}.toast-container span[data-v-a6de5a03]{color:var(--minimal-fore);font-size:12px}.toast-container .toast-controls .close-button[data-v-a6de5a03]{padding:6px;color:var(--error-color);font-weight:700}.toast-container .toast-controls .close-button[data-v-a6de5a03]:not(:active):not(:focus){box-shadow:none}.blur-effect[data-v-a6de5a03]{background-color:var(--trans-default-background);-webkit-backdrop-filter:blur(24px);backdrop-filter:blur(24px)}body.dark-theme .blur-effect[data-v-a6de5a03]{-webkit-backdrop-filter:blur(24px) brightness(.8);backdrop-filter:blur(24px) brightness(.8)}html[data-v-4b280e9a]{padding:0;margin:0;text-align:justify}body[data-v-4b280e9a]{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar][data-v-4b280e9a]{overflow:hidden}div[data-v-4b280e9a],p[data-v-4b280e9a]{margin:0}select[data-v-4b280e9a]{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option[data-v-4b280e9a]{cursor:pointer}option[data-v-4b280e9a]:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a[data-v-4b280e9a]{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ[data-v-4b280e9a]{position:fixed!important;top:50%!important;left:50%!important}.dialogJ[data-v-4b280e9a]{transform:translate(-50%,-50%)}@keyframes kf-fade-in-4b280e9a{0%{opacity:0}to{opacity:1}}@keyframes kf-fade-out-4b280e9a{0%{opacity:1}to{opacity:0}}@keyframes kf-dialog-in-4b280e9a{0%{opacity:0;transform:scale(1.2)}to{opacity:1;transform:scale(1)}}@keyframes kf-zoom-in-4b280e9a{0%{transform:scale(.72)}to{transform:scale(1)}}@keyframes kf-fade-zoom-in-4b280e9a{0%{opacity:0;transform:scale(.72)}to{opacity:1;transform:scale(1)}}.dialog-wrapper[data-v-4b280e9a]{position:fixed;z-index:9999;top:0;left:0;display:flex;width:100%;height:100%;background-color:transparent;animation:kf-fade-in-4b280e9a .2s}.dialog-wrapper.darker[data-v-4b280e9a]{background-color:#000000b8}.blur-effect[data-v-4b280e9a]{-webkit-backdrop-filter:blur(24px);backdrop-filter:blur(24px)}body.dark-theme .blur-effect[data-v-4b280e9a]{-webkit-backdrop-filter:blur(24px) brightness(.8);backdrop-filter:blur(24px) brightness(.8)}html[data-v-8df9d0bc]{padding:0;margin:0;text-align:justify}body[data-v-8df9d0bc]{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar][data-v-8df9d0bc]{overflow:hidden}div[data-v-8df9d0bc],p[data-v-8df9d0bc]{margin:0}select[data-v-8df9d0bc]{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option[data-v-8df9d0bc]{cursor:pointer}option[data-v-8df9d0bc]:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a[data-v-8df9d0bc]{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ[data-v-8df9d0bc]{position:fixed!important;top:50%!important;left:50%!important}.dialogJ[data-v-8df9d0bc]{transform:translate(-50%,-50%)}.message-box[data-v-8df9d0bc]{display:flex;overflow:hidden;max-width:60vw;max-height:80vh;box-sizing:border-box;flex-direction:column;border:1px solid var(--light-border-color);border-radius:16px;margin:auto;animation:kf-dialog-in .4s ease;background-color:var(--default-background);box-shadow:0 0 20px #0000004d;font-size:16px;transition:.4s ease}.message-box .message-wrapper[data-v-8df9d0bc]{display:flex;overflow-x:hidden;overflow-y:auto;overflow:hidden auto;flex-direction:column;padding:16px}.message-box .message-wrapper .title[data-v-8df9d0bc]{margin-bottom:8px;color:var(--highlight-fore);font-size:20px;font-weight:700}.message-box .message-controls[data-v-8df9d0bc]{display:flex;padding:16px;margin-top:auto;background-color:var(--deep-background);gap:8px}.message-box .message-controls .message-button[data-v-8df9d0bc]{flex-grow:1;padding:6px 16px;font-size:14px}.block-panel{display:flex;min-width:30px;height:26px;align-items:center;justify-content:center;padding:2px 8px;border-radius:24px;margin:auto;background-color:var(--trans-light-background);font-size:14px;text-align:center}.block-panel .icon{color:var(--light-fore);font-size:18px}.block-panel .panel-button{border:none!important}.block-panel .panel-button{width:30px;height:30px;padding:4px;border-radius:48px}.block-panel.left-align{margin-left:0}#header-progress[data-v-da001943]{position:fixed;z-index:99999;top:0;max-width:100vw;height:4px;background-color:var(--tieba-theme-color);transition:.4s}html[data-v-e6108e1e]{padding:0;margin:0;text-align:justify}body[data-v-e6108e1e]{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar][data-v-e6108e1e]{overflow:hidden}div[data-v-e6108e1e],p[data-v-e6108e1e]{margin:0}select[data-v-e6108e1e]{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option[data-v-e6108e1e]{cursor:pointer}option[data-v-e6108e1e]:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a[data-v-e6108e1e]{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ[data-v-e6108e1e]{position:fixed!important;top:50%!important;left:50%!important}.dialogJ[data-v-e6108e1e]{transform:translate(-50%,-50%)}@keyframes kf-fade-in-e6108e1e{0%{opacity:0}to{opacity:1}}@keyframes kf-fade-out-e6108e1e{0%{opacity:1}to{opacity:0}}@keyframes kf-dialog-in-e6108e1e{0%{opacity:0;transform:scale(1.2)}to{opacity:1;transform:scale(1)}}@keyframes kf-zoom-in-e6108e1e{0%{transform:scale(.72)}to{transform:scale(1)}}@keyframes kf-fade-zoom-in-e6108e1e{0%{opacity:0;transform:scale(.72)}to{opacity:1;transform:scale(1)}}.images-viewer[data-v-e6108e1e]{display:flex;width:100%;height:100%;flex-direction:column;align-items:center;justify-content:center}.images-viewer .icon[data-v-e6108e1e]{color:var(--light-fore)}.images-viewer .control-panel[data-v-e6108e1e]{position:absolute;display:flex;align-items:center;padding:10px;border:1px solid var(--light-border-color);border-radius:12px;background-color:var(--trans-default-background);box-shadow:0 0 32px #0006;gap:2px;-webkit-backdrop-filter:blur(24px);backdrop-filter:blur(24px)}body.dark-theme .images-viewer .control-panel[data-v-e6108e1e]{-webkit-backdrop-filter:blur(24px) brightness(.8);backdrop-filter:blur(24px) brightness(.8)}.images-viewer .head-controls[data-v-e6108e1e]{top:16px;margin-bottom:auto}.images-viewer .head-controls .head-btn[data-v-e6108e1e]{width:36px;height:36px;border-radius:12px;background-color:transparent;background-color:initial;box-shadow:none}.images-viewer .head-controls .head-btn[data-v-e6108e1e]:hover{background-color:var(--default-background);color:var(--tieba-theme-color)}.images-viewer .head-controls .close[data-v-e6108e1e]:hover{color:var(--error-color)}.images-viewer .head-controls span[data-v-e6108e1e]{color:var(--minimal-fore);font-family:var(--code-zh)}.images-viewer .head-controls .zoom-size[data-v-e6108e1e]{padding:10px}.images-viewer .back[data-v-e6108e1e],.images-viewer .forward[data-v-e6108e1e]{height:60px;box-shadow:0 0 20px #0000001a;font-size:large}.images-viewer .back[data-v-e6108e1e]{left:32px}.images-viewer .forward[data-v-e6108e1e]{right:32px}.images-viewer .back[data-v-e6108e1e]:hover,.images-viewer .forward[data-v-e6108e1e]:hover{background-color:var(--default-background)}.images-viewer .back[data-v-e6108e1e]:focus,.images-viewer .forward[data-v-e6108e1e]:focus{box-shadow:0 0 0 2px var(--tieba-theme-color)}.images-viewer .image-container[data-v-e6108e1e]{display:flex;width:auto;align-items:center;justify-content:center;margin:auto}.images-viewer .image-container .curr-image[data-v-e6108e1e]{position:absolute;-o-object-fit:contain;object-fit:contain;transition:all .4s ease,left 0s,top 0s}.images-viewer .bottom-controls[data-v-e6108e1e]{bottom:16px;display:flex;margin-top:auto;gap:4px}.images-viewer .bottom-controls .bottom-btn[data-v-e6108e1e]{overflow:hidden;width:100px;height:75px;padding:0;border:none;border-radius:6px;background-color:var(--trans-default-background);transition:all linear .1s}.images-viewer .bottom-controls .bottom-btn .image-list[data-v-e6108e1e]{width:100%;height:100%;-o-object-fit:cover;object-fit:cover}.images-viewer .bottom-controls .bottom-btn.selected[data-v-e6108e1e]{border:3px solid var(--tieba-theme-color)}a[data-v-6189916b]{color:inherit;-webkit-text-decoration:none;text-decoration:none}p[data-v-6189916b]{margin:0}img[data-v-6189916b]:before{display:block;width:100%;height:100%;box-sizing:border-box;background-color:var(--light-background);content:""}.dynamic .img-button[data-v-6189916b]{min-width:30%!important;flex:initial!important;flex-grow:1!important}.post-container[data-v-6189916b]{display:flex;width:320px;box-sizing:border-box;flex-direction:column;padding:16px;border-radius:16px;background-color:var(--default-background);cursor:pointer;gap:20px;text-align:justify}.post-container .forum-btn[data-v-6189916b]{border-radius:24px;font-size:14px}.post-container .forum-btn[data-v-6189916b]:not(:hover):not(:active):not(:focus){background-color:var(--light-background);box-shadow:none}.post-container .main-content[data-v-6189916b]{display:flex;flex-direction:column;gap:8px}.post-container .main-content .title[data-v-6189916b]{margin:0;color:var(--highlight-fore);font-weight:700}.post-container .main-content .content[data-v-6189916b]{color:var(--light-fore);font-size:14px}.post-container .img-container[data-v-6189916b]{display:flex;overflow:hidden;flex-wrap:wrap;border-radius:16px;gap:6px}.post-container .img-container .img-button[data-v-6189916b]{overflow:hidden;min-width:40%;height:144px;flex:1;padding:0;border:none;border-radius:0}.post-container .img-container .img-button .post-img[data-v-6189916b]{width:100%;height:100%;-o-object-fit:cover;object-fit:cover;transition:.4s cubic-bezier(0,0,.2,1)}.post-container .img-container .img-button .post-img[data-v-6189916b]:hover{scale:1.2}.post-container .bottom-controls[data-v-6189916b]{display:flex;align-items:center;gap:12px}.post-container .bottom-controls .author[data-v-6189916b]{display:flex;align-items:center;padding:0;border-radius:24px;background-color:transparent;background-color:initial}.post-container .bottom-controls .author .author-portrait[data-v-6189916b]{width:32px;height:32px;border-radius:24px;-o-object-fit:cover;object-fit:cover}.post-container .bottom-controls .author .author-info[data-v-6189916b]{display:flex;flex-direction:column;padding:0 10px;text-align:left}.post-container .bottom-controls .author .author-info .author-name[data-v-6189916b]{font-size:14px;font-weight:700}.post-container .bottom-controls .author .author-info .post-time[data-v-6189916b]{color:var(--minimal-fore);font-size:12px}.post-container .bottom-controls .author[data-v-6189916b]:not(:hover):not(:active):not(:focus){box-shadow:none}.post-container .bottom-controls .replies[data-v-6189916b]{display:flex;min-width:16px;align-items:center;border-radius:24px;margin-left:auto;color:var(--light-fore);font-family:monospace;font-weight:700}.post-container .bottom-controls .replies[data-v-6189916b]:before{margin-right:6px;content:"forum";font-family:Material Symbols,monospace;font-size:16px;font-weight:400}.masonry-wrapper[data-v-0edff44b]{display:flex;width:100%;min-width:var(--content-max);flex-direction:column;align-items:center;gap:12px}.masonry-wrapper .masonry-container[data-v-0edff44b]{width:100%;margin:auto}@keyframes feeds-in-0edff44b{0%{transform:scale(.72)}to{transform:scale(1)}}.masonry-wrapper .masonry-container .post-elem[data-v-0edff44b]{animation:feeds-in-0edff44b .4s cubic-bezier(.18,.89,.32,1.2)}.masonry-wrapper .masonry-container .post-elem[data-v-0edff44b]:not(:hover):not(:active):not(:focus){box-shadow:none}.masonry-wrapper>.post-elem[data-v-0edff44b]{position:absolute!important;visibility:hidden!important}.about-wrapper[data-v-d80f8352]{display:flex;flex-direction:column;align-items:center;padding:8px;margin:auto;gap:12px}.about-wrapper .main-title[data-v-d80f8352]{display:flex;align-items:center;gap:12px}.about-wrapper .main-title .main-icon[data-v-d80f8352]{width:64px;height:64px}.about-wrapper .main-title .title[data-v-d80f8352]{color:var(--highlight-fore);font-size:32px;font-style:italic;font-weight:700}.about-wrapper .script-info[data-v-d80f8352]{display:flex;flex-direction:column;align-items:center;color:var(--minimal-fore);gap:8px}.about-wrapper .script-info .author-info[data-v-d80f8352]{display:flex;align-items:baseline;gap:8px}.about-wrapper .about-controls[data-v-d80f8352]{display:flex;margin-top:16px;gap:8px}.about-wrapper .about-controls .about-button[data-v-d80f8352]{padding:6px 10px;font-size:14px}.update-wrapper[data-v-eeb67353]{display:flex;max-width:100%;flex-direction:column;gap:8px}.update-wrapper .latest-info[data-v-eeb67353]{display:flex;align-items:center;padding:2px 8px;border-radius:16px;margin:auto auto 12px;background-color:var(--level-blue-background);color:var(--level-blue-fore);gap:6px}.update-wrapper .latest-info.is-latest[data-v-eeb67353]{background-color:var(--level-green-background);color:var(--level-green-fore)}.update-wrapper .title-container[data-v-eeb67353]{display:flex;align-items:center;gap:10px}.update-wrapper .title-container .title[data-v-eeb67353]{font-size:20px;font-weight:700}.update-wrapper .title-container .is-pre-release[data-v-eeb67353]{padding:2px 8px;border-radius:16px;background-color:var(--level-orange-background);color:var(--level-orange-fore);font-size:14px}.update-wrapper .main-info[data-v-eeb67353]{display:flex;align-items:center;gap:8px}.update-wrapper .main-info .avatar[data-v-eeb67353]{width:32px;height:32px;border-radius:32px}.update-wrapper .main-info .release-time[data-v-eeb67353]{margin-left:auto}.update-wrapper .update-controls[data-v-eeb67353]{display:flex;align-items:center;margin-top:8px;gap:8px}.update-wrapper .update-controls .up-button[data-v-eeb67353]{padding:4px 8px;border-radius:10px;font-size:15px;font-weight:700}.update-wrapper .update-controls .up-name[data-v-eeb67353]{font-family:monospace}.forbidden-wrapper[data-v-eeb67353]{display:flex;width:100%;height:100%;flex-direction:column;align-items:center}.forbidden-wrapper .icon[data-v-eeb67353]{font-size:64px}.layout-custom-back[data-v-486f1dc3]{display:flex;width:100%;flex-direction:column;gap:8px}.layout-custom-back .custom-image[data-v-486f1dc3]{max-width:100%;max-height:320px;border-radius:8px;margin:0 auto}.layout-custom-back .custom-back-buttons[data-v-486f1dc3]{display:flex;align-items:center;justify-content:flex-end;gap:6px}.layout-custom-back .adjust-controls[data-v-486f1dc3]{display:flex;flex-direction:column;gap:8px}.layout-custom-back .adjust-controls .control-set[data-v-486f1dc3]{display:flex;align-items:baseline;gap:6px}.layout-custom-back .adjust-controls .control-set .editor[data-v-486f1dc3]{width:auto;font-family:var(--code-zh)}:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","\u5FAE\u8F6F\u96C5\u9ED1",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:.3s;--el-transition-duration-fast:.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(.645, .045, .355, 1);--el-transition-function-fast-bezier:cubic-bezier(.23, 1, .32, 1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px}:root{color-scheme:light;--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary:#409eff;--el-color-primary-light-3:#79bbff;--el-color-primary-light-5:#a0cfff;--el-color-primary-light-7:#c6e2ff;--el-color-primary-light-8:#d9ecff;--el-color-primary-light-9:#ecf5ff;--el-color-primary-dark-2:#337ecc;--el-color-success:#67c23a;--el-color-success-light-3:#95d475;--el-color-success-light-5:#b3e19d;--el-color-success-light-7:#d1edc4;--el-color-success-light-8:#e1f3d8;--el-color-success-light-9:#f0f9eb;--el-color-success-dark-2:#529b2e;--el-color-warning:#e6a23c;--el-color-warning-light-3:#eebe77;--el-color-warning-light-5:#f3d19e;--el-color-warning-light-7:#f8e3c5;--el-color-warning-light-8:#faecd8;--el-color-warning-light-9:#fdf6ec;--el-color-warning-dark-2:#b88230;--el-color-danger:#f56c6c;--el-color-danger-light-3:#f89898;--el-color-danger-light-5:#fab6b6;--el-color-danger-light-7:#fcd3d3;--el-color-danger-light-8:#fde2e2;--el-color-danger-light-9:#fef0f0;--el-color-danger-dark-2:#c45656;--el-color-error:#f56c6c;--el-color-error-light-3:#f89898;--el-color-error-light-5:#fab6b6;--el-color-error-light-7:#fcd3d3;--el-color-error-light-8:#fde2e2;--el-color-error-light-9:#fef0f0;--el-color-error-dark-2:#c45656;--el-color-info:#909399;--el-color-info-light-3:#b1b3b8;--el-color-info-light-5:#c8c9cc;--el-color-info-light-7:#dedfe0;--el-color-info-light-8:#e9e9eb;--el-color-info-light-9:#f4f4f5;--el-color-info-dark-2:#73767a;--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0, 0, 0, .04),0px 8px 20px rgba(0, 0, 0, .08);--el-box-shadow-light:0px 0px 12px rgba(0, 0, 0, .12);--el-box-shadow-lighter:0px 0px 6px rgba(0, 0, 0, .12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0, 0, 0, .08),0px 12px 32px rgba(0, 0, 0, .12),0px 8px 16px -8px rgba(0, 0, 0, .16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0, 0, 0, .8);--el-overlay-color-light:rgba(0, 0, 0, .7);--el-overlay-color-lighter:rgba(0, 0, 0, .5);--el-mask-color:rgba(255, 255, 255, .9);--el-mask-color-extra-light:rgba(255, 255, 255, .3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:opacity .2s linear;transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:opacity .2s linear;transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all .3s cubic-bezier(.55,0,.1,1);transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all .3s cubic-bezier(.55,0,.1,1);transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transition:transform .3s cubic-bezier(.23,1,.32,1),opacity .3s cubic-bezier(.23,1,.32,1);transition:var(--el-transition-md-fade);transform-origin:center top}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transition:transform .3s cubic-bezier(.23,1,.32,1),opacity .3s cubic-bezier(.23,1,.32,1);transition:var(--el-transition-md-fade);transform-origin:center bottom}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transition:transform .3s cubic-bezier(.23,1,.32,1),opacity .3s cubic-bezier(.23,1,.32,1);transition:var(--el-transition-md-fade);transform-origin:top left}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:.3s height ease-in-out,.3s padding-top ease-in-out,.3s padding-bottom ease-in-out;transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:.3s max-height ease-in-out,.3s padding-top ease-in-out,.3s padding-bottom ease-in-out;transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:.3s width ease-in-out,.3s padding-left ease-in-out,.3s padding-right ease-in-out;transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity .3s cubic-bezier(.55,0,.1,1);transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-icon-loading{animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.el-icon{--color:inherit;height:1em;width:1em;line-height:1em;display:inline-flex;justify-content:center;align-items:center;position:relative;fill:currentColor;color:inherit;color:var(--color);font-size:inherit}.el-icon.is-loading{animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.el-color-predefine{display:flex;font-size:12px;margin-top:8px;width:280px}.el-color-predefine__colors{display:flex;flex:1;flex-wrap:wrap}.el-color-predefine__color-selector{margin:0 0 8px 8px;width:20px;height:20px;border-radius:4px;cursor:pointer}.el-color-predefine__color-selector:nth-child(10n+1){margin-left:0}.el-color-predefine__color-selector.selected{box-shadow:0 0 3px 2px var(--el-color-primary)}.el-color-predefine__color-selector>div{display:flex;height:100%;border-radius:3px}.el-color-predefine__color-selector.is-alpha{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==)}.el-color-hue-slider{position:relative;box-sizing:border-box;width:280px;height:12px;background-color:red;padding:0 2px;float:right}.el-color-hue-slider__bar{position:relative;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff,#00f 67%,#f0f 83%,red);height:100%}.el-color-hue-slider__thumb{position:absolute;cursor:pointer;box-sizing:border-box;left:0;top:0;width:4px;height:100%;border-radius:1px;background:#fff;border:1px solid var(--el-border-color-lighter);box-shadow:0 0 2px #0009;z-index:1}.el-color-hue-slider.is-vertical{width:12px;height:180px;padding:2px 0}.el-color-hue-slider.is-vertical .el-color-hue-slider__bar{background:linear-gradient(to bottom,red 0,#ff0 17%,#0f0 33%,#0ff,#00f 67%,#f0f 83%,red)}.el-color-hue-slider.is-vertical .el-color-hue-slider__thumb{left:0;top:0;width:100%;height:4px}.el-color-svpanel{position:relative;width:280px;height:180px}.el-color-svpanel__black,.el-color-svpanel__white{position:absolute;top:0;left:0;right:0;bottom:0}.el-color-svpanel__white{background:linear-gradient(to right,#fff,#fff0)}.el-color-svpanel__black{background:linear-gradient(to top,#000,#0000)}.el-color-svpanel__cursor{position:absolute}.el-color-svpanel__cursor>div{cursor:head;width:4px;height:4px;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px #0000004d,0 0 1px 2px #0006;border-radius:50%;transform:translate(-2px,-2px)}.el-color-alpha-slider{position:relative;box-sizing:border-box;width:280px;height:12px;background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-size:12px 12px;background-position:0 0,6px 0,6px -6px,0 6px}.el-color-alpha-slider__bar{position:relative;background:linear-gradient(to right,rgba(255,255,255,0) 0,var(--el-bg-color) 100%);height:100%}.el-color-alpha-slider__thumb{position:absolute;cursor:pointer;box-sizing:border-box;left:0;top:0;width:4px;height:100%;border-radius:1px;background:#fff;border:1px solid var(--el-border-color-lighter);box-shadow:0 0 2px #0009;z-index:1}.el-color-alpha-slider.is-vertical{width:20px;height:180px}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__bar{background:linear-gradient(to bottom,#fff0 0,#fff)}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__thumb{left:0;top:0;width:100%;height:4px}.el-color-dropdown{width:300px}.el-color-dropdown__main-wrapper{margin-bottom:6px}.el-color-dropdown__main-wrapper:after{content:"";display:table;clear:both}.el-color-dropdown__btns{margin-top:12px;text-align:right}.el-color-dropdown__value{float:left;line-height:26px;font-size:12px;color:#000;width:160px}.el-color-picker{display:inline-block;position:relative;line-height:normal;outline:0}.el-color-picker:hover:not(.is-disabled):not(.is-focused) .el-color-picker__trigger{border-color:var(--el-border-color-hover)}.el-color-picker:focus-visible:not(.is-disabled) .el-color-picker__trigger{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-picker.is-focused .el-color-picker__trigger{border-color:var(--el-color-primary)}.el-color-picker.is-disabled .el-color-picker__trigger{cursor:not-allowed}.el-color-picker--large{height:40px}.el-color-picker--large .el-color-picker__trigger{height:40px;width:40px}.el-color-picker--large .el-color-picker__mask{height:38px;width:38px}.el-color-picker--small{height:24px}.el-color-picker--small .el-color-picker__trigger{height:24px;width:24px}.el-color-picker--small .el-color-picker__mask{height:22px;width:22px}.el-color-picker--small .el-color-picker__empty,.el-color-picker--small .el-color-picker__icon{transform:scale(.8)}.el-color-picker__mask{height:30px;width:30px;border-radius:4px;position:absolute;top:1px;left:1px;z-index:1;cursor:not-allowed;background-color:#ffffffb3}.el-color-picker__trigger{display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;height:32px;width:32px;padding:4px;border:1px solid var(--el-border-color);border-radius:4px;font-size:0;position:relative;cursor:pointer}.el-color-picker__color{position:relative;display:block;box-sizing:border-box;border:1px solid var(--el-text-color-secondary);border-radius:var(--el-border-radius-small);width:100%;height:100%;text-align:center}.el-color-picker__color.is-alpha{background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-size:12px 12px;background-position:0 0,6px 0,6px -6px,0 6px}.el-color-picker__color-inner{display:inline-flex;justify-content:center;align-items:center;width:100%;height:100%}.el-color-picker .el-color-picker__empty{font-size:12px;color:var(--el-text-color-secondary)}.el-color-picker .el-color-picker__icon{display:inline-flex;justify-content:center;align-items:center;color:#fff;font-size:12px}.el-color-picker__panel{position:absolute;z-index:10;padding:6px;box-sizing:content-box;background-color:#fff;border-radius:var(--el-border-radius-base);box-shadow:var(--el-box-shadow-light)}.el-color-picker__panel.el-popper{border:1px solid var(--el-border-color-lighter)}.el-color-picker,.el-color-picker__panel{--el-color-picker-alpha-bg-a:#ccc;--el-color-picker-alpha-bg-b:transparent}.dark .el-color-picker,.dark .el-color-picker__panel{--el-color-picker-alpha-bg-a:#333333}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%}.el-textarea{position:relative;display:inline-block;width:100%;vertical-align:bottom;font-size:var(--el-font-size-base)}.el-textarea__inner{position:relative;display:block;resize:vertical;padding:5px 11px;line-height:1.5;box-sizing:border-box;width:100%;font-size:inherit;font-family:inherit;color:var(--el-input-text-color,var(--el-text-color-regular));background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;-webkit-appearance:none;box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));transition:var(--el-transition-box-shadow);border:none}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{outline:0;box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-textarea .el-input__count{color:var(--el-color-info);background:var(--el-fill-color-blank);position:absolute;font-size:12px;line-height:14px;bottom:5px;right:10px}.el-textarea.is-disabled .el-textarea__inner{box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;background-color:var(--el-disabled-bg-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%}.el-input{--el-input-height:var(--el-component-size);position:relative;font-size:var(--el-font-size-base);display:inline-flex;width:var(--el-input-width);line-height:var(--el-component-size);line-height:var(--el-input-height);box-sizing:border-box;vertical-align:middle}.el-input::-webkit-scrollbar{z-index:11;width:6px}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{border-radius:5px;width:6px;background:var(--el-text-color-disabled)}.el-input::-webkit-scrollbar-corner{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);font-size:14px;cursor:pointer}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{height:100%;display:inline-flex;align-items:center;color:var(--el-color-info);font-size:12px}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);line-height:normal;line-height:initial;display:inline-block;padding-left:8px}.el-input__wrapper{display:inline-flex;flex-grow:1;align-items:center;justify-content:center;padding:1px 11px;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));cursor:text;transition:var(--el-transition-box-shadow);transform:translateZ(0);box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);width:100%;flex-grow:1;-webkit-appearance:none;color:var(--el-input-text-color,var(--el-text-color-regular));font-size:inherit;height:30px;height:var(--el-input-inner-height);line-height:30px;line-height:var(--el-input-inner-height);padding:0;outline:0;border:none;background:0 0;box-sizing:border-box}.el-input__inner:focus{outline:0}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__inner[type=number]{line-height:1}.el-input__prefix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__prefix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__suffix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{height:inherit;line-height:inherit;display:flex;justify-content:center;align-items:center;transition:all var(--el-transition-duration);margin-left:8px}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color,) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{display:inline-flex;width:100%;align-items:stretch}.el-input-group__append,.el-input-group__prepend{background-color:var(--el-fill-color-light);color:var(--el-color-info);position:relative;display:inline-flex;align-items:center;justify-content:center;min-height:100%;border-radius:var(--el-input-border-radius);padding:0 20px;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:0}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-select__wrapper,.el-input-group__append div.el-select:hover .el-select__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-select__wrapper,.el-input-group__prepend div.el-select:hover .el-select__wrapper{border-color:transparent;background-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-right:0;border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-select__wrapper{border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--append>.el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-select__wrapper{border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255, 255, 255, .5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-color-info);--el-button-active-color:var(--el-text-color-primary)}.el-button{display:inline-flex;justify-content:center;align-items:center;line-height:1;height:32px;white-space:nowrap;cursor:pointer;color:var(--el-button-text-color);text-align:center;box-sizing:border-box;outline:0;transition:.1s;font-weight:var(--el-button-font-weight);-webkit-user-select:none;user-select:none;vertical-align:middle;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);padding:8px 15px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button:focus,.el-button:hover{color:var(--el-button-hover-text-color);border-color:var(--el-button-hover-border-color);background-color:var(--el-button-hover-bg-color);outline:0}.el-button:active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button>span{display:inline-flex;align-items:center}.el-button+.el-button{margin-left:12px}.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button.is-disabled,.el-button.is-disabled:focus,.el-button.is-disabled:hover{color:var(--el-button-disabled-text-color);cursor:not-allowed;background-image:none;background-color:var(--el-button-disabled-bg-color);border-color:var(--el-button-disabled-border-color)}.el-button.is-loading{position:relative;pointer-events:none}.el-button.is-loading:before{z-index:1;pointer-events:none;content:"";position:absolute;left:-1px;top:-1px;right:-1px;bottom:-1px;border-radius:inherit;background-color:var(--el-mask-color-extra-light)}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{width:32px;border-radius:50%;padding:8px}.el-button.is-text{color:var(--el-button-text-color);border:0 solid transparent;background-color:transparent}.el-button.is-text.is-disabled{background-color:transparent!important}.el-button.is-text.is-disabled{color:var(--el-button-disabled-text-color)}.el-button.is-text:not(.is-disabled):focus,.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:focus,.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{border-color:transparent;color:var(--el-button-text-color);background:0 0;padding:2px;height:auto}.el-button.is-link:focus,.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{background-color:transparent!important;border-color:transparent!important}.el-button.is-link.is-disabled{color:var(--el-button-disabled-text-color)}.el-button.is-link:not(.is-disabled):focus,.el-button.is-link:not(.is-disabled):hover{border-color:transparent;background-color:transparent}.el-button.is-link:not(.is-disabled):active{color:var(--el-button-active-color);border-color:transparent;background-color:transparent}.el-button--text{border-color:transparent;background:0 0;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{background-color:transparent!important;border-color:transparent!important}.el-button--text.is-disabled{color:var(--el-button-disabled-text-color)}.el-button--text:not(.is-disabled):focus,.el-button--text:not(.is-disabled):hover{color:var(--el-color-primary-light-3);border-color:transparent;background-color:transparent}.el-button--text:not(.is-disabled):active{color:var(--el-color-primary-dark-2);border-color:transparent;background-color:transparent}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{color:var(--el-color-primary-light-5);background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{color:var(--el-color-success-light-5);background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{color:var(--el-color-warning-light-5);background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{color:var(--el-color-danger-light-5);background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{color:var(--el-color-info-light-5);background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8)}.el-button--large{--el-button-size:40px;height:40px;height:var(--el-button-size);padding:12px 19px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{width:var(--el-button-size);padding:12px}.el-button--small{--el-button-size:24px;height:24px;height:var(--el-button-size);padding:5px 11px;font-size:12px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{width:var(--el-button-size);padding:5px}.theme-color-component[data-v-8c2d6ae3]{display:flex;width:100%;flex-direction:column;align-items:flex-start;gap:6px}.theme-color-component .title[data-v-8c2d6ae3]{margin:0;color:var(--minimal-fore);text-align:center}.theme-color-component .picker[data-v-8c2d6ae3]{display:flex;gap:6px}.theme-color-component .picker label[data-v-8c2d6ae3]{color:var(--minimal-fore)}.theme-color-component .reset-button[data-v-8c2d6ae3]{margin-left:auto}.theme-picker{z-index:9999!important}.toggle-button[data-v-83f67b5d]{color:var(--default-fore)}.toggle-button .icon[data-v-83f67b5d],.toggle-button .outline-icon[data-v-83f67b5d]{color:var(--minimal-fore)}.toggle-button.toggle-on[data-v-83f67b5d]{background-color:var(--tieba-theme-color);color:var(--default-background)}.user-textbox{box-sizing:border-box;padding:4px;border:2px solid var(--border-color);border-radius:6px;background-color:var(--default-background);outline:none;transition:.4s ease}.user-textbox.lodash-style{padding:0;border:none;border-radius:0;border-bottom:2px solid var(--border-color)}.user-textbox:hover{border-color:var(--light-background)}.user-textbox:focus{border-color:var(--tieba-theme-color)}html[data-v-dae045ee]{padding:0;margin:0;text-align:justify}body[data-v-dae045ee]{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar][data-v-dae045ee]{overflow:hidden}div[data-v-dae045ee],p[data-v-dae045ee]{margin:0}select[data-v-dae045ee]{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option[data-v-dae045ee]{cursor:pointer}option[data-v-dae045ee]:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a[data-v-dae045ee]{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ[data-v-dae045ee]{position:fixed!important;top:50%!important;left:50%!important}.dialogJ[data-v-dae045ee]{transform:translate(-50%,-50%)}@keyframes content-in-dae045ee{0%{opacity:0;transform:translateY(20px)}to{opacity:1}}.key-button[data-v-dae045ee]{display:flex;overflow:hidden;min-width:80px;align-items:center;padding:12px 16px;border-radius:0;box-shadow:none;font-size:16px;gap:12px;text-align:justify;white-space:nowrap}.key-button .icon[data-v-dae045ee]{font-size:20px;font-variation-settings:"FILL" 0,"wght" 300;transition:font-variation-settings .2s ease}.key-button .key-info[data-v-dae045ee]{display:flex;width:calc(100% - 32px);flex-direction:column}.key-button .key-title[data-v-dae045ee],.key-button .key-desc[data-v-dae045ee]{overflow:hidden;text-overflow:ellipsis}.key-button .key-desc[data-v-dae045ee]{color:var(--minimal-fore);font-size:14px}.key-button.selected[data-v-dae045ee]{background-color:var(--tieba-theme-color)!important;color:var(--default-background)!important}.key-button.selected[data-v-dae045ee]{font-weight:700}.key-button.selected .icon[data-v-dae045ee]{font-variation-settings:"FILL" 1,"GRAD" 48,"wght" 300;font-weight:400}.key-button.selected .key-desc[data-v-dae045ee]{color:var(--default-background)}.settings-wrapper[data-v-dae045ee]{display:flex;overflow:hidden;width:72%;min-width:720px;height:72%;min-height:400px;box-sizing:border-box;border:1px solid var(--light-border-color);border-radius:18px;margin:auto;animation:kf-dialog-in .4s ease;background-color:var(--default-background);box-shadow:0 0 24px #0003}.settings-wrapper .left-container[data-v-dae045ee]{display:flex;width:30%;max-width:280px;flex-direction:column}.settings-wrapper .left-container .search-controls[data-v-dae045ee]{display:flex;flex-direction:column;padding:16px;gap:8px}.settings-wrapper .left-container .search-controls .title[data-v-dae045ee]{margin-top:8px;font-size:20px;font-weight:700}.settings-wrapper .left-container .search-controls .search-box[data-v-dae045ee]{padding:6px;font-size:14px}.settings-wrapper .left-container .left-panel[data-v-dae045ee]{display:flex;box-sizing:border-box;flex-direction:column}.settings-wrapper .middle-container[data-v-dae045ee]{display:flex;width:20%;max-width:220px;flex-direction:column;padding:16px 6px;background-color:var(--deep-background);gap:6px}.settings-wrapper .middle-container .sub-key[data-v-dae045ee]{display:flex;padding:8px 16px;border-radius:12px;gap:4px}.settings-wrapper .middle-container .sub-key .key-title[data-v-dae045ee]{font-size:14px}.settings-wrapper .middle-container .sub-key[data-v-dae045ee]:not(:hover):not(:active):not(:focus){background-color:transparent;background-color:initial}.settings-wrapper .right-container[data-v-dae045ee]{display:flex;overflow:auto;width:50%;flex-direction:column;flex-grow:1;padding:16px;animation:content-in-dae045ee .2s cubic-bezier(0,0,.2,1);background-color:var(--default-background);gap:32px}.settings-wrapper .right-container .setting-content[data-v-dae045ee]{display:flex;flex-direction:column;gap:8px}.settings-wrapper .right-container .setting-content .content-title[data-v-dae045ee]{color:var(--highlight-fore);font-size:18px;font-weight:700}.settings-wrapper .right-container .setting-content .content-sub-title[data-v-dae045ee]{color:var(--default-fore);font-size:16px;font-weight:700}.settings-wrapper .right-container .setting-content .content-desc[data-v-dae045ee]{display:flex;flex-direction:column;color:var(--light-fore);gap:6px}.settings-wrapper .right-container .setting-content .content-textbox[data-v-dae045ee]{margin-left:auto}.settings-wrapper .right-container .setting-content .content-image[data-v-dae045ee]{max-width:100%;max-height:320px;border-radius:8px;margin:0 auto}.settings-wrapper .right-container .setting-content .setting-control[data-v-dae045ee]{display:flex}.settings-wrapper .right-container .setting-content .setting-control .settings-toggle-button[data-v-dae045ee]{margin-left:auto;background:none;font-size:36px}.settings-wrapper .right-container .setting-content .setting-control .settings-toggle-button.toggle-on[data-v-dae045ee]{color:var(--tieba-theme-color)}.settings-wrapper .right-container .setting-content .setting-control .settings-toggle-button.toggle-on[data-v-dae045ee]:hover{color:var(--tieba-theme-fore)}.settings-wrapper .right-container .setting-content .setting-control .icon-component[data-v-dae045ee]{margin-left:auto;font-size:64px;font-variation-settings:"FILL" 1}.settings-wrapper .empty-container[data-v-dae045ee]{margin:auto;color:var(--minimal-fore);font-size:72px}html[data-v-f0bb93e8]{padding:0;margin:0;text-align:justify}body[data-v-f0bb93e8]{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar][data-v-f0bb93e8]{overflow:hidden}div[data-v-f0bb93e8],p[data-v-f0bb93e8]{margin:0}select[data-v-f0bb93e8]{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option[data-v-f0bb93e8]{cursor:pointer}option[data-v-f0bb93e8]:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}.dialogJ[data-v-f0bb93e8]{position:fixed!important;top:50%!important;left:50%!important}.dialogJ[data-v-f0bb93e8]{transform:translate(-50%,-50%)}.index-wrapper .grid-container .profile-menu-container .curr-user .user-profile[data-v-f0bb93e8]{-o-object-fit:contain;object-fit:contain}@keyframes kf-fade-in-f0bb93e8{0%{opacity:0}to{opacity:1}}@keyframes kf-fade-out-f0bb93e8{0%{opacity:1}to{opacity:0}}@keyframes kf-dialog-in-f0bb93e8{0%{opacity:0;transform:scale(1.2)}to{opacity:1;transform:scale(1)}}@keyframes kf-zoom-in-f0bb93e8{0%{transform:scale(.72)}to{transform:scale(1)}}@keyframes kf-fade-zoom-in-f0bb93e8{0%{opacity:0;transform:scale(.72)}to{opacity:1;transform:scale(1)}}a[data-v-f0bb93e8]{color:inherit;-webkit-text-decoration:none;text-decoration:none}.block-wrapper[data-v-f0bb93e8]{display:flex;flex-direction:column;gap:8px}.block-wrapper .block-controls[data-v-f0bb93e8]{display:flex;align-items:center;gap:8px}.block-wrapper .block-controls .block-title[data-v-f0bb93e8]{margin:0;font-size:24px;font-weight:700}.block-wrapper .block-container[data-v-f0bb93e8]{padding:8px;border-radius:12px;background-color:var(--trans-light-background)}body.custom-background .block-wrapper .block-container[data-v-f0bb93e8]{-webkit-backdrop-filter:blur(24px);backdrop-filter:blur(24px)}body.dark-theme body.custom-background .block-wrapper .block-container[data-v-f0bb93e8]{-webkit-backdrop-filter:blur(24px) brightness(.8);backdrop-filter:blur(24px) brightness(.8)}.block-panel[data-v-f0bb93e8]{display:flex;min-width:30px;height:26px;align-items:center;justify-content:center;padding:2px 8px;border-radius:24px;margin-left:auto;background-color:var(--trans-light-background);font-size:14px;text-align:center}.block-panel .icon[data-v-f0bb93e8]{color:var(--light-fore);font-size:18px}.block-panel .panel-btn[data-v-f0bb93e8]{width:30px;height:30px;padding:4px;border:none;border-radius:48px}.block-panel.left-align[data-v-f0bb93e8]{margin-left:0}.index-wrapper[data-v-f0bb93e8]{display:flex;flex-direction:column;align-items:center;gap:12px}.index-wrapper .grid-container[data-v-f0bb93e8]{display:grid;max-width:var(--content-max);margin:16px;grid-gap:36px;gap:36px;grid-template-rows:repeat(1,1fr)}.index-wrapper .grid-container .head-controls[data-v-f0bb93e8]{display:flex;flex-direction:column;align-items:center;padding:24px;margin-top:24px;gap:24px}.index-wrapper .grid-container .head-controls .main-title[data-v-f0bb93e8]{display:flex;align-items:center;justify-content:center;gap:12px}.index-wrapper .grid-container .head-controls .main-title .main-icon[data-v-f0bb93e8]{height:64px}.index-wrapper .grid-container .head-controls .main-title .title[data-v-f0bb93e8]{font-size:36px;font-style:italic;font-weight:700}.index-wrapper .grid-container .head-controls .search-controls[data-v-f0bb93e8]{position:relative;display:grid;width:100%;max-width:420px;justify-content:center;grid-template-columns:1fr 72px}.index-wrapper .grid-container .head-controls .search-controls .search-box[data-v-f0bb93e8]{width:100%;padding:8px;border-bottom-right-radius:0;border-top-right-radius:0;font-size:16px}.index-wrapper .grid-container .head-controls .search-controls .search-button[data-v-f0bb93e8]{border:none;border-bottom-left-radius:0;border-top-left-radius:0;font-size:16px;font-weight:700}.index-wrapper .grid-container .head-controls .search-controls .search-suggestions[data-v-f0bb93e8]{position:absolute;z-index:1;top:100%;display:flex;overflow:hidden;width:100%;box-sizing:border-box;flex-direction:column;border:1px solid var(--border-color);border-radius:6px;margin-top:4px;background-color:var(--default-background);box-shadow:0 0 20px #0003;animation:kf-fade-in-f0bb93e8 .2s}.index-wrapper .grid-container .head-controls .search-controls .search-suggestions .search-elem[data-v-f0bb93e8]{display:flex;overflow:hidden;box-sizing:border-box;padding:8px;border:none;border-radius:0;animation:stretch-f0bb93e8 .2s cubic-bezier(.22,.61,.36,1);gap:8px;text-align:justify}@keyframes stretch-f0bb93e8{0%{padding:4px 8px}to{padding:8px}}.index-wrapper .grid-container .head-controls .search-controls .search-suggestions .search-elem .sugg-img[data-v-f0bb93e8]{width:42px;height:42px;border-radius:8px}.index-wrapper .grid-container .head-controls .search-controls .search-suggestions .search-elem .sugg-content[data-v-f0bb93e8]{position:relative;display:flex;width:calc(100% - 50px);flex-direction:column;justify-content:center;gap:4px}.index-wrapper .grid-container .head-controls .search-controls .search-suggestions .search-elem .sugg-content .sugg-title[data-v-f0bb93e8]{overflow:hidden;margin:0;font-size:14px;font-weight:700;text-overflow:ellipsis;white-space:nowrap}.index-wrapper .grid-container .head-controls .search-controls .search-suggestions .search-elem .sugg-content .sugg-desc[data-v-f0bb93e8]{overflow:hidden;margin:0;color:var(--light-fore);font-size:12px;text-overflow:ellipsis;white-space:nowrap}.index-wrapper .grid-container .profile-menu-container[data-v-f0bb93e8]{position:absolute;z-index:1}.index-wrapper .grid-container .profile-menu-container .curr-user[data-v-f0bb93e8]{position:fixed;top:24px;left:24px;overflow:hidden;width:36px;height:36px;padding:0;border:3px solid var(--border-color);border-radius:36px}.index-wrapper .grid-container .profile-menu-container .curr-user .user-profile[data-v-f0bb93e8]{width:100%}.index-wrapper .grid-container .profile-menu-container .profile-menu[data-v-f0bb93e8]{top:64px;left:24px}.index-wrapper .grid-container .config-menu-container[data-v-f0bb93e8]{position:absolute;z-index:1;display:flex}.index-wrapper .grid-container .config-menu-container .config-menu-btn[data-v-f0bb93e8]{position:fixed;top:24px;right:24px;height:32px;border:none;border-radius:36px;background-color:var(--page-background);font-size:24px}.index-wrapper .grid-container .config-menu-container .config-menu-btn[data-v-f0bb93e8]:hover{background-color:var(--default-background)}.index-wrapper .grid-container .config-menu-container .config-menu-btn[data-v-f0bb93e8]:active{background-color:var(--default-hover)}.index-wrapper .grid-container .config-menu-container .config-menu[data-v-f0bb93e8]{top:64px;right:24px;opacity:1}.index-wrapper .grid-container .signed-count[data-v-f0bb93e8]{font-weight:700}.index-wrapper .grid-container .block-panel.followed[data-v-f0bb93e8]{margin-left:auto}.index-wrapper .grid-container .followed-container[data-v-f0bb93e8]{margin-top:-16px}.index-wrapper .grid-container .followed-container .followed-list[data-v-f0bb93e8]{display:flex;flex-wrap:wrap;padding:8px;border-radius:12px;background-color:var(--trans-light-background);gap:4px}.index-wrapper .grid-container .followed-container .followed-list .followed-btn[data-v-f0bb93e8]{display:flex;align-items:center;padding:6px 8px;border-radius:12px;font-size:14px;gap:6px}.index-wrapper .grid-container .followed-container .followed-list .followed-btn .signed[data-v-f0bb93e8]{color:green;font-weight:700}.index-wrapper .grid-container .followed-container .followed-list .followed-btn .forum-level[data-v-f0bb93e8]{min-width:24px;padding:0 2px;border-radius:24px;font-weight:700;text-align:center}.index-wrapper .grid-container .topic-list[data-v-f0bb93e8]{display:grid;grid-gap:4px;gap:4px;grid-auto-rows:max-content;grid-template-columns:repeat(2,1fr)}.index-wrapper .grid-container .topic-list .topic-btn[data-v-f0bb93e8]{display:flex;width:100%;height:100%;align-items:center;padding:12px;border-radius:12px;gap:8px}.index-wrapper .grid-container .topic-list .topic-btn .topic-img[data-v-f0bb93e8]{width:72px;border-radius:12px}.index-wrapper .grid-container .topic-list .topic-btn .topic-content[data-v-f0bb93e8]{display:flex;flex-flow:column wrap;gap:4px;text-align:justify}.index-wrapper .grid-container .topic-list .topic-btn .topic-content .topic-title[data-v-f0bb93e8]{display:flex;align-items:center;gap:6px}.index-wrapper .grid-container .topic-list .topic-btn .topic-content .topic-title [class^=topic-rank][data-v-f0bb93e8]{padding:0 4px;border-radius:4px;background-color:orange;color:var(--default-background);font-weight:700;text-align:center}.index-wrapper .grid-container .topic-list .topic-btn .topic-content .topic-title .topic-name[data-v-f0bb93e8]{font-size:16px;font-weight:700}.index-wrapper .grid-container .topic-list .topic-btn .topic-content .topic-desc[data-v-f0bb93e8]{color:var(--light-fore);font-size:14px}.index-wrapper .masonry-container[data-v-f0bb93e8]{display:flex;box-sizing:border-box;flex-direction:column;align-items:center;gap:8px}.index-wrapper .masonry-container .feeds-container[data-v-f0bb93e8]{width:100%;margin:auto}@keyframes feeds-in-f0bb93e8{0%{transform:scale(.72)}to{transform:scale(1)}}@keyframes refresh-btn-in-f0bb93e8{0%{padding:0 18px;opacity:0}to{padding:8px 18px;opacity:1}}.index-wrapper .masonry-container .feeds-container .feeds-refresh-btn[data-v-f0bb93e8]{position:fixed;z-index:1;bottom:24px;left:50%;display:flex;align-items:center;justify-content:center;padding:8px 18px;border-width:2px;border-radius:16px;animation:refresh-btn-in-f0bb93e8 .4s ease;box-shadow:0 6px 20px #0000004d;font-size:14px;font-weight:700;gap:6px;transform:translate(-50%)}.index-wrapper .masonry-container .feeds-container .feeds-refresh-btn .icon[data-v-f0bb93e8]{font-size:18px}.index-wrapper .masonry-container .post-elem[data-v-f0bb93e8]{animation:feeds-in-f0bb93e8 .4s cubic-bezier(.18,.89,.32,1.2)}.index-wrapper .masonry-container .post-elem[data-v-f0bb93e8]:not(:hover):not(:active):not(:focus){box-shadow:none}.index-wrapper .masonry-container .empty-container .no-feed-content[data-v-f0bb93e8]{color:var(--minimal-fore);font-size:small;text-align:center}html[data-v-00bee924]{padding:0;margin:0;text-align:justify}body[data-v-00bee924]{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar][data-v-00bee924]{overflow:hidden}div[data-v-00bee924],p[data-v-00bee924]{margin:0}select[data-v-00bee924]{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option[data-v-00bee924]{cursor:pointer}option[data-v-00bee924]:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a[data-v-00bee924]{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ[data-v-00bee924]{position:fixed!important;top:50%!important;left:50%!important}.dialogJ[data-v-00bee924]{transform:translate(-50%,-50%)}@keyframes kf-fade-in-00bee924{0%{opacity:0}to{opacity:1}}@keyframes kf-fade-out-00bee924{0%{opacity:1}to{opacity:0}}@keyframes kf-dialog-in-00bee924{0%{opacity:0;transform:scale(1.2)}to{opacity:1;transform:scale(1)}}@keyframes kf-zoom-in-00bee924{0%{transform:scale(.72)}to{transform:scale(1)}}@keyframes kf-fade-zoom-in-00bee924{0%{opacity:0;transform:scale(.72)}to{opacity:1;transform:scale(1)}}@keyframes stretch-00bee924{0%{padding:2px 14px}to{padding:4px 14px}}a[data-v-00bee924]{color:inherit}.dropdown-menu[data-v-00bee924]{position:fixed;z-index:1;display:flex;overflow:hidden;width:-moz-max-content;width:max-content;min-width:120px;flex-direction:column;padding:4px;border:1px solid var(--border-color);border-radius:8px;background-color:var(--default-background);box-shadow:0 0 20px #00000014;font-size:14px;animation:kf-fade-in-00bee924 .1s}.dropdown-menu .menu-item[data-v-00bee924]{display:flex;width:100%;align-items:center;padding:4px 14px;border:none;border-radius:6px;animation:stretch-00bee924 .1s cubic-bezier(.22,.61,.36,1);background:none;color:var(--default-fore);gap:6px;transition:.2s}.dropdown-menu .menu-item .menu-title[data-v-00bee924]{display:flex;width:100%;gap:12px;text-align:justify}.dropdown-menu .menu-item .menu-title .menu-inner[data-v-00bee924]{margin-left:auto;color:var(--minimal-fore)}.dropdown-menu .menu-item[data-v-00bee924]:hover{background-color:var(--default-hover)}.dropdown-menu .menu-item[data-v-00bee924]:active{background-color:var(--default-active)}.dropdown-menu .menu-separator[data-v-00bee924]{width:calc(100% + 8px);height:1px;margin:6px 0 6px -4px;background-color:var(--border-color)}.blur-effect[data-v-00bee924]{background-color:var(--trans-default-background);-webkit-backdrop-filter:blur(24px);backdrop-filter:blur(24px)}body.dark-theme .blur-effect[data-v-00bee924]{-webkit-backdrop-filter:blur(24px) brightness(.8);backdrop-filter:blur(24px) brightness(.8)}html[data-v-18e85ac3]{padding:0;margin:0;text-align:justify}body[data-v-18e85ac3]{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar][data-v-18e85ac3]{overflow:hidden}div[data-v-18e85ac3],p[data-v-18e85ac3]{margin:0}select[data-v-18e85ac3]{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option[data-v-18e85ac3]{cursor:pointer}option[data-v-18e85ac3]:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a[data-v-18e85ac3]{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ[data-v-18e85ac3]{position:fixed!important;top:50%!important;left:50%!important}.dialogJ[data-v-18e85ac3]{transform:translate(-50%,-50%)}@keyframes kf-fade-in-18e85ac3{0%{opacity:0}to{opacity:1}}@keyframes kf-fade-out-18e85ac3{0%{opacity:1}to{opacity:0}}@keyframes kf-dialog-in-18e85ac3{0%{opacity:0;transform:scale(1.2)}to{opacity:1;transform:scale(1)}}@keyframes kf-zoom-in-18e85ac3{0%{transform:scale(.72)}to{transform:scale(1)}}@keyframes kf-fade-zoom-in-18e85ac3{0%{opacity:0;transform:scale(.72)}to{opacity:1;transform:scale(1)}}#nav-bar[data-v-18e85ac3]{position:fixed;z-index:1200;top:0;left:0;display:flex;width:100vw;height:48px;box-sizing:border-box;align-items:center;justify-content:space-around;padding:4px;border-bottom:1px solid var(--border-color);background-color:var(--trans-page-background);-webkit-backdrop-filter:blur(24px);backdrop-filter:blur(24px);box-shadow:0 10px 10px #00000003}body.dark-theme #nav-bar[data-v-18e85ac3]{-webkit-backdrop-filter:blur(24px) brightness(.8);backdrop-filter:blur(24px) brightness(.8)}body.dark-theme #nav-bar[data-v-18e85ac3]{box-shadow:0 10px 16px #0003}#nav-bar .nav-button[data-v-18e85ac3]:not(:hover):not(:active):not(:focus){background-color:#0000}#nav-bar .left-container .nav-title-container[data-v-18e85ac3]{display:flex;align-items:center;border:none;background:none;gap:8px;-webkit-text-decoration:underline 3px var(--tieba-theme-color);text-decoration:underline 3px var(--tieba-theme-color)}#nav-bar .left-container .nav-title-container .nav-icon[data-v-18e85ac3]{width:36px}#nav-bar .left-container .nav-title-container .nav-title[data-v-18e85ac3]{color:var(--default-fore);font-size:20px;font-style:italic;font-weight:700;transition:.2s}#nav-bar .left-container .nav-title-container:hover .nav-title[data-v-18e85ac3],#nav-bar .left-container .nav-title-container:active .nav-title[data-v-18e85ac3],#nav-bar .left-container .nav-title-container:focus .nav-title[data-v-18e85ac3]{color:var(--highlight-fore)}#nav-bar .middle-container[data-v-18e85ac3]{display:flex;height:100%;justify-content:center}#nav-bar .middle-container .middle-menu-container[data-v-18e85ac3]{height:100%;padding:0 10px;border:none;background:none;color:var(--default-fore);font-size:15px;font-weight:700;text-decoration:underline;-webkit-text-decoration:underline solid rgba(0,0,0,0);text-decoration:underline solid rgba(0,0,0,0);text-decoration-thickness:2px;-webkit-text-decoration:underline 2px rgba(0,0,0,0);text-decoration:underline 2px rgba(0,0,0,0)}#nav-bar .middle-container .middle-menu-container[data-v-18e85ac3]:hover{-webkit-text-decoration:underline 2px var(--tieba-theme-color);text-decoration:underline 2px var(--tieba-theme-color)}#nav-bar .right-container[data-v-18e85ac3]{display:flex;align-items:center;gap:8px}#nav-bar .right-container .avatar-button[data-v-18e85ac3]{width:32px;height:32px;padding:0;border:4px;border-radius:32px}#nav-bar .right-container .avatar-button .nav-avatar[data-v-18e85ac3]{width:100%;border-radius:24px}#nav-bar .right-container .nav-menu[data-v-18e85ac3]{padding:2px 8px;border:none;border-radius:24px;color:var(--highlight-fore);font-size:26px}#nav-bar .right-container .nav-menu[data-v-18e85ac3]:not(:active):not(:focus){box-shadow:none}.menu-container:hover>.dropdown-menu[data-v-18e85ac3],.menu-container:active>.dropdown-menu[data-v-18e85ac3]{display:block;animation:kf-fade-in-18e85ac3 .2s}.dropdown-menu[data-v-18e85ac3]{z-index:1201;display:none;cursor:default;font-weight:400;animation:kf-fade-out-18e85ac3 .2s}@keyframes slide-in-9c94de19{0%{opacity:0;transform:translateY(20%)}}#thread-editor[data-v-9c94de19]{bottom:0;left:50%;display:flex;width:100%;max-width:var(--content-max);max-height:100vh;box-sizing:border-box;flex-direction:column;align-items:center;padding:24px;border-radius:8px 8px 0 0;margin:auto auto 0;animation:slide-in-9c94de19 .4s ease;background-color:var(--default-background);gap:8px;transition:.4s}#thread-editor #thread-editor-exit[data-v-9c94de19]{margin-left:auto;font-size:18px}#thread-editor #thread-editor-exit[data-v-9c94de19]:not(:hover):not(:active):not(:focus){box-shadow:none}#thread-editor .title-editor[data-v-9c94de19]{width:100%;flex-grow:1;border-width:3px;background-color:transparent;font-size:24px;font-weight:700}#thread-editor h1[data-v-9c94de19]{margin-right:auto}#thread-editor #thread-editor-slot[data-v-9c94de19]{width:100%;flex-shrink:2}#thread-editor #thread-editor-toolbar[data-v-9c94de19]{display:flex;width:100%;align-items:center}#thread-editor #thread-editor-toolbar #thread-editor-submit[data-v-9c94de19]{padding:4px 12px;margin-left:auto;font-size:16px;font-weight:700}#thread-editor .edui-container .edui-toolbar .edui-btn-toolbar .edui-btn .edui-icon:before{font-family:Material Symbols,monospace;font-variation-settings:"FILL" 0,"wght" 400,"GRAD" 0,"opsz" 40;-webkit-user-select:none;-moz-user-select:none;user-select:none}body{overflow-x:hidden;overflow-y:scroll;overflow:hidden scroll}#thread-editor .edui-container{width:100%!important}#thread-editor .edui-container .edui-toolbar{height:auto;align-items:center;background-color:transparent}#thread-editor .edui-container .edui-toolbar .edui-btn-toolbar{display:flex;background-color:transparent;gap:8px}#thread-editor .edui-container .edui-toolbar .edui-btn-toolbar .edui-btn{padding:1px;border-radius:4px;margin-right:0;background:none;background-color:var(--light-background);box-shadow:0 0 0 1px var(--border-color);cursor:pointer;transition:.4s}#thread-editor .edui-container .edui-toolbar .edui-btn-toolbar .edui-btn .edui-icon{display:flex;width:-moz-max-content;width:max-content;align-items:center;padding:2px 4px;background:none;gap:4px}#thread-editor .edui-container .edui-toolbar .edui-btn-toolbar .edui-btn .edui-icon:before{font-size:16px}#thread-editor .edui-container .edui-toolbar .edui-dialog-container .edui-dropdown-menu{overflow:hidden;width:-moz-max-content;width:max-content;padding:0;border:2px solid var(--border-color);border-radius:6px;background:none}#thread-editor .edui-container .edui-toolbar .edui-dialog-container .edui-dropdown-menu .edui-popup-body{padding:0;border:none;background-color:var(--default-background)}#thread-editor .edui-container .edui-toolbar .edui-dialog-container .edui-dropdown-menu .edui-popup-caret{display:none}#thread-editor .edui-container .edui-editor-body{border:none;border-radius:0;border-bottom:3px solid var(--tieba-theme-color);transition:.4s}#thread-editor .edui-container .edui-editor-body:hover{border-color:var(--light-background)}#thread-editor .edui-container .edui-editor-body:focus{border-color:var(--tieba-theme-color)}#thread-editor .edui-container .edui-body-container{min-height:18px!important}#thread-editor .edui-container .edui-body-container{max-height:50vh;padding:0;border-radius:0;background-color:transparent}.edui-btn-topic{display:none!important}#thread-editor .edui-btn-toolbar .edui-icon.edui-icon-medal:before{content:"diamond"}#thread-editor .edui-btn-toolbar .edui-icon.edui-icon-medal:after{content:"\u7279\u6743"}#thread-editor .edui-btn-toolbar .edui-icon.edui-icon-image:before{content:"photo"}#thread-editor .edui-btn-toolbar .edui-icon.edui-icon-image:after{content:"\u63D2\u5165\u56FE\u7247"}#thread-editor .edui-btn-toolbar .edui-icon.edui-icon-video:before{content:"video_file"}#thread-editor .edui-btn-toolbar .edui-icon.edui-icon-video:after{content:"\u63D2\u5165\u89C6\u9891"}#thread-editor .edui-btn-toolbar .edui-icon.edui-icon-emotion:before{content:"face"}#thread-editor .edui-btn-toolbar .edui-icon.edui-icon-emotion:after{content:"\u63D2\u5165\u8868\u60C5"}#thread-editor .edui-btn-toolbar .edui-icon.edui-icon-scrawl:before{content:"format_paint"}#thread-editor .edui-btn-toolbar .edui-icon.edui-icon-scrawl:after{content:"\u6D82\u9E26"}#thread-editor .edui-btn-toolbar .edui-icon.edui-icon-topic:before{content:"grid_3x3"}#thread-editor .edui-btn-toolbar .edui-icon.edui-icon-topic:after{content:"\u8BDD\u9898"}#thread-editor .edui-btn-toolbar .edui-icon.edui-icon-quick-reply:before{content:"rocket_launch"}#thread-editor .edui-btn-toolbar .edui-icon.edui-icon-quick-reply:after{content:"\u5FEB\u901F\u56DE\u5E16"}.edui-popup-body .layer_medal_list li a:before,.edui-popup-body .layer_btn_list li a:before{font-family:Material Symbols,monospace;font-variation-settings:"FILL" 0,"wght" 400,"GRAD" 0,"opsz" 40;-webkit-user-select:none;-moz-user-select:none;user-select:none}.edui-dialog-container .upload_container .next_step,.edui-popup-body .layer_medal_list li a,.edui-popup-body .layer_btn_list li a{box-sizing:border-box;padding:2px 8px;border:none;border-radius:6px;background:none;background-color:var(--default-background);box-shadow:0 0 0 1px var(--border-color);color:var(--default-fore);cursor:pointer;transition:.4s}.edui-dialog-container .upload_container .theme-style.next_step,.edui-popup-body .layer_medal_list li a.theme-style,.edui-popup-body .layer_btn_list li a.theme-style{color:var(--default-background)!important}.edui-dialog-container .upload_container .theme-style.next_step,.edui-popup-body .layer_medal_list li a.theme-style,.edui-popup-body .layer_btn_list li a.theme-style{background-color:var(--tieba-theme-color)}.edui-dialog-container .upload_container .theme-style.next_step:hover,.edui-popup-body .layer_medal_list li a.theme-style:hover,.edui-popup-body .layer_btn_list li a.theme-style:hover{background-color:var(--tieba-theme-hover)}.edui-dialog-container .upload_container .theme-style.next_step:active,.edui-popup-body .layer_medal_list li a.theme-style:active,.edui-popup-body .layer_btn_list li a.theme-style:active{background-color:var(--tieba-theme-active)}.edui-dialog-container .upload_container .unset-background.next_step,.edui-popup-body .layer_medal_list li a.unset-background,.edui-popup-body .layer_btn_list li a.unset-background{background-color:transparent;background-color:initial}.edui-dialog-container .upload_container .no-border.next_step,.edui-popup-body .layer_medal_list li a.no-border,.edui-popup-body .layer_btn_list li a.no-border{box-shadow:none}.edui-dialog-container .upload_container .next_step:hover,.edui-popup-body .layer_medal_list li a:hover,.edui-popup-body .layer_btn_list li a:hover{background-color:var(--default-hover)}.edui-dialog-container .upload_container .next_step:active,.edui-popup-body .layer_medal_list li a:active,.edui-popup-body .layer_btn_list li a:active{background-color:var(--default-active)}.edui-dialog-container .upload_container .next_step:focus,.edui-popup-body .layer_medal_list li a:focus,.edui-popup-body .layer_btn_list li a:focus{border-color:var(--tieba-theme-color);box-shadow:0 0 0 2px var(--tieba-theme-color)}.edui-dialog-container .edui-popup{position:static!important}.edui-dialog-container .upload_container{padding:0 20px 20px 0}.edui-dialog-container .upload_container .slide_item_img{border-color:var(--tieba-theme-color)!important}.edui-dialog-container .upload_container .slide_item_img{overflow:hidden}.edui-dialog-container .upload_container .watermark_options{position:static;margin-left:20px}.edui-dialog-container .upload_container .next_step{position:static;width:-moz-max-content;width:max-content;height:-moz-max-content;height:max-content;padding:4px 8px;margin-left:auto;line-height:normal}.edui-popup-body{position:static}.edui-popup-body .layer_medal_list,.edui-popup-body .layer_btn_list{width:-moz-max-content;width:max-content;height:-moz-max-content;height:max-content}.edui-popup-body .layer_medal_list li,.edui-popup-body .layer_btn_list li{display:flex;overflow:hidden;align-items:center;padding:0;background:none}.edui-popup-body .layer_medal_list li a,.edui-popup-body .layer_btn_list li a{display:flex;width:-moz-max-content;width:max-content;height:-moz-max-content;height:max-content;align-items:center;padding:4px 8px;border-radius:0;box-shadow:none;gap:4px}.edui-popup-body .layer_medal_list li a:before,.edui-popup-body .layer_btn_list li a:before{font-size:16px}.layer_medal_list li.post_bubble a:before{content:"bubble_chart"}.layer_medal_list li.post_bubble a:after{content:"\u53D1\u5E16\u6C14\u6CE1"}.layer_medal_list li.colorful_font a:before{content:"format_color_text"}.layer_medal_list li.colorful_font a:after{content:"\u5F69\u8272\u5B57\u4F53"}.layer_btn_list{padding:0!important}.layer_btn_list li{border:none!important}.layer_btn_list li.from_upload a:before{content:"upload_file"}.layer_btn_list li.from_upload a:after{content:"\u4E0A\u4F20\u6587\u4EF6"}.layer_btn_list li.from_web a:before{content:"web"}.layer_btn_list li.from_web a:after{content:"\u7F51\u7EDC\u56FE\u7247"}html{padding:0;margin:0;text-align:justify}body{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar]{overflow:hidden}div,p{margin:0}select{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option{cursor:pointer}option:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ{position:fixed!important;top:50%!important;left:50%!important}.dialogJ{transform:translate(-50%,-50%)}#thread-editor .emotion_container .ueditor_emotion_tab .s_prev:before,#thread-editor .emotion_container .ueditor_emotion_tab .s_next:before{font-family:Material Symbols,monospace;font-variation-settings:"FILL" 0,"wght" 400,"GRAD" 0,"opsz" 40;-webkit-user-select:none;-moz-user-select:none;user-select:none}@keyframes kf-fade-in{0%{opacity:0}to{opacity:1}}@keyframes kf-fade-out{0%{opacity:1}to{opacity:0}}@keyframes kf-dialog-in{0%{opacity:0;transform:scale(1.2)}to{opacity:1;transform:scale(1)}}@keyframes kf-zoom-in{0%{transform:scale(.72)}to{transform:scale(1)}}@keyframes kf-fade-zoom-in{0%{opacity:0;transform:scale(.72)}to{opacity:1;transform:scale(1)}}#thread-editor .emotion_container .ueditor_emotion_tab .s_prev,#thread-editor .emotion_container .ueditor_emotion_tab .s_next{box-sizing:border-box;padding:2px 8px;border:none;border-radius:6px;background:none;background-color:var(--default-background);box-shadow:0 0 0 1px var(--border-color);color:var(--default-fore);cursor:pointer;transition:.4s}#thread-editor .emotion_container .ueditor_emotion_tab .theme-style.s_prev,#thread-editor .emotion_container .ueditor_emotion_tab .theme-style.s_next{color:var(--default-background)!important}#thread-editor .emotion_container .ueditor_emotion_tab .theme-style.s_prev,#thread-editor .emotion_container .ueditor_emotion_tab .theme-style.s_next{background-color:var(--tieba-theme-color)}#thread-editor .emotion_container .ueditor_emotion_tab .theme-style.s_prev:hover,#thread-editor .emotion_container .ueditor_emotion_tab .theme-style.s_next:hover{background-color:var(--tieba-theme-hover)}#thread-editor .emotion_container .ueditor_emotion_tab .theme-style.s_prev:active,#thread-editor .emotion_container .ueditor_emotion_tab .theme-style.s_next:active{background-color:var(--tieba-theme-active)}#thread-editor .emotion_container .ueditor_emotion_tab .unset-background.s_prev,#thread-editor .emotion_container .ueditor_emotion_tab .unset-background.s_next{background-color:transparent;background-color:initial}#thread-editor .emotion_container .ueditor_emotion_tab .no-border.s_prev,#thread-editor .emotion_container .ueditor_emotion_tab .no-border.s_next{box-shadow:none}#thread-editor .emotion_container .ueditor_emotion_tab .s_prev:hover,#thread-editor .emotion_container .ueditor_emotion_tab .s_next:hover{background-color:var(--default-hover)}#thread-editor .emotion_container .ueditor_emotion_tab .s_prev:active,#thread-editor .emotion_container .ueditor_emotion_tab .s_next:active{background-color:var(--default-active)}#thread-editor .emotion_container .ueditor_emotion_tab .s_prev:focus,#thread-editor .emotion_container .ueditor_emotion_tab .s_next:focus{border-color:var(--tieba-theme-color);box-shadow:0 0 0 2px var(--tieba-theme-color)}#thread-editor .emotion_container .tbui_scroll_panel{overflow:hidden;border-radius:4px 4px 0 0}body.dark-theme #thread-editor .emotion_container td,body.dark-theme #thread-editor .emotion_container .emotion_preview{filter:brightness(.8)}#thread-editor .emotion_container .emotion_preview{border:1px solid var(--border-color);border-radius:6px;box-shadow:0 0 10px #00000003}body.dark-theme #thread-editor .emotion_container .emotion_preview{box-shadow:0 0 16px #0003}#thread-editor .emotion_container .ueditor_emotion_tab{display:flex;align-items:center;justify-content:space-evenly;border-top:2px solid var(--border-color);background:none;background-color:var(--default-background);color:var(--default-fore)}#thread-editor .emotion_container .ueditor_emotion_tab .s_prev,#thread-editor .emotion_container .ueditor_emotion_tab .s_next{width:-moz-max-content!important;width:max-content!important;height:-moz-max-content!important;height:max-content!important}#thread-editor .emotion_container .ueditor_emotion_tab .s_prev,#thread-editor .emotion_container .ueditor_emotion_tab .s_next{position:static;padding:0 2px;background:none;box-shadow:none}#thread-editor .emotion_container .ueditor_emotion_tab .s_prev:before,#thread-editor .emotion_container .ueditor_emotion_tab .s_next:before{font-size:10px}#thread-editor .emotion_container .ueditor_emotion_tab .s_prev:before{content:"arrow_back_ios"}#thread-editor .emotion_container .ueditor_emotion_tab .s_next:before{content:"arrow_forward_ios"}#thread-editor .emotion_container .ueditor_emotion_tab .s_tab_con_wrapper{position:static}#thread-editor .emotion_container .ueditor_emotion_tab .s_tab_con_wrapper .s_tab_btn{border-radius:4px;background:none;background-color:var(--default-background)}#thread-editor .emotion_container .ueditor_emotion_tab .s_tab_con_wrapper .s_tab_btn .s_tab_btnbg{border-radius:4px;background:none;transition:.4s}#thread-editor .emotion_container .ueditor_emotion_tab .s_tab_con_wrapper .s_hover{filter:brightness(1.2)}#thread-editor .emotion_container .ueditor_emotion_tab .s_tab_con_wrapper .s_hover .s_tab_btnbg{filter:brightness(1.4)}#thread-editor .emotion_container .ueditor_emotion_tab .s_tab_con_wrapper .selected{background:none}#thread-editor .emotion_container .ueditor_emotion_tab .s_tab_con_wrapper .selected .s_tab_btnbg{background-color:var(--tieba-theme-color);color:var(--default-background);font-weight:700}html[data-v-521b9a21]{padding:0;margin:0;text-align:justify}body[data-v-521b9a21]{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar][data-v-521b9a21]{overflow:hidden}div[data-v-521b9a21],p[data-v-521b9a21]{margin:0}select[data-v-521b9a21]{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option[data-v-521b9a21]{cursor:pointer}option[data-v-521b9a21]:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a[data-v-521b9a21]{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ[data-v-521b9a21]{position:fixed!important;top:50%!important;left:50%!important}.dialogJ[data-v-521b9a21]{transform:translate(-50%,-50%)}.toggle-panel[data-v-521b9a21]{display:flex;overflow:hidden;max-width:60vh;max-height:60vh;box-sizing:border-box;flex-direction:column;padding:12px;border:1px solid var(--light-border-color);border-radius:16px;margin:auto;animation:kf-dialog-in .4s ease;background-color:var(--default-background);box-shadow:0 0 10px #0000001a;color:var(--default-fore);transition:.4s ease}.toggle-panel .toggle-wrapper[data-v-521b9a21]{display:flex;flex-wrap:wrap;justify-content:center;gap:8px}.toggle-panel .toggle-wrapper .toggle-container[data-v-521b9a21]{display:flex;flex-direction:column;align-items:center;gap:4px}.toggle-panel .toggle-wrapper .toggle-container .panel-button[data-v-521b9a21]{width:58px;height:58px;border-radius:12px;font-size:24px}.toggle-panel .toggle-wrapper .toggle-container .panel-button.toggle-off[data-v-521b9a21]{color:var(--minimal-fore)}.toggle-panel .toggle-wrapper .toggle-container .panel-button.toggle-on[data-v-521b9a21]:focus{box-shadow:0 0 0 1px var(--tieba-theme-color)}.toggle-panel .toggle-wrapper .toggle-container .toggle-name[data-v-521b9a21]{color:var(--light-fore)}.el-pagination{--el-pagination-font-size:14px;--el-pagination-bg-color:var(--el-fill-color-blank);--el-pagination-text-color:var(--el-text-color-primary);--el-pagination-border-radius:2px;--el-pagination-button-color:var(--el-text-color-primary);--el-pagination-button-width:32px;--el-pagination-button-height:32px;--el-pagination-button-disabled-color:var(--el-text-color-placeholder);--el-pagination-button-disabled-bg-color:var(--el-fill-color-blank);--el-pagination-button-bg-color:var(--el-fill-color);--el-pagination-hover-color:var(--el-color-primary);--el-pagination-font-size-small:12px;--el-pagination-button-width-small:24px;--el-pagination-button-height-small:24px;--el-pagination-item-gap:16px;white-space:nowrap;color:var(--el-text-color-primary);color:var(--el-pagination-text-color);font-size:14px;font-size:var(--el-pagination-font-size);font-weight:400;display:flex;align-items:center}.el-pagination .el-input__inner{text-align:center;-moz-appearance:textfield}.el-pagination .el-select{width:128px}.el-pagination button{display:flex;justify-content:center;align-items:center;font-size:var(--el-pagination-font-size);min-width:var(--el-pagination-button-width);height:var(--el-pagination-button-height);line-height:var(--el-pagination-button-height);color:var(--el-pagination-button-color);background:var(--el-pagination-bg-color);padding:0 4px;border:none;border-radius:var(--el-pagination-border-radius);cursor:pointer;text-align:center;box-sizing:border-box}.el-pagination button *{pointer-events:none}.el-pagination button:focus{outline:0}.el-pagination button:hover{color:var(--el-pagination-hover-color)}.el-pagination button.is-active{color:var(--el-pagination-hover-color);cursor:default;font-weight:700}.el-pagination button.is-active.is-disabled{font-weight:700;color:var(--el-text-color-secondary)}.el-pagination button.is-disabled,.el-pagination button:disabled{color:var(--el-pagination-button-disabled-color);background-color:var(--el-pagination-button-disabled-bg-color);cursor:not-allowed}.el-pagination button:focus-visible{outline:1px solid var(--el-pagination-hover-color);outline-offset:-1px}.el-pagination .btn-next .el-icon,.el-pagination .btn-prev .el-icon{display:block;font-size:12px;font-weight:700;width:inherit}.el-pagination>.is-first{margin-left:0!important}.el-pagination>.is-last{margin-right:0!important}.el-pagination .btn-prev{margin-left:var(--el-pagination-item-gap)}.el-pagination__sizes,.el-pagination__total{margin-left:var(--el-pagination-item-gap);font-weight:400;color:var(--el-text-color-regular)}.el-pagination__total[disabled=true]{color:var(--el-text-color-placeholder)}.el-pagination__jump{display:flex;align-items:center;margin-left:var(--el-pagination-item-gap);font-weight:400;color:var(--el-text-color-regular)}.el-pagination__jump[disabled=true]{color:var(--el-text-color-placeholder)}.el-pagination__goto{margin-right:8px}.el-pagination__editor{text-align:center;box-sizing:border-box}.el-pagination__editor.el-input{width:56px}.el-pagination__editor .el-input__inner::-webkit-inner-spin-button,.el-pagination__editor .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-pagination__classifier{margin-left:8px}.el-pagination__rightwrapper{flex:1;display:flex;align-items:center;justify-content:flex-end}.el-pagination.is-background .btn-next,.el-pagination.is-background .btn-prev,.el-pagination.is-background .el-pager li{margin:0 4px;background-color:var(--el-pagination-button-bg-color)}.el-pagination.is-background .btn-next.is-active,.el-pagination.is-background .btn-prev.is-active,.el-pagination.is-background .el-pager li.is-active{background-color:var(--el-color-primary);color:var(--el-color-white)}.el-pagination.is-background .btn-next.is-disabled,.el-pagination.is-background .btn-next:disabled,.el-pagination.is-background .btn-prev.is-disabled,.el-pagination.is-background .btn-prev:disabled,.el-pagination.is-background .el-pager li.is-disabled,.el-pagination.is-background .el-pager li:disabled{color:var(--el-text-color-placeholder);background-color:var(--el-disabled-bg-color)}.el-pagination.is-background .btn-next.is-disabled.is-active,.el-pagination.is-background .btn-next:disabled.is-active,.el-pagination.is-background .btn-prev.is-disabled.is-active,.el-pagination.is-background .btn-prev:disabled.is-active,.el-pagination.is-background .el-pager li.is-disabled.is-active,.el-pagination.is-background .el-pager li:disabled.is-active{color:var(--el-text-color-secondary);background-color:var(--el-fill-color-dark)}.el-pagination.is-background .btn-prev{margin-left:var(--el-pagination-item-gap)}.el-pagination--small .btn-next,.el-pagination--small .btn-prev,.el-pagination--small .el-pager li{height:var(--el-pagination-button-height-small);line-height:var(--el-pagination-button-height-small);font-size:var(--el-pagination-font-size-small);min-width:var(--el-pagination-button-width-small)}.el-pagination--small button,.el-pagination--small span:not([class*=suffix]){font-size:var(--el-pagination-font-size-small)}.el-pagination--small .el-select{width:100px}.el-pager{-webkit-user-select:none;user-select:none;list-style:none;font-size:0;padding:0;margin:0;display:flex;align-items:center}.el-pager li{display:flex;justify-content:center;align-items:center;font-size:var(--el-pagination-font-size);min-width:var(--el-pagination-button-width);height:var(--el-pagination-button-height);line-height:var(--el-pagination-button-height);color:var(--el-pagination-button-color);background:var(--el-pagination-bg-color);padding:0 4px;border:none;border-radius:var(--el-pagination-border-radius);cursor:pointer;text-align:center;box-sizing:border-box}.el-pager li *{pointer-events:none}.el-pager li:focus{outline:0}.el-pager li:hover{color:var(--el-pagination-hover-color)}.el-pager li.is-active{color:var(--el-pagination-hover-color);cursor:default;font-weight:700}.el-pager li.is-active.is-disabled{font-weight:700;color:var(--el-text-color-secondary)}.el-pager li.is-disabled,.el-pager li:disabled{color:var(--el-pagination-button-disabled-color);background-color:var(--el-pagination-button-disabled-bg-color);cursor:not-allowed}.el-pager li:focus-visible{outline:1px solid var(--el-pagination-hover-color);outline-offset:-1px}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px}.el-tag{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary);--el-tag-text-color:var(--el-color-primary);background-color:var(--el-color-primary-light-9);background-color:var(--el-tag-bg-color);border-color:var(--el-color-primary-light-8);border-color:var(--el-tag-border-color);color:var(--el-color-primary);color:var(--el-tag-text-color);display:inline-flex;justify-content:center;align-items:center;vertical-align:middle;height:24px;padding:0 9px;font-size:var(--el-tag-font-size);line-height:1;border-width:1px;border-style:solid;border-radius:var(--el-tag-border-radius);box-sizing:border-box;white-space:nowrap;--el-icon-size:14px}.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{flex-shrink:0;color:var(--el-tag-text-color)}.el-tag .el-tag__close:hover{color:var(--el-color-white);background-color:var(--el-tag-hover-color)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3);--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--primary,.el-tag--dark.el-tag--success,.el-tag--dark.el-tag--warning,.el-tag--dark.el-tag--danger,.el-tag--dark.el-tag--error,.el-tag--dark.el-tag--info{--el-tag-text-color:var(--el-color-white)}.el-tag--plain{--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary);--el-tag-bg-color:var(--el-fill-color-blank)}.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{padding:0 11px;height:32px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{padding:0 7px;height:20px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-scrollbar{--el-scrollbar-opacity:.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary)}.el-scrollbar{overflow:hidden;position:relative;height:100%}.el-scrollbar__wrap{overflow:auto;height:100%}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{position:relative;display:block;width:0;height:0;cursor:pointer;border-radius:inherit;background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));transition:var(--el-transition-duration) background-color;opacity:.3;opacity:var(--el-scrollbar-opacity,.3)}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:.5;opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{position:absolute;right:2px;bottom:2px;z-index:1;border-radius:4px}.el-scrollbar__bar.is-vertical{width:6px;top:2px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity .34s ease-out}.el-scrollbar-fade-leave-active{transition:opacity .12s ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius, 4px)}.el-popper{position:absolute;border-radius:var(--el-popper-border-radius);padding:5px 11px;z-index:2000;font-size:12px;line-height:20px;min-width:10px;word-wrap:break-word;visibility:visible}.el-popper.is-dark{color:var(--el-bg-color);background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary)}.el-popper.is-dark .el-popper__arrow:before{border:1px solid var(--el-text-color-primary);background:var(--el-text-color-primary);right:0}.el-popper.is-light{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light .el-popper__arrow:before{border:1px solid var(--el-border-color-light);background:var(--el-bg-color-overlay);right:0}.el-popper.is-pure{padding:0}.el-popper__arrow{position:absolute;width:10px;height:10px;z-index:-1}.el-popper__arrow:before{position:absolute;width:10px;height:10px;z-index:-1;content:" ";transform:rotate(45deg);background:var(--el-text-color-primary);box-sizing:border-box}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow:before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow:before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow:before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow:before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent!important;border-bottom-color:transparent!important}.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}.el-select-dropdown{z-index:calc(var(--el-index-top) + 1);border-radius:var(--el-border-radius-base);box-sizing:border-box}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown__loading,.el-select-dropdown__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:var(--el-select-font-size)}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{list-style:none;padding:6px 0;margin:0;box-sizing:border-box}.el-select-dropdown__list.el-vl__window{margin:6px 0;padding:0}.el-select-dropdown__header{padding:10px;border-bottom:1px solid var(--el-border-color-light)}.el-select-dropdown__footer{padding:10px;border-top:1px solid var(--el-border-color-light)}.el-select-dropdown__item{font-size:var(--el-font-size-base);padding:0 32px 0 20px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--el-text-color-regular);height:34px;line-height:34px;box-sizing:border-box;cursor:pointer}.el-select-dropdown__item.is-hovering{background-color:var(--el-fill-color-light)}.el-select-dropdown__item.is-selected{color:var(--el-color-primary);font-weight:700}.el-select-dropdown__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed;background-color:transparent;background-color:initial}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-selected:after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-select-dropdown.is-multiple .el-select-dropdown__item.is-disabled:after{background-color:var(--el-text-color-placeholder)}.el-select-group{margin:0;padding:0}.el-select-group__wrap{position:relative;list-style:none;margin:0;padding:0}.el-select-group__wrap:not(:last-of-type){padding-bottom:24px}.el-select-group__wrap:not(:last-of-type):after{content:"";position:absolute;display:block;left:20px;right:20px;bottom:12px;height:1px;background:var(--el-border-color-light)}.el-select-group__split-dash{position:absolute;left:20px;right:20px;height:1px;background:var(--el-border-color-light)}.el-select-group__title{padding-left:20px;font-size:12px;color:var(--el-color-info);line-height:30px}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px;--el-select-width:100%}.el-select{display:inline-block;position:relative;vertical-align:middle;width:var(--el-select-width)}.el-select__wrapper{display:flex;align-items:center;position:relative;box-sizing:border-box;cursor:pointer;text-align:left;font-size:14px;padding:4px 12px;gap:6px;min-height:32px;line-height:24px;border-radius:var(--el-border-radius-base);background-color:var(--el-fill-color-blank);transition:var(--el-transition-duration);box-shadow:0 0 0 1px var(--el-border-color) inset}.el-select__wrapper:hover{box-shadow:0 0 0 1px var(--el-text-color) inset}.el-select__wrapper.is-filterable{cursor:text}.el-select__wrapper.is-focused{box-shadow:0 0 0 1px var(--el-color-primary) inset}.el-select__wrapper.is-hovering:not(.is-focused){box-shadow:0 0 0 1px var(--el-border-color-hover) inset}.el-select__wrapper.is-disabled{cursor:not-allowed;background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select__wrapper.is-disabled:hover{box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select__wrapper.is-disabled.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-select__wrapper.is-disabled .el-select__caret,.el-select__wrapper.is-disabled .el-tag{cursor:not-allowed}.el-select__prefix,.el-select__suffix{display:flex;align-items:center;flex-shrink:0;gap:6px;color:var(--el-input-icon-color,var(--el-text-color-placeholder))}.el-select__caret{color:var(--el-select-input-color);font-size:var(--el-select-input-font-size);transition:var(--el-transition-duration);transform:rotate(0);cursor:pointer}.el-select__caret.is-reverse{transform:rotate(180deg)}.el-select__selection{position:relative;display:flex;flex-wrap:wrap;align-items:center;flex:1;min-width:0;gap:6px}.el-select__selection.is-near{margin-left:-8px}.el-select__selection .el-tag{cursor:pointer;border-color:transparent}.el-select__selection .el-tag .el-tag__content{min-width:0}.el-select__selected-item{display:flex;flex-wrap:wrap;-webkit-user-select:none;user-select:none}.el-select__tags-text{display:block;line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select__placeholder{position:absolute;display:block;top:50%;transform:translateY(-50%);width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--el-input-text-color,var(--el-text-color-regular))}.el-select__placeholder.is-transparent{-webkit-user-select:none;user-select:none;color:var(--el-text-color-placeholder)}.el-select__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select__popper.el-popper .el-popper__arrow:before{border:1px solid var(--el-border-color-light)}.el-select__popper.el-popper[data-popper-placement^=top] .el-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.el-select__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.el-select__popper.el-popper[data-popper-placement^=left] .el-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.el-select__popper.el-popper[data-popper-placement^=right] .el-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.el-select__input-wrapper{max-width:100%}.el-select__input-wrapper.is-hidden{position:absolute;opacity:0}.el-select__input{border:none;outline:0;padding:0;color:var(--el-select-multiple-input-color);font-size:inherit;font-family:inherit;-webkit-appearance:none;-moz-appearance:none;appearance:none;height:24px;max-width:100%;background-color:transparent}.el-select__input.is-disabled{cursor:not-allowed}.el-select__input-calculator{position:absolute;left:0;top:0;max-width:100%;visibility:hidden;white-space:pre;overflow:hidden}.el-select--large .el-select__wrapper{gap:6px;padding:8px 16px;min-height:40px;line-height:24px;font-size:14px}.el-select--large .el-select__selection{gap:6px}.el-select--large .el-select__selection.is-near{margin-left:-8px}.el-select--large .el-select__prefix,.el-select--large .el-select__suffix{gap:6px}.el-select--large .el-select__input{height:24px}.el-select--small .el-select__wrapper{gap:4px;padding:2px 8px;min-height:24px;line-height:20px;font-size:12px}.el-select--small .el-select__selection{gap:4px}.el-select--small .el-select__selection.is-near{margin-left:-6px}.el-select--small .el-select__prefix,.el-select--small .el-select__suffix{gap:4px}.el-select--small .el-select__input{height:20px}.shield-container[data-v-bb897aee]{display:flex;width:100%;flex-direction:column;gap:16px}.shield-container .words-container[data-v-bb897aee]{display:flex;flex-wrap:wrap;padding:12px;border-radius:12px;background-color:var(--trans-light-background);gap:4px}.shield-container .words-container .shield-elem[data-v-bb897aee]{display:flex;align-items:center;padding:4px 8px;border:none;border-radius:8px;font-size:14px;gap:4px}.shield-container .words-container .shield-elem .icon[data-v-bb897aee]{color:var(--light-fore)}.shield-container .words-container .remove-all[data-v-bb897aee]{background-color:#d62929;color:var(--default-background);font-variation-settings:"FILL" 0}.shield-container .empty-list-container[data-v-bb897aee]{color:var(--minimal-fore)}.shield-container .shield-controls[data-v-bb897aee]{display:flex;flex-direction:column;gap:8px}.shield-container .shield-controls .shield-input[data-v-bb897aee]{width:100%;height:auto;max-height:6em;box-sizing:border-box;padding:6px;font-size:16px;resize:none}.shield-container .shield-controls .submit-controls[data-v-bb897aee]{display:flex;align-items:center;justify-content:flex-end;gap:12px}.shield-container .shield-controls .submit-controls label[data-v-bb897aee]{margin-left:4px;-webkit-user-select:none;-moz-user-select:none;user-select:none}.shield-container .shield-controls .submit-controls .regex-check[data-v-bb897aee]{margin-right:8px;font-size:16px}.shield-container .shield-controls .submit-controls .submit-button[data-v-bb897aee]{padding:4px 12px;font-size:14px;font-weight:700} `);

(function () {
  'use strict';

  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateAdd = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateMethod = (obj, member, method) => {
    __accessCheck(obj, member, "access private method");
    return method;
  };
  (function() {
    var _parseMarkdown, parseMarkdown_fn, _onError, onError_fn;
    const materialSymbols = '@font-face{font-family:Material Symbols;font-style:normal;font-weight:200 400;src:url(https://fonts.gstatic.com/s/materialsymbolsoutlined/v110/kJEhBvYX7BgnkSrUwT8OhrdQw4oELdPIeeII9v6oFsI.woff2) format("woff2")}.material-symbols-outlined{display:inline-block;direction:ltr;font-family:Material Symbols;font-size:24px;-webkit-font-smoothing:antialiased;font-style:normal;font-weight:400;letter-spacing:normal;line-height:1;text-transform:none;white-space:nowrap;word-wrap:normal}';
    const palette = ':root{--code-zh: "Consolas", "JetBrains Mono", "Fira Code", "Menlo", sans-serif;--img-tieba-icon: url(https://gitee.com/WiresawBlade/Tieba-Remix/raw/master/assets/images/main/icon.png);color-scheme:light dark}.dark-theme{--default-background: rgb(32, 32, 32);--default-hover: rgb(42, 42, 42);--default-active: rgb(54, 54, 54);--page-background: rgb(26, 26, 26);--trans-page-background: rgba(26, 26, 26, .8);--trans-default-background: rgba(32, 32, 32, .8);--deep-background: rgb(26, 26, 26);--trans-deep-background: rgba(20, 20, 20, .6);--light-background: rgb(60, 60, 60);--trans-light-background: rgba(60, 60, 60, .6);--very-light-background: rgb(60, 60, 60);--elem-color: rgb(26, 26, 26);--default-fore: rgb(230, 230, 230);--light-fore: rgb(200, 200, 200);--minimal-fore: rgb(144, 144, 144);--highlight-fore: rgb(255, 255, 255);--border-color: rgba(96, 96, 96, .6);--light-border-color: rgba(96, 96, 96, .2);--tieba-theme-color: rgb(113, 97, 193);--trans-tieba-theme-color: rgba(113, 97, 193, .6);--tieba-theme-hover: rgb(149, 128, 254);--tieba-theme-active: rgb(172, 156, 253);--tieba-theme-background: rgba(113, 97, 193, .2);--tieba-theme-fore: rgb(150, 128, 255);--level-green-background: rgba(96, 153, 59, .1);--level-green-fore: rgb(133, 206, 84);--level-blue-background: rgba(0, 165, 227, .1);--level-blue-fore: rgb(0, 169, 255);--level-yellow-background: rgba(229, 193, 90, .1);--level-yellow-fore: rgb(242, 205, 96);--level-orange-background: rgba(204, 122, 0, .1);--level-orange-fore: rgb(255, 170, 0);--check-color: color.adjust(green, $lightness: 10%);--error-color: color.adjust(red, $lightness: 16%);--warning-color: color.adjust(orange, $blackness: 10%)}.light-theme{--default-background: rgb(255, 255, 255);--default-hover: rgb(240, 240, 240);--default-active: rgb(224, 224, 224);--page-background: rgb(245, 245, 245);--trans-page-background: rgba(245, 245, 245, .8);--trans-default-background: rgba(255, 255, 255, .8);--deep-background: rgb(228, 228, 228);--trans-deep-background: rgba(200, 200, 200, .6);--light-background: rgb(235, 235, 235);--trans-light-background: rgba(228, 228, 228, .6);--very-light-background: rgb(245, 245, 245);--elem-color: rgb(240, 240, 240);--default-fore: rgb(16, 16, 16);--light-fore: rgb(64, 64, 64);--minimal-fore: rgb(92, 92, 92);--highlight-fore: rgb(0, 0, 0);--border-color: rgba(210, 210, 210, .6);--light-border-color: rgba(210, 210, 210, .2);--tieba-theme-color: rgb(97, 78, 194);--trans-tieba-theme-color: rgba(97, 78, 194, .6);--tieba-theme-hover: rgb(119, 105, 194);--tieba-theme-active: rgb(150, 134, 232);--tieba-theme-background: rgba(97, 78, 194, .2);--tieba-theme-fore: rgb(58, 46, 116);--level-green-background: rgba(84, 130, 53, .1);--level-green-fore: rgb(51, 78, 32);--level-blue-background: rgba(0, 153, 213, .1);--level-blue-fore: rgb(0, 81, 111);--level-yellow-background: rgba(164, 139, 63, .1);--level-yellow-fore: rgb(124, 105, 46);--level-orange-background: rgba(255, 153, 0, .1);--level-orange-fore: rgb(178, 104, 0);--check-color: color.adjust(green, $lightness: 10%);--error-color: color.adjust(red, $lightness: 16%);--warning-color: color.adjust(orange, $blackness: 10%)}';
    const remixedMain = "html{padding:0;margin:0;text-align:justify}body{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar]{overflow:hidden}div,p{margin:0}select{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option{cursor:pointer}option:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ{position:fixed!important;top:50%!important;left:50%!important}.dialogJ{transform:translate(-50%,-50%)}";
    const utilClassesCSS = 'html{padding:0;margin:0;text-align:justify}body{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar]{overflow:hidden}div,p{margin:0}select{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option{cursor:pointer}option:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ{position:fixed!important;top:50%!important;left:50%!important}.dialogJ{transform:translate(-50%,-50%)}.icon,.outline-icon{font-family:Material Symbols,monospace;font-variation-settings:"FILL" 0,"wght" 400,"GRAD" 0,"opsz" 40;-webkit-user-select:none;-moz-user-select:none;user-select:none}.filled-icon{font-family:Material Symbols,monospace;font-variation-settings:"FILL" 1,"wght" 400,"GRAD" 0,"opsz" 40;-webkit-user-select:none;-moz-user-select:none;user-select:none}.markdown{font-family:sans-serif}.markdown code{padding:2px 6px;border-radius:8px;background-color:var(--light-border-color);font-family:monospace;word-wrap:break-word}.markdown a{color:var(--tieba-theme-fore)}.markdown a:hover{-webkit-text-decoration:underline;text-decoration:underline}.markdown h2{margin:20px 0 8px;font-size:24px}.markdown h3{margin:16px 0 6px}.markdown ul{margin:6px 0}.markdown li{margin:6px 0 6px 22px;list-style:disc}.markdown li::marker{color:var(--minimal-fore)}.markdown blockquote{margin:20px 16px;color:var(--minimal-fore)}.settings-toggle-button{border:none!important;background-color:transparent!important;background-color:initial!important}.settings-toggle-button{border-radius:36px}.settings-toggle-button.toggle-off{color:var(--minimal-fore);font-variation-settings:"FILL" 0}.settings-toggle-button.toggle-off:after{content:"toggle_off"}.settings-toggle-button.toggle-on:after{content:"toggle_on"}.settings-toggle-button.toggle-on{color:var(--tieba-theme-color);font-variation-settings:"FILL" 1}.settings-toggle-button.toggle-off:hover{color:var(--default-hover)}.settings-toggle-button.toggle-off:active{color:var(--default-active)}.settings-toggle-button.toggle-on:hover{color:var(tieba-theme-hover)}.settings-toggle-button.toggle-on:active{color:var(--tieba-theme-active)}.level-green{background-color:var(--level-green-background)!important;color:var(--level-green-fore)!important}.level-blue{background-color:var(--level-blue-background)!important;color:var(--level-blue-fore)!important}.level-yellow{background-color:var(--level-yellow-background)!important;color:var(--level-yellow-fore)!important}.level-orange{background-color:var(--level-orange-background)!important;color:var(--level-orange-fore)!important}.remove-default{font-size:16px;line-height:normal;line-height:initial}.remove-default .content{min-height:0;min-height:initial;background:transparent none repeat 0 0 / auto auto padding-box border-box scroll;background:initial}.remove-default code{display:inline;display:initial;width:auto;width:initial;height:auto;height:initial}.remove-default .content,.remove-default .foot{width:auto;width:initial}.remove-default button{color:inherit}body.custom-background .blur-if-custom-background{-webkit-backdrop-filter:blur(24px);backdrop-filter:blur(24px)}body.dark-theme body.custom-background .blur-if-custom-background{-webkit-backdrop-filter:blur(24px) brightness(.8);backdrop-filter:blur(24px) brightness(.8)}';
    const darkVars = "html.dark{color-scheme:dark;--el-color-primary:#409eff;--el-color-primary-light-3:#3375b9;--el-color-primary-light-5:#2a598a;--el-color-primary-light-7:#213d5b;--el-color-primary-light-8:#1d3043;--el-color-primary-light-9:#18222c;--el-color-primary-dark-2:#66b1ff;--el-color-success:#67c23a;--el-color-success-light-3:#4e8e2f;--el-color-success-light-5:#3e6b27;--el-color-success-light-7:#2d481f;--el-color-success-light-8:#25371c;--el-color-success-light-9:#1c2518;--el-color-success-dark-2:#85ce61;--el-color-warning:#e6a23c;--el-color-warning-light-3:#a77730;--el-color-warning-light-5:#7d5b28;--el-color-warning-light-7:#533f20;--el-color-warning-light-8:#3e301c;--el-color-warning-light-9:#292218;--el-color-warning-dark-2:#ebb563;--el-color-danger:#f56c6c;--el-color-danger-light-3:#b25252;--el-color-danger-light-5:#854040;--el-color-danger-light-7:#582e2e;--el-color-danger-light-8:#412626;--el-color-danger-light-9:#2b1d1d;--el-color-danger-dark-2:#f78989;--el-color-error:#f56c6c;--el-color-error-light-3:#b25252;--el-color-error-light-5:#854040;--el-color-error-light-7:#582e2e;--el-color-error-light-8:#412626;--el-color-error-light-9:#2b1d1d;--el-color-error-dark-2:#f78989;--el-color-info:#909399;--el-color-info-light-3:#6b6d71;--el-color-info-light-5:#525457;--el-color-info-light-7:#393a3c;--el-color-info-light-8:#2d2d2f;--el-color-info-light-9:#202121;--el-color-info-dark-2:#a6a9ad;--el-box-shadow:0px 12px 32px 4px rgba(0, 0, 0, .36),0px 8px 20px rgba(0, 0, 0, .72);--el-box-shadow-light:0px 0px 12px rgba(0, 0, 0, .72);--el-box-shadow-lighter:0px 0px 6px rgba(0, 0, 0, .72);--el-box-shadow-dark:0px 16px 48px 16px rgba(0, 0, 0, .72),0px 12px 32px #000000,0px 8px 16px -8px #000000;--el-bg-color-page:#0a0a0a;--el-bg-color:#141414;--el-bg-color-overlay:#1d1e1f;--el-text-color-primary:#E5EAF3;--el-text-color-regular:#CFD3DC;--el-text-color-secondary:#A3A6AD;--el-text-color-placeholder:#8D9095;--el-text-color-disabled:#6C6E72;--el-border-color-darker:#636466;--el-border-color-dark:#58585B;--el-border-color:#4C4D4F;--el-border-color-light:#414243;--el-border-color-lighter:#363637;--el-border-color-extra-light:#2B2B2C;--el-fill-color-darker:#424243;--el-fill-color-dark:#39393A;--el-fill-color:#303030;--el-fill-color-light:#262727;--el-fill-color-lighter:#1D1D1D;--el-fill-color-extra-light:#191919;--el-fill-color-blank:transparent;--el-mask-color:rgba(0, 0, 0, .8);--el-mask-color-extra-light:rgba(0, 0, 0, .3)}html.dark .el-button{--el-button-disabled-text-color:rgba(255, 255, 255, .5)}html.dark .el-card{--el-card-bg-color:var(--el-bg-color-overlay)}html.dark .el-empty{--el-empty-fill-color-0:var(--el-color-black);--el-empty-fill-color-1:#4b4b52;--el-empty-fill-color-2:#36383d;--el-empty-fill-color-3:#1e1e20;--el-empty-fill-color-4:#262629;--el-empty-fill-color-5:#202124;--el-empty-fill-color-6:#212224;--el-empty-fill-color-7:#1b1c1f;--el-empty-fill-color-8:#1c1d1f;--el-empty-fill-color-9:#18181a}";
    const ThemePlus = "body{--el-color-primary: var(--tieba-theme-color) !important}";
    /**
    * @vue/shared v3.4.15
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    function makeMap(str, expectsLowerCase) {
      const set2 = new Set(str.split(","));
      return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
    }
    const EMPTY_OBJ = Object.freeze({});
    const EMPTY_ARR = Object.freeze([]);
    const NOOP = () => {
    };
    const NO = () => false;
    const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend = Object.assign;
    const remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    const hasOwnProperty$f = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$f.call(val, key);
    const isArray$1 = Array.isArray;
    const isMap = (val) => toTypeString(val) === "[object Map]";
    const isSet = (val) => toTypeString(val) === "[object Set]";
    const isDate = (val) => toTypeString(val) === "[object Date]";
    const isFunction$1 = (val) => typeof val === "function";
    const isString$2 = (val) => typeof val === "string";
    const isSymbol$1 = (val) => typeof val === "symbol";
    const isObject$1 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
    };
    const objectToString$1 = Object.prototype.toString;
    const toTypeString = (value) => objectToString$1.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const isBuiltInDirective = /* @__PURE__ */ makeMap(
      "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
    );
    const cacheStringFunction = (fn2) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn2(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction((str) => {
      const s = str ? `on${capitalize(str)}` : ``;
      return s;
    });
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
      }
    };
    const def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber$1 = (val) => {
      const n = isString$2(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray$1(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString$2(value) || isObject$1(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString$2(value)) {
        res = value;
      } else if (isArray$1(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$1(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
    const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
    const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
    const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
    const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
    const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length)
        return false;
      let equal = true;
      for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
      }
      return equal;
    }
    function looseEqual(a, b) {
      if (a === b)
        return true;
      let aValidType = isDate(a);
      let bValidType = isDate(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isSymbol$1(a);
      bValidType = isSymbol$1(b);
      if (aValidType || bValidType) {
        return a === b;
      }
      aValidType = isArray$1(a);
      bValidType = isArray$1(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject$1(a);
      bValidType = isObject$1(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    const toDisplayString = (val) => {
      return isString$2(val) ? val : val == null ? "" : isArray$1(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2], i) => {
              entries[stringifySymbol(key, i) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
        };
      } else if (isSymbol$1(val)) {
        return stringifySymbol(val);
      } else if (isObject$1(val) && !isArray$1(val) && !isPlainObject$1(val)) {
        return String(val);
      }
      return val;
    };
    const stringifySymbol = (v, i = "") => {
      var _a2;
      return isSymbol$1(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i})` : v;
    };
    /**
    * @vue/reactivity v3.4.15
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    function warn$2(msg, ...args) {
      console.warn(`[Vue warn] ${msg}`, ...args);
    }
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      run(fn2) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn2();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        } else {
          warn$2(`cannot run an inactive effect scope.`);
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].stop();
          }
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
          this._active = false;
        }
      }
    }
    function recordEffectScope(effect2, scope = activeEffectScope) {
      if (scope && scope.active) {
        scope.effects.push(effect2);
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    function onScopeDispose(fn2) {
      if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn2);
      } else {
        warn$2(
          `onScopeDispose() is called when there is no active effect scope to be associated with.`
        );
      }
    }
    let activeEffect;
    class ReactiveEffect {
      constructor(fn2, trigger2, scheduler, scope) {
        this.fn = fn2;
        this.trigger = trigger2;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this._dirtyLevel = 2;
        this._trackId = 0;
        this._runnings = 0;
        this._shouldSchedule = false;
        this._depsLength = 0;
        recordEffectScope(this, scope);
      }
      get dirty() {
        if (this._dirtyLevel === 1) {
          pauseTracking();
          for (let i = 0; i < this._depsLength; i++) {
            const dep = this.deps[i];
            if (dep.computed) {
              triggerComputed(dep.computed);
              if (this._dirtyLevel >= 2) {
                break;
              }
            }
          }
          if (this._dirtyLevel < 2) {
            this._dirtyLevel = 0;
          }
          resetTracking();
        }
        return this._dirtyLevel >= 2;
      }
      set dirty(v) {
        this._dirtyLevel = v ? 2 : 0;
      }
      run() {
        this._dirtyLevel = 0;
        if (!this.active) {
          return this.fn();
        }
        let lastShouldTrack = shouldTrack;
        let lastEffect = activeEffect;
        try {
          shouldTrack = true;
          activeEffect = this;
          this._runnings++;
          preCleanupEffect(this);
          return this.fn();
        } finally {
          postCleanupEffect(this);
          this._runnings--;
          activeEffect = lastEffect;
          shouldTrack = lastShouldTrack;
        }
      }
      stop() {
        var _a2;
        if (this.active) {
          preCleanupEffect(this);
          postCleanupEffect(this);
          (_a2 = this.onStop) == null ? void 0 : _a2.call(this);
          this.active = false;
        }
      }
    }
    function triggerComputed(computed2) {
      return computed2.value;
    }
    function preCleanupEffect(effect2) {
      effect2._trackId++;
      effect2._depsLength = 0;
    }
    function postCleanupEffect(effect2) {
      if (effect2.deps && effect2.deps.length > effect2._depsLength) {
        for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
          cleanupDepEffect(effect2.deps[i], effect2);
        }
        effect2.deps.length = effect2._depsLength;
      }
    }
    function cleanupDepEffect(dep, effect2) {
      const trackId = dep.get(effect2);
      if (trackId !== void 0 && effect2._trackId !== trackId) {
        dep.delete(effect2);
        if (dep.size === 0) {
          dep.cleanup();
        }
      }
    }
    let shouldTrack = true;
    let pauseScheduleStack = 0;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function pauseScheduling() {
      pauseScheduleStack++;
    }
    function resetScheduling() {
      pauseScheduleStack--;
      while (!pauseScheduleStack && queueEffectSchedulers.length) {
        queueEffectSchedulers.shift()();
      }
    }
    function trackEffect(effect2, dep, debuggerEventExtraInfo) {
      var _a2;
      if (dep.get(effect2) !== effect2._trackId) {
        dep.set(effect2, effect2._trackId);
        const oldDep = effect2.deps[effect2._depsLength];
        if (oldDep !== dep) {
          if (oldDep) {
            cleanupDepEffect(oldDep, effect2);
          }
          effect2.deps[effect2._depsLength++] = dep;
        } else {
          effect2._depsLength++;
        }
        {
          (_a2 = effect2.onTrack) == null ? void 0 : _a2.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));
        }
      }
    }
    const queueEffectSchedulers = [];
    function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
      var _a2;
      pauseScheduling();
      for (const effect2 of dep.keys()) {
        if (effect2._dirtyLevel < dirtyLevel && dep.get(effect2) === effect2._trackId) {
          const lastDirtyLevel = effect2._dirtyLevel;
          effect2._dirtyLevel = dirtyLevel;
          if (lastDirtyLevel === 0) {
            effect2._shouldSchedule = true;
            {
              (_a2 = effect2.onTrigger) == null ? void 0 : _a2.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));
            }
            effect2.trigger();
          }
        }
      }
      scheduleEffects(dep);
      resetScheduling();
    }
    function scheduleEffects(dep) {
      for (const effect2 of dep.keys()) {
        if (effect2.scheduler && effect2._shouldSchedule && (!effect2._runnings || effect2.allowRecurse) && dep.get(effect2) === effect2._trackId) {
          effect2._shouldSchedule = false;
          queueEffectSchedulers.push(effect2.scheduler);
        }
      }
    }
    const createDep = (cleanup, computed2) => {
      const dep = /* @__PURE__ */ new Map();
      dep.cleanup = cleanup;
      dep.computed = computed2;
      return dep;
    };
    const targetMap = /* @__PURE__ */ new WeakMap();
    const ITERATE_KEY = Symbol("iterate");
    const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
    function track(target, type, key) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
        }
        trackEffect(
          activeEffect,
          dep,
          {
            target,
            type,
            key
          }
        );
      }
    }
    function trigger(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && isArray$1(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || !isSymbol$1(key2) && key2 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type) {
          case "add":
            if (!isArray$1(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!isArray$1(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      pauseScheduling();
      for (const dep of deps) {
        if (dep) {
          triggerEffects(
            dep,
            2,
            {
              target,
              type,
              key,
              newValue,
              oldValue,
              oldTarget
            }
          );
        }
      }
      resetScheduling();
    }
    function getDepFromReactive(object, key) {
      var _a2;
      return (_a2 = targetMap.get(object)) == null ? void 0 : _a2.get(key);
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
    );
    const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i = 0, l = this.length; i < l; i++) {
            track(arr, "get", i + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          pauseScheduling();
          const res = toRaw(this)[key].apply(this, args);
          resetScheduling();
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function hasOwnProperty$e(key) {
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _shallow = false) {
        this._isReadonly = _isReadonly;
        this._shallow = _shallow;
      }
      get(target, key, receiver) {
        const isReadonly2 = this._isReadonly, shallow = this._shallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return shallow;
        } else if (key === "__v_raw") {
          if (receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
          // this means the reciever is a user proxy of the reactive proxy
          Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
            return target;
          }
          return;
        }
        const targetIsArray = isArray$1(target);
        if (!isReadonly2) {
          if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty$e;
          }
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (shallow) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$1(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(shallow = false) {
        super(false, shallow);
      }
      set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._shallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value, oldValue);
          }
        }
        return result;
      }
      deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        const oldValue = target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      }
      has(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          isArray$1(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(shallow = false) {
        super(true, shallow);
      }
      set(target, key) {
        {
          warn$2(
            `Set operation on key "${String(key)}" failed: target is readonly.`,
            target
          );
        }
        return true;
      }
      deleteProperty(target, key) {
        {
          warn$2(
            `Delete operation on key "${String(key)}" failed: target is readonly.`,
            target
          );
        }
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
      true
    );
    const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function get$1(target, key, isReadonly2 = false, isShallow22 = false) {
      target = target["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow22 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    }
    function has(key, isReadonly2 = false) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    }
    function size(target, isReadonly2 = false) {
      target = target["__v_raw"];
      !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto = getProto(target);
      const hadKey = proto.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
      }
      return this;
    }
    function set(key, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      } else {
        checkIdentityKeys(target, has2, key);
      }
      const oldValue = get2.call(target, key);
      target.set(key, value);
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
      return this;
    }
    function deleteEntry(key) {
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      } else {
        checkIdentityKeys(target, has2, key);
      }
      const oldValue = get2 ? get2.call(target, key) : void 0;
      const result = target.delete(key);
      if (hadKey) {
        trigger(target, "delete", key, void 0, oldValue);
      }
      return result;
    }
    function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const oldTarget = isMap(target) ? new Map(target) : new Set(target);
      const result = target.clear();
      if (hadItems) {
        trigger(target, "clear", void 0, void 0, oldTarget);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow22) {
      return function forEach2(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow22 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow22) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow22 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        {
          const key = args[0] ? `on key "${args[0]}" ` : ``;
          console.warn(
            `${capitalize(type)} operation ${key}failed: target is readonly.`,
            toRaw(this)
          );
        }
        return type === "delete" ? false : type === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get$1(this, key);
        },
        get size() {
          return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get$1(this, key, false, true);
        },
        get size() {
          return size(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get$1(this, key, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get$1(this, key, true, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
      iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(
          method,
          false,
          false
        );
        readonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          false
        );
        shallowInstrumentations2[method] = createIterableMethod(
          method,
          false,
          true
        );
        shallowReadonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          true
        );
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    const [
      mutableInstrumentations,
      readonlyInstrumentations,
      shallowInstrumentations,
      shallowReadonlyInstrumentations
    ] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const shallowReadonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, true)
    };
    function checkIdentityKeys(target, has2, key) {
      const rawKey = toRaw(key);
      if (rawKey !== key && has2.call(target, rawKey)) {
        const type = toRawType(target);
        console.warn(
          `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
        );
      }
    }
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function shallowReadonly(target) {
      return createReactiveObject(
        target,
        true,
        shallowReadonlyHandlers,
        shallowReadonlyCollectionHandlers,
        shallowReadonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$1(target)) {
        {
          console.warn(`value cannot be made reactive: ${String(target)}`);
        }
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return isReactive(value) || isReadonly(value);
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      def(value, "__v_skip", true);
      return value;
    }
    const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
    class ComputedRefImpl {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this.effect = new ReactiveEffect(
          () => getter(this._value),
          () => triggerRefValue(this, 1),
          () => this.dep && scheduleEffects(this.dep)
        );
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        if (!self2._cacheable || self2.effect.dirty) {
          if (hasChanged(self2._value, self2._value = self2.effect.run())) {
            triggerRefValue(self2, 2);
          }
        }
        trackRefValue(self2);
        if (self2.effect._dirtyLevel >= 1) {
          triggerRefValue(self2, 1);
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
      // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
      get _dirty() {
        return this.effect.dirty;
      }
      set _dirty(v) {
        this.effect.dirty = v;
      }
      // #endregion
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction$1(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = () => {
          console.warn("Write operation failed: computed value is readonly");
        };
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      if (debugOptions && !isSSR) {
        cRef.effect.onTrack = debugOptions.onTrack;
        cRef.effect.onTrigger = debugOptions.onTrigger;
      }
      return cRef;
    }
    function trackRefValue(ref2) {
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffect(
          activeEffect,
          ref2.dep || (ref2.dep = createDep(
            () => ref2.dep = void 0,
            ref2 instanceof ComputedRefImpl ? ref2 : void 0
          )),
          {
            target: ref2,
            type: "get",
            key: "value"
          }
        );
      }
    }
    function triggerRefValue(ref2, dirtyLevel = 2, newVal) {
      ref2 = toRaw(ref2);
      const dep = ref2.dep;
      if (dep) {
        triggerEffects(
          dep,
          dirtyLevel,
          {
            target: ref2,
            type: "set",
            key: "value",
            newValue: newVal
          }
        );
      }
    }
    function isRef(r) {
      return !!(r && r.__v_isRef === true);
    }
    function ref(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
          this._rawValue = newVal;
          this._value = useDirectValue ? newVal : toReactive(newVal);
          triggerRefValue(this, 2, newVal);
        }
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    function toRefs(object) {
      if (!isProxy(object)) {
        console.warn(`toRefs() expects a reactive object but received a plain one.`);
      }
      const ret = isArray$1(object) ? new Array(object.length) : {};
      for (const key in object) {
        ret[key] = propertyToRef(object, key);
      }
      return ret;
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    class GetterRefImpl {
      constructor(_getter) {
        this._getter = _getter;
        this.__v_isRef = true;
        this.__v_isReadonly = true;
      }
      get value() {
        return this._getter();
      }
    }
    function toRef(source, key, defaultValue) {
      if (isRef(source)) {
        return source;
      } else if (isFunction$1(source)) {
        return new GetterRefImpl(source);
      } else if (isObject$1(source) && arguments.length > 1) {
        return propertyToRef(source, key, defaultValue);
      } else {
        return ref(source);
      }
    }
    function propertyToRef(source, key, defaultValue) {
      const val = source[key];
      return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
    }
    /**
    * @vue/runtime-core v3.4.15
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const stack = [];
    function pushWarningContext(vnode) {
      stack.push(vnode);
    }
    function popWarningContext() {
      stack.pop();
    }
    function warn$1(msg, ...args) {
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            msg + args.join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && // avoid spamming console during tests
        true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
    }
    function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i) => {
        logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys2 = Object.keys(props);
      keys2.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys2.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString$2(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction$1(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function assertNumber(val, type) {
      if (val === void 0) {
        return;
      } else if (typeof val !== "number") {
        warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);
      } else if (isNaN(val)) {
        warn$1(`${type} is NaN - the duration expression might be incorrect.`);
      }
    }
    const ErrorTypeStrings$1 = {
      ["sp"]: "serverPrefetch hook",
      ["bc"]: "beforeCreate hook",
      ["c"]: "created hook",
      ["bm"]: "beforeMount hook",
      ["m"]: "mounted hook",
      ["bu"]: "beforeUpdate hook",
      ["u"]: "updated",
      ["bum"]: "beforeUnmount hook",
      ["um"]: "unmounted hook",
      ["a"]: "activated hook",
      ["da"]: "deactivated hook",
      ["ec"]: "errorCaptured hook",
      ["rtc"]: "renderTracked hook",
      ["rtg"]: "renderTriggered hook",
      [0]: "setup function",
      [1]: "render function",
      [2]: "watcher getter",
      [3]: "watcher callback",
      [4]: "watcher cleanup function",
      [5]: "native event handler",
      [6]: "component event handler",
      [7]: "vnode hook",
      [8]: "directive hook",
      [9]: "transition hook",
      [10]: "app errorHandler",
      [11]: "app warnHandler",
      [12]: "ref function",
      [13]: "async component loader",
      [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
    };
    function callWithErrorHandling(fn2, instance, type, args) {
      let res;
      try {
        res = args ? fn2(...args) : fn2();
      } catch (err) {
        handleError(err, instance, type);
      }
      return res;
    }
    function callWithAsyncErrorHandling(fn2, instance, type, args) {
      if (isFunction$1(fn2)) {
        const res = callWithErrorHandling(fn2, instance, type, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type);
          });
        }
        return res;
      }
      const values2 = [];
      for (let i = 0; i < fn2.length; i++) {
        values2.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
      }
      return values2;
    }
    function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = ErrorTypeStrings$1[type];
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i = 0; i < errorCapturedHooks.length; i++) {
              if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          callWithErrorHandling(
            appErrorHandler,
            null,
            10,
            [err, exposedInstance, errorInfo]
          );
          return;
        }
      }
      logError(err, type, contextVNode, throwInDev);
    }
    function logError(err, type, contextVNode, throwInDev = true) {
      {
        const info = ErrorTypeStrings$1[type];
        if (contextVNode) {
          pushWarningContext(contextVNode);
        }
        warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) {
          popWarningContext();
        }
        if (throwInDev) {
          throw err;
        } else {
          console.error(err);
        }
      }
    }
    let isFlushing = false;
    let isFlushPending = false;
    const queue = [];
    let flushIndex = 0;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    const RECURSION_LIMIT = 100;
    function nextTick(fn2) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
    }
    function findInsertionIndex(id) {
      let start = flushIndex + 1;
      let end = queue.length;
      while (start < end) {
        const middle = start + end >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id || middleJobId === id && middleJob.pre) {
          start = middle + 1;
        } else {
          end = middle;
        }
      }
      return start;
    }
    function queueJob(job) {
      if (!queue.length || !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function invalidateJob(job) {
      const i = queue.indexOf(job);
      if (i > flushIndex) {
        queue.splice(i, 1);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$1(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(
          cb,
          cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
        )) {
          pendingPostFlushCbs.push(cb);
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
      {
        seen = seen || /* @__PURE__ */ new Map();
      }
      for (; i < queue.length; i++) {
        const cb = queue[i];
        if (cb && cb.pre) {
          if (instance && cb.id !== instance.uid) {
            continue;
          }
          if (checkRecursiveUpdates(seen, cb)) {
            continue;
          }
          queue.splice(i, 1);
          i--;
          cb();
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a, b) => getId(a) - getId(b)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        {
          seen = seen || /* @__PURE__ */ new Map();
        }
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
            continue;
          }
          activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? Infinity : job.id;
    const comparator = (a, b) => {
      const diff = getId(a) - getId(b);
      if (diff === 0) {
        if (a.pre && !b.pre)
          return -1;
        if (b.pre && !a.pre)
          return 1;
      }
      return diff;
    };
    function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      {
        seen = seen || /* @__PURE__ */ new Map();
      }
      queue.sort(comparator);
      const check = (job) => checkRecursiveUpdates(seen, job);
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (check(job)) {
              continue;
            }
            callWithErrorHandling(job, null, 14);
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs(seen);
        }
      }
    }
    function checkRecursiveUpdates(seen, fn2) {
      if (!seen.has(fn2)) {
        seen.set(fn2, 1);
      } else {
        const count = seen.get(fn2);
        if (count > RECURSION_LIMIT) {
          const instance = fn2.ownerInstance;
          const componentName2 = instance && getComponentName(instance.type);
          handleError(
            `Maximum recursive updates exceeded${componentName2 ? ` in component <${componentName2}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
            null,
            10
          );
          return true;
        } else {
          seen.set(fn2, count + 1);
        }
      }
    }
    let isHmrUpdating = false;
    const hmrDirtyComponents = /* @__PURE__ */ new Set();
    {
      getGlobalThis().__VUE_HMR_RUNTIME__ = {
        createRecord: tryWrap(createRecord),
        rerender: tryWrap(rerender),
        reload: tryWrap(reload)
      };
    }
    const map$1 = /* @__PURE__ */ new Map();
    function registerHMR(instance) {
      const id = instance.type.__hmrId;
      let record = map$1.get(id);
      if (!record) {
        createRecord(id, instance.type);
        record = map$1.get(id);
      }
      record.instances.add(instance);
    }
    function unregisterHMR(instance) {
      map$1.get(instance.type.__hmrId).instances.delete(instance);
    }
    function createRecord(id, initialDef) {
      if (map$1.has(id)) {
        return false;
      }
      map$1.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: /* @__PURE__ */ new Set()
      });
      return true;
    }
    function normalizeClassComponent(component) {
      return isClassComponent(component) ? component.__vccOpts : component;
    }
    function rerender(id, newRender) {
      const record = map$1.get(id);
      if (!record) {
        return;
      }
      record.initialDef.render = newRender;
      [...record.instances].forEach((instance) => {
        if (newRender) {
          instance.render = newRender;
          normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        isHmrUpdating = true;
        instance.effect.dirty = true;
        instance.update();
        isHmrUpdating = false;
      });
    }
    function reload(id, newComp) {
      const record = map$1.get(id);
      if (!record)
        return;
      newComp = normalizeClassComponent(newComp);
      updateComponentDef(record.initialDef, newComp);
      const instances = [...record.instances];
      for (const instance of instances) {
        const oldComp = normalizeClassComponent(instance.type);
        if (!hmrDirtyComponents.has(oldComp)) {
          if (oldComp !== record.initialDef) {
            updateComponentDef(oldComp, newComp);
          }
          hmrDirtyComponents.add(oldComp);
        }
        instance.appContext.propsCache.delete(instance.type);
        instance.appContext.emitsCache.delete(instance.type);
        instance.appContext.optionsCache.delete(instance.type);
        if (instance.ceReload) {
          hmrDirtyComponents.add(oldComp);
          instance.ceReload(newComp.styles);
          hmrDirtyComponents.delete(oldComp);
        } else if (instance.parent) {
          instance.parent.effect.dirty = true;
          queueJob(instance.parent.update);
        } else if (instance.appContext.reload) {
          instance.appContext.reload();
        } else if (typeof window !== "undefined") {
          window.location.reload();
        } else {
          console.warn(
            "[HMR] Root or manually mounted instance modified. Full reload required."
          );
        }
      }
      queuePostFlushCb(() => {
        for (const instance of instances) {
          hmrDirtyComponents.delete(
            normalizeClassComponent(instance.type)
          );
        }
      });
    }
    function updateComponentDef(oldComp, newComp) {
      extend(oldComp, newComp);
      for (const key in oldComp) {
        if (key !== "__file" && !(key in newComp)) {
          delete oldComp[key];
        }
      }
    }
    function tryWrap(fn2) {
      return (id, arg) => {
        try {
          return fn2(id, arg);
        } catch (e) {
          console.error(e);
          console.warn(
            `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
          );
        }
      };
    }
    let devtools$1;
    let buffer = [];
    let devtoolsNotInstalled = false;
    function emit$1(event, ...args) {
      if (devtools$1) {
        devtools$1.emit(event, ...args);
      } else if (!devtoolsNotInstalled) {
        buffer.push({ event, args });
      }
    }
    function setDevtoolsHook$1(hook, target) {
      var _a2, _b;
      devtools$1 = hook;
      if (devtools$1) {
        devtools$1.enabled = true;
        buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
        buffer = [];
      } else if (
        // handle late devtools injection - only do this if we are in an actual
        // browser environment to avoid the timer handle stalling test runner exit
        // (#4815)
        typeof window !== "undefined" && // some envs mock window but not fully
        window.HTMLElement && // also exclude jsdom
        !((_b = (_a2 = window.navigator) == null ? void 0 : _a2.userAgent) == null ? void 0 : _b.includes("jsdom"))
      ) {
        const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
        replay.push((newHook) => {
          setDevtoolsHook$1(newHook, target);
        });
        setTimeout(() => {
          if (!devtools$1) {
            target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
            devtoolsNotInstalled = true;
            buffer = [];
          }
        }, 3e3);
      } else {
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }
    function devtoolsInitApp(app, version2) {
      emit$1("app:init", app, version2, {
        Fragment,
        Text,
        Comment,
        Static
      });
    }
    function devtoolsUnmountApp(app) {
      emit$1("app:unmount", app);
    }
    const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
      "component:added"
      /* COMPONENT_ADDED */
    );
    const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
      "component:updated"
      /* COMPONENT_UPDATED */
    );
    const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
      "component:removed"
      /* COMPONENT_REMOVED */
    );
    const devtoolsComponentRemoved = (component) => {
      if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
      !devtools$1.cleanupBuffer(component)) {
        _devtoolsComponentRemoved(component);
      }
    };
    function createDevtoolsComponentHook(hook) {
      return (component) => {
        emit$1(
          hook,
          component.appContext.app,
          component.uid,
          component.parent ? component.parent.uid : void 0,
          component
        );
      };
    }
    const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
      "perf:start"
      /* PERFORMANCE_START */
    );
    const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
      "perf:end"
      /* PERFORMANCE_END */
    );
    function createDevtoolsPerformanceHook(hook) {
      return (component, type, time) => {
        emit$1(hook, component.appContext.app, component.uid, component, type, time);
      };
    }
    function devtoolsComponentEmit(component, event, params) {
      emit$1(
        "component:emit",
        component.appContext.app,
        component,
        event,
        params
      );
    }
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || EMPTY_OBJ;
      {
        const {
          emitsOptions,
          propsOptions: [propsOptions]
        } = instance;
        if (emitsOptions) {
          if (!(event in emitsOptions) && true) {
            if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
              warn$1(
                `Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`
              );
            }
          } else {
            const validator = emitsOptions[event];
            if (isFunction$1(validator)) {
              const isValid = validator(...rawArgs);
              if (!isValid) {
                warn$1(
                  `Invalid event arguments: event validation failed for event "${event}".`
                );
              }
            }
          }
        }
      }
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modelArg = isModelListener2 && event.slice(7);
      if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
        if (trim) {
          args = rawArgs.map((a) => isString$2(a) ? a.trim() : a);
        }
        if (number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      {
        devtoolsComponentEmit(instance, event, args);
      }
      {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
          warn$1(
            `Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(
            instance,
            instance.type
          )} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(
            event
          )}" instead of "${event}".`
          );
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.emitsCache;
      const cached = cache.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$1(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache.set(comp, null);
        }
        return null;
      }
      if (isArray$1(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend(normalized, raw);
      }
      if (isObject$1(comp)) {
        cache.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function pushScopeId(id) {
      currentScopeId = id;
    }
    function popScopeId() {
      currentScopeId = null;
    }
    function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx)
        return fn2;
      if (fn2._n) {
        return fn2;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
          res = fn2(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        {
          devtoolsComponentUpdated(ctx);
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    let accessedAttrs = false;
    function markAttrsAccessed() {
      accessedAttrs = true;
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        props,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render: render2,
        renderCache,
        data,
        setupState,
        ctx,
        inheritAttrs
      } = instance;
      let result;
      let fallthroughAttrs;
      const prev = setCurrentRenderingInstance(instance);
      {
        accessedAttrs = false;
      }
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = setupState.__isScriptSetup ? new Proxy(proxyToUse, {
            get(target, key, receiver) {
              warn$1(
                `Property '${String(
                key
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render2.call(
              thisProxy,
              proxyToUse,
              renderCache,
              props,
              setupState,
              data,
              ctx
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render22 = Component;
          if (attrs === props) {
            markAttrsAccessed();
          }
          result = normalizeVNode(
            render22.length > 1 ? render22(
              props,
              true ? {
                get attrs() {
                  markAttrsAccessed();
                  return attrs;
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render22(
              props,
              null
              /* we know it doesn't need it */
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root2 = result;
      let setRoot = void 0;
      if (result.patchFlag > 0 && result.patchFlag & 2048) {
        [root2, setRoot] = getChildRoot(result);
      }
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys2 = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root2;
        if (keys2.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys2.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root2 = cloneVNode(root2, fallthroughAttrs);
          } else if (!accessedAttrs && root2.type !== Comment) {
            const allAttrs = Object.keys(attrs);
            const eventAttrs = [];
            const extraAttrs = [];
            for (let i = 0, l = allAttrs.length; i < l; i++) {
              const key = allAttrs[i];
              if (isOn(key)) {
                if (!isModelListener(key)) {
                  eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                }
              } else {
                extraAttrs.push(key);
              }
            }
            if (extraAttrs.length) {
              warn$1(
                `Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
              );
            }
            if (eventAttrs.length) {
              warn$1(
                `Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
              );
            }
          }
        }
      }
      if (vnode.dirs) {
        if (!isElementRoot(root2)) {
          warn$1(
            `Runtime directive used on component with non-element root node. The directives will not function as intended.`
          );
        }
        root2 = cloneVNode(root2);
        root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        if (!isElementRoot(root2)) {
          warn$1(
            `Component inside <Transition> renders non-element root node that cannot be animated.`
          );
        }
        root2.transition = vnode.transition;
      }
      if (setRoot) {
        setRoot(root2);
      } else {
        result = root2;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getChildRoot = (vnode) => {
      const rawChildren = vnode.children;
      const dynamicChildren = vnode.dynamicChildren;
      const childRoot = filterSingleRoot(rawChildren, false);
      if (!childRoot) {
        return [vnode, void 0];
      } else if (childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {
        return getChildRoot(childRoot);
      }
      const index2 = rawChildren.indexOf(childRoot);
      const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
      const setRoot = (updatedRoot) => {
        rawChildren[index2] = updatedRoot;
        if (dynamicChildren) {
          if (dynamicIndex > -1) {
            dynamicChildren[dynamicIndex] = updatedRoot;
          } else if (updatedRoot.patchFlag > 0) {
            vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
          }
        }
      };
      return [normalizeVNode(childRoot), setRoot];
    };
    function filterSingleRoot(children, recurse = true) {
      let singleRoot;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isVNode(child)) {
          if (child.type !== Comment || child.children === "v-if") {
            if (singleRoot) {
              return;
            } else {
              singleRoot = child;
              if (recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {
                return filterSingleRoot(singleRoot.children);
              }
            }
          }
        } else {
          return;
        }
      }
      return singleRoot;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    const isElementRoot = (vnode) => {
      return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if ((prevChildren || nextChildren) && isHmrUpdating) {
        return true;
      }
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i = 0; i < dynamicProps.length; i++) {
            const key = dynamicProps[i];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el) {
      while (parent) {
        const root2 = parent.subTree;
        if (root2.suspense && root2.suspense.activeBranch === vnode) {
          root2.el = vnode.el;
        }
        if (root2 === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
        } else {
          break;
        }
      }
    }
    const COMPONENTS = "components";
    const DIRECTIVES = "directives";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString$2(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveDirective(name) {
      return resolveAsset(DIRECTIVES, name);
    }
    function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type] || Component[type], name) || // global registration
          resolve(instance.appContext[type], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        if (warnMissing && !res) {
          const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
          warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
      } else {
        warn$1(
          `resolve${capitalize(type.slice(0, -1))} can only be used in render() or setup().`
        );
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
    }
    const isSuspense = (type) => type.__isSuspense;
    function queueEffectWithSuspense(fn2, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$1(fn2)) {
          suspense.effects.push(...fn2);
        } else {
          suspense.effects.push(fn2);
        }
      } else {
        queuePostFlushCb(fn2);
      }
    }
    const ssrContextKey = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
          warn$1(
            `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
          );
        }
        return ctx;
      }
    };
    function watchEffect(effect2, options) {
      return doWatch(effect2, null, options);
    }
    const INITIAL_WATCHER_VALUE = {};
    function watch(source, cb, options) {
      if (!isFunction$1(cb)) {
        warn$1(
          `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
        );
      }
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, {
      immediate,
      deep,
      flush,
      once: once2,
      onTrack,
      onTrigger
    } = EMPTY_OBJ) {
      if (cb && once2) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          unwatch();
        };
      }
      if (deep !== void 0 && typeof deep === "number") {
        warn$1(
          `watch() "deep" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.`
        );
      }
      if (!cb) {
        if (immediate !== void 0) {
          warn$1(
            `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
          );
        }
        if (deep !== void 0) {
          warn$1(
            `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
          );
        }
        if (once2 !== void 0) {
          warn$1(
            `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
          );
        }
      }
      const warnInvalidSource = (s) => {
        warn$1(
          `Invalid watch source: `,
          s,
          `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
        );
      };
      const instance = currentInstance;
      const reactiveGetter = (source2) => deep === true ? source2 : (
        // for deep: false, only traverse root-level properties
        traverse(source2, deep === false ? 1 : void 0)
      );
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
      } else if (isArray$1(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return reactiveGetter(s);
          } else if (isFunction$1(s)) {
            return callWithErrorHandling(s, instance, 2);
          } else {
            warnInvalidSource(s);
          }
        });
      } else if (isFunction$1(source)) {
        if (cb) {
          getter = () => callWithErrorHandling(source, instance, 2);
        } else {
          getter = () => {
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(
              source,
              instance,
              3,
              [onCleanup]
            );
          };
        }
      } else {
        getter = NOOP;
        warnInvalidSource(source);
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn2) => {
        cleanup = effect2.onStop = () => {
          callWithErrorHandling(fn2, instance, 4);
          cleanup = effect2.onStop = void 0;
        };
      };
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        onCleanup = NOOP;
        if (!cb) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        if (flush === "sync") {
          const ctx = useSSRContext();
          ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else {
          return NOOP;
        }
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect2.active || !effect2.dirty) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb, instance, 3, [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect2.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === "sync") {
        scheduler = job;
      } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        job.pre = true;
        if (instance)
          job.id = instance.uid;
        scheduler = () => queueJob(job);
      }
      const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
      const scope = getCurrentScope();
      const unwatch = () => {
        effect2.stop();
        if (scope) {
          remove(scope.effects, effect2);
        }
      };
      {
        effect2.onTrack = onTrack;
        effect2.onTrigger = onTrigger;
      }
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect2.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(
          effect2.run.bind(effect2),
          instance && instance.suspense
        );
      } else {
        effect2.run();
      }
      if (ssrCleanup)
        ssrCleanup.push(unwatch);
      return unwatch;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$1(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
          cur = cur[segments[i]];
        }
        return cur;
      };
    }
    function traverse(value, depth, currentDepth = 0, seen) {
      if (!isObject$1(value) || value["__v_skip"]) {
        return value;
      }
      if (depth && depth > 0) {
        if (currentDepth >= depth) {
          return value;
        }
        currentDepth++;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      if (isRef(value)) {
        traverse(value.value, depth, currentDepth, seen);
      } else if (isArray$1(value)) {
        for (let i = 0; i < value.length; i++) {
          traverse(value[i], depth, currentDepth, seen);
        }
      } else if (isSet(value) || isMap(value)) {
        value.forEach((v) => {
          traverse(v, depth, currentDepth, seen);
        });
      } else if (isPlainObject$1(value)) {
        for (const key in value) {
          traverse(value[key], depth, currentDepth, seen);
        }
      }
      return value;
    }
    function validateDirectiveName(name) {
      if (isBuiltInDirective(name)) {
        warn$1("Do not use built-in directive ids as custom directive id: " + name);
      }
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        warn$1(`withDirectives can only be used inside render functions.`);
        return vnode;
      }
      const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
        if (dir) {
          if (isFunction$1(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
          binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const leaveCbKey = Symbol("_leaveCb");
    const enterCbKey = Symbol("_enterCb");
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          let child = children[0];
          if (children.length > 1) {
            let hasFound = false;
            for (const c of children) {
              if (c.type !== Comment) {
                if (hasFound) {
                  warn$1(
                    "<transition> can only be used on a single element or component. Use <transition-group> for lists."
                  );
                  break;
                }
                child = c;
                hasFound = true;
              }
            }
          }
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (mode && mode !== "in-out" && mode !== "out-in" && mode !== "default") {
            warn$1(`invalid <transition> mode: ${mode}`);
          }
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getKeepAliveChild(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          const enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(innerChild, enterHooks);
          const oldChild = instance.subTree;
          const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
          let transitionKeyChanged = false;
          const { getTransitionKey } = innerChild.type;
          if (getTransitionKey) {
            const key = getTransitionKey();
            if (prevTransitionKey === void 0) {
              prevTransitionKey = key;
            } else if (key !== prevTransitionKey) {
              prevTransitionKey = key;
              transitionKeyChanged = true;
            }
          }
          if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
            const leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in") {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (instance.update.active !== false) {
                  instance.effect.dirty = true;
                  instance.update();
                }
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el[leaveCbKey] = () => {
                  earlyRemove();
                  el[leaveCbKey] = void 0;
                  delete enterHooks.delayedLeave;
                };
                enterHooks.delayedLeave = delayedLeave;
              };
            }
          }
          return child;
        };
      }
    };
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$1(hook)) {
          if (hook.every((hook2) => hook2.length <= 1))
            done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el[leaveCbKey]) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook, [el]);
        },
        enter(el) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el[enterCbKey] = (cancelled) => {
            if (called)
              return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el]);
            } else {
              callHook2(afterHook, [el]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el[enterCbKey] = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el, done]);
          } else {
            done();
          }
        },
        leave(el, remove2) {
          const key2 = String(vnode.key);
          if (el[enterCbKey]) {
            el[enterCbKey](
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el]);
          let called = false;
          const done = el[leaveCbKey] = (cancelled) => {
            if (called)
              return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el]);
            } else {
              callHook2(onAfterLeave, [el]);
            }
            el[leaveCbKey] = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          return resolveTransitionHooks(vnode2, props, state, instance);
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getKeepAliveChild(vnode) {
      return isKeepAlive(vnode) ? (
        // #7121 ensure get the child component subtree in case
        // it's been replaced during HMR
        vnode.component ? vnode.component.subTree : vnode.children ? vnode.children[0] : void 0
      ) : vnode;
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
          if (child.patchFlag & 128)
            keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
          ret[i].patchFlag = -2;
        }
      }
      return ret;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineComponent(options, extraOptions) {
      return isFunction$1(options) ? (
        // #8326: extend call and options.name access are considered side-effects
        // by Rollup, so we have to wrap it in a pure-annotated IIFE.
        /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
      ) : options;
    }
    const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      const injected = injectHook(
        type,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type], injected);
      }, target);
    }
    function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          if (target.isUnmounted) {
            return;
          }
          pauseTracking();
          const reset = setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type, args);
          reset();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      } else {
        const apiName = toHandlerKey(ErrorTypeStrings$1[type].replace(/ hook$/, ""));
        warn$1(
          `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
        );
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => (
      // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
      (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
    );
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook("bu");
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook("bum");
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook("sp");
    const onRenderTriggered = createHook(
      "rtg"
    );
    const onRenderTracked = createHook(
      "rtc"
    );
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    function renderList(source, renderItem, cache, index2) {
      let ret;
      const cached = cache && cache[index2];
      if (isArray$1(source) || isString$2(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
          ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
        }
      } else if (typeof source === "number") {
        if (!Number.isInteger(source)) {
          warn$1(`The v-for range expect an integer value but got ${source}.`);
        }
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
          ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
        }
      } else if (isObject$1(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i) => renderItem(item, i, void 0, cached && cached[i])
          );
        } else {
          const keys2 = Object.keys(source);
          ret = new Array(keys2.length);
          for (let i = 0, l = keys2.length; i < l; i++) {
            const key = keys2[i];
            ret[i] = renderItem(source[key], key, i, cached && cached[i]);
          }
        }
      } else {
        ret = [];
      }
      if (cache) {
        cache[index2] = ret;
      }
      return ret;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default")
          props.name = name;
        return createVNode("slot", props, fallback && fallback());
      }
      let slot = slots[name];
      if (slot && slot.length > 1) {
        warn$1(
          `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`
        );
        slot = () => [];
      }
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode(slot(props));
      const rendered = createBlock(
        Fragment,
        {
          key: props.key || // slot content array of a dynamic conditional slot may have a branch
          // key attached in the `createSlots` helper, respect that
          validSlotContent && validSlotContent.key || `_${name}`
        },
        validSlotContent || (fallback ? fallback() : []),
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        if (child.type === Fragment && !ensureValidVNode(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    const getPublicInstance = (i) => {
      if (!i)
        return null;
      if (isStatefulComponent(i))
        return getExposeProxy(i) || i.proxy;
      return getPublicInstance(i.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
        $: (i) => i,
        $el: (i) => i.vnode.el,
        $data: (i) => i.data,
        $props: (i) => shallowReadonly(i.props),
        $attrs: (i) => shallowReadonly(i.attrs),
        $slots: (i) => shallowReadonly(i.slots),
        $refs: (i) => shallowReadonly(i.refs),
        $parent: (i) => getPublicInstance(i.parent),
        $root: (i) => getPublicInstance(i.root),
        $emit: (i) => i.emit,
        $options: (i) => resolveMergedOptions(i),
        $forceUpdate: (i) => i.f || (i.f = () => {
          i.effect.dirty = true;
          queueJob(i.update);
        }),
        $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
        $watch: (i) => instanceWatch.bind(i)
      })
    );
    const isReservedPrefix = (key) => key === "_" || key === "$";
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        if (key === "__isVue") {
          return true;
        }
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance, "get", key);
            markAttrsAccessed();
          } else if (key === "$slots") {
            track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else if (currentRenderingInstance && (!isString$2(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
        // to infinite warning loop
        key.indexOf("__v") !== 0)) {
          if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
            warn$1(
              `Property ${JSON.stringify(
              key
            )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
            );
          } else if (instance === currentRenderingInstance) {
            warn$1(
              `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`
            );
          }
        }
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (setupState.__isScriptSetup && hasOwn(setupState, key)) {
          warn$1(`Cannot mutate <script setup> binding "${key}" from Options API.`);
          return false;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          warn$1(`Attempting to mutate prop "${key}". Props are readonly.`);
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          warn$1(
            `Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`
          );
          return false;
        } else {
          if (key in instance.appContext.config.globalProperties) {
            Object.defineProperty(ctx, key, {
              enumerable: true,
              configurable: true,
              value
            });
          } else {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    {
      PublicInstanceProxyHandlers.ownKeys = (target) => {
        warn$1(
          `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
        );
        return Reflect.ownKeys(target);
      };
    }
    function createDevRenderContext(instance) {
      const target = {};
      Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: () => instance
      });
      Object.keys(publicPropertiesMap).forEach((key) => {
        Object.defineProperty(target, key, {
          configurable: true,
          enumerable: false,
          get: () => publicPropertiesMap[key](instance),
          // intercepted by the proxy so no need for implementation,
          // but needed to prevent set errors
          set: NOOP
        });
      });
      return target;
    }
    function exposePropsOnRenderContext(instance) {
      const {
        ctx,
        propsOptions: [propsOptions]
      } = instance;
      if (propsOptions) {
        Object.keys(propsOptions).forEach((key) => {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => instance.props[key],
            set: NOOP
          });
        });
      }
    }
    function exposeSetupStateOnRenderContext(instance) {
      const { ctx, setupState } = instance;
      Object.keys(toRaw(setupState)).forEach((key) => {
        if (!setupState.__isScriptSetup) {
          if (isReservedPrefix(key[0])) {
            warn$1(
              `setup() return property ${JSON.stringify(
              key
            )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
            );
            return;
          }
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => setupState[key],
            set: NOOP
          });
        }
      });
    }
    function useSlots() {
      return getContext().slots;
    }
    function useAttrs$1() {
      return getContext().attrs;
    }
    function getContext() {
      const i = getCurrentInstance();
      if (!i) {
        warn$1(`useContext() called without active instance.`);
      }
      return i.setupContext || (i.setupContext = createSetupContext(i));
    }
    function normalizePropsOrEmits(props) {
      return isArray$1(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    function createDuplicateChecker() {
      const cache = /* @__PURE__ */ Object.create(null);
      return (type, key) => {
        if (cache[key]) {
          warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
        } else {
          cache[key] = type;
        }
      };
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render: render2,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = createDuplicateChecker();
      {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) {
          for (const key in propsOptions) {
            checkDuplicateProperties("Props", key);
          }
        }
      }
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$1(methodHandler)) {
            {
              Object.defineProperty(ctx, key, {
                value: methodHandler.bind(publicThis),
                configurable: true,
                enumerable: true,
                writable: true
              });
            }
            {
              checkDuplicateProperties("Methods", key);
            }
          } else {
            warn$1(
              `Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`
            );
          }
        }
      }
      if (dataOptions) {
        if (!isFunction$1(dataOptions)) {
          warn$1(
            `The data option must be a function. Plain object usage is no longer supported.`
          );
        }
        const data = dataOptions.call(publicThis, publicThis);
        if (isPromise(data)) {
          warn$1(
            `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`
          );
        }
        if (!isObject$1(data)) {
          warn$1(`data() should return an object.`);
        } else {
          instance.data = reactive(data);
          {
            for (const key in data) {
              checkDuplicateProperties("Data", key);
              if (!isReservedPrefix(key[0])) {
                Object.defineProperty(ctx, key, {
                  configurable: true,
                  enumerable: true,
                  get: () => data[key],
                  set: NOOP
                });
              }
            }
          }
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          if (get2 === NOOP) {
            warn$1(`Computed property "${key}" has no getter.`);
          }
          const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : () => {
            warn$1(
              `Write operation failed: computed property "${key}" is readonly.`
            );
          };
          const c = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c.value,
            set: (v) => c.value = v
          });
          {
            checkDuplicateProperties("Computed", key);
          }
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$1(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$1(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render2 && instance.render === NOOP) {
        instance.render = render2;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components)
        instance.components = components;
      if (directives)
        instance.directives = directives;
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
      if (isArray$1(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$1(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx[key] = injected;
        }
        {
          checkDuplicateProperties("Inject", key);
        }
      }
    }
    function callHook$1(hook, instance, type) {
      callWithAsyncErrorHandling(
        isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type
      );
    }
    function createWatcher(raw, ctx, publicThis, key) {
      const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString$2(raw)) {
        const handler = ctx[raw];
        if (isFunction$1(handler)) {
          watch(getter, handler);
        } else {
          warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
        }
      } else if (isFunction$1(raw)) {
        watch(getter, raw.bind(publicThis));
      } else if (isObject$1(raw)) {
        if (isArray$1(raw)) {
          raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
        } else {
          const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction$1(handler)) {
            watch(getter, handler, raw);
          } else {
            warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
          }
        }
      } else {
        warn$1(`Invalid watch option: "${key}"`, raw);
      }
    }
    function resolveMergedOptions(instance) {
      const base = instance.type;
      const { mixins, extends: extendsOptions } = base;
      const {
        mixins: globalMixins,
        optionsCache: cache,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache.get(base);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
          );
        }
        mergeOptions(resolved, base, optionMergeStrategies);
      }
      if (isObject$1(base)) {
        cache.set(base, resolved);
      }
      return resolved;
    }
    function mergeOptions(to, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions(to, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m) => mergeOptions(to, m, strats, true)
        );
      }
      for (const key in from) {
        if (asMixin && key === "expose") {
          warn$1(
            `"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`
          );
        } else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
      }
      return to;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to, from) {
      if (!from) {
        return to;
      }
      if (!to) {
        return from;
      }
      return function mergedDataFn() {
        return extend(
          isFunction$1(to) ? to.call(this, this) : to,
          isFunction$1(from) ? from.call(this, this) : from
        );
      };
    }
    function mergeInject(to, from) {
      return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$1(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
          res[raw[i]] = raw[i];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to, from) {
      return to ? [...new Set([].concat(to, from))] : from;
    }
    function mergeObjectOptions(to, from) {
      return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
    }
    function mergeEmitsOrPropsOptions(to, from) {
      if (to) {
        if (isArray$1(to) && isArray$1(from)) {
          return [.../* @__PURE__ */ new Set([...to, ...from])];
        }
        return extend(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to),
          normalizePropsOrEmits(from != null ? from : {})
        );
      } else {
        return from;
      }
    }
    function mergeWatchOptions(to, from) {
      if (!to)
        return from;
      if (!from)
        return to;
      const merged = extend(/* @__PURE__ */ Object.create(null), to);
      for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render2, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$1(rootComponent)) {
          rootComponent = extend({}, rootComponent);
        }
        if (rootProps != null && !isObject$1(rootProps)) {
          warn$1(`root props passed to app.mount() must be an object.`);
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        let isMounted = false;
        const app = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version,
          get config() {
            return context.config;
          },
          set config(v) {
            {
              warn$1(
                `app.config cannot be replaced. Modify individual options instead.`
              );
            }
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin)) {
              warn$1(`Plugin has already been applied to target app.`);
            } else if (plugin && isFunction$1(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app, ...options);
            } else if (isFunction$1(plugin)) {
              installedPlugins.add(plugin);
              plugin(app, ...options);
            } else {
              warn$1(
                `A plugin must either be a function or an object with an "install" function.`
              );
            }
            return app;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              } else {
                warn$1(
                  "Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : "")
                );
              }
            }
            return app;
          },
          component(name, component) {
            {
              validateComponentName(name, context.config);
            }
            if (!component) {
              return context.components[name];
            }
            if (context.components[name]) {
              warn$1(`Component "${name}" has already been registered in target app.`);
            }
            context.components[name] = component;
            return app;
          },
          directive(name, directive) {
            {
              validateDirectiveName(name);
            }
            if (!directive) {
              return context.directives[name];
            }
            if (context.directives[name]) {
              warn$1(`Directive "${name}" has already been registered in target app.`);
            }
            context.directives[name] = directive;
            return app;
          },
          mount(rootContainer, isHydrate, namespace) {
            if (!isMounted) {
              if (rootContainer.__vue_app__) {
                warn$1(
                  `There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`
                );
              }
              const vnode = createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace === true) {
                namespace = "svg";
              } else if (namespace === false) {
                namespace = void 0;
              }
              {
                context.reload = () => {
                  render2(
                    cloneVNode(vnode),
                    rootContainer,
                    namespace
                  );
                };
              }
              if (isHydrate && hydrate) {
                hydrate(vnode, rootContainer);
              } else {
                render2(vnode, rootContainer, namespace);
              }
              isMounted = true;
              app._container = rootContainer;
              rootContainer.__vue_app__ = app;
              {
                app._instance = vnode.component;
                devtoolsInitApp(app, version);
              }
              return getExposeProxy(vnode.component) || vnode.component.proxy;
            } else {
              warn$1(
                `App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``
              );
            }
          },
          unmount() {
            if (isMounted) {
              render2(null, app._container);
              {
                app._instance = null;
                devtoolsUnmountApp(app);
              }
              delete app._container.__vue_app__;
            } else {
              warn$1(`Cannot unmount an app that is not mounted.`);
            }
          },
          provide(key, value) {
            if (key in context.provides) {
              warn$1(
                `App already provides property with key "${String(key)}". It will be overwritten with the new value.`
              );
            }
            context.provides[key] = value;
            return app;
          },
          runWithContext(fn2) {
            currentApp = app;
            try {
              return fn2();
            } finally {
              currentApp = null;
            }
          }
        };
        return app;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance) {
        {
          warn$1(`provide() can only be used inside setup().`);
        }
      } else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else {
          warn$1(`injection "${String(key)}" not found.`);
        }
      } else {
        warn$1(`inject() can only be used inside setup() or functional components.`);
      }
    }
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = {};
      def(attrs, InternalObjectKey, 1);
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      {
        validateProps(rawProps || {}, props, instance);
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function isInHmrContext(instance) {
      while (instance) {
        if (instance.type.__hmrId)
          return true;
        instance = instance.parent;
      }
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            let key = propsToUpdate[i];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger(instance, "set", "$attrs");
      }
      {
        validateProps(rawProps || {}, props, instance);
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
          const key = needCastKeys[i];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent2) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent2 && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.propsCache;
      const cached = cache.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$1(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
          extend(normalized, props);
          if (keys2)
            needCastKeys.push(...keys2);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$1(comp)) {
          cache.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$1(raw)) {
        for (let i = 0; i < raw.length; i++) {
          if (!isString$2(raw[i])) {
            warn$1(`props must be strings when using array syntax.`, raw[i]);
          }
          const normalizedKey = camelize(raw[i]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        if (!isObject$1(raw)) {
          warn$1(`invalid props options`, raw);
        }
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
            if (prop) {
              const booleanIndex = getTypeIndex(Boolean, prop.type);
              const stringIndex = getTypeIndex(String, prop.type);
              prop[
                0
                /* shouldCast */
              ] = booleanIndex > -1;
              prop[
                1
                /* shouldCastTrue */
              ] = stringIndex < 0 || booleanIndex < stringIndex;
              if (booleanIndex > -1 || hasOwn(prop, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$1(comp)) {
        cache.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$") {
        return true;
      } else {
        warn$1(`Invalid prop name: "${key}" is a reserved property.`);
      }
      return false;
    }
    function getType(ctor) {
      const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
      return match ? match[2] : ctor === null ? "null" : "";
    }
    function isSameType(a, b) {
      return getType(a) === getType(b);
    }
    function getTypeIndex(type, expectedTypes) {
      if (isArray$1(expectedTypes)) {
        return expectedTypes.findIndex((t) => isSameType(t, type));
      } else if (isFunction$1(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
      }
      return -1;
    }
    function validateProps(rawProps, props, instance) {
      const resolvedValues = toRaw(props);
      const options = instance.propsOptions[0];
      for (const key in options) {
        let opt = options[key];
        if (opt == null)
          continue;
        validateProp(
          key,
          resolvedValues[key],
          opt,
          shallowReadonly(resolvedValues),
          !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key))
        );
      }
    }
    function validateProp(name, value, prop, props, isAbsent2) {
      const { type, required, validator, skipCheck } = prop;
      if (required && isAbsent2) {
        warn$1('Missing required prop: "' + name + '"');
        return;
      }
      if (value == null && !required) {
        return;
      }
      if (type != null && type !== true && !skipCheck) {
        let isValid = false;
        const types = isArray$1(type) ? type : [type];
        const expectedTypes = [];
        for (let i = 0; i < types.length && !isValid; i++) {
          const { valid, expectedType } = assertType(value, types[i]);
          expectedTypes.push(expectedType || "");
          isValid = valid;
        }
        if (!isValid) {
          warn$1(getInvalidTypeMessage(name, value, expectedTypes));
          return;
        }
      }
      if (validator && !validator(value, props)) {
        warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
      }
    }
    const isSimpleType = /* @__PURE__ */ makeMap(
      "String,Number,Boolean,Function,Symbol,BigInt"
    );
    function assertType(value, type) {
      let valid;
      const expectedType = getType(type);
      if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        if (!valid && t === "object") {
          valid = value instanceof type;
        }
      } else if (expectedType === "Object") {
        valid = isObject$1(value);
      } else if (expectedType === "Array") {
        valid = isArray$1(value);
      } else if (expectedType === "null") {
        valid = value === null;
      } else {
        valid = value instanceof type;
      }
      return {
        valid,
        expectedType
      };
    }
    function getInvalidTypeMessage(name, value, expectedTypes) {
      if (expectedTypes.length === 0) {
        return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
      }
      let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
      const expectedType = expectedTypes[0];
      const receivedType = toRawType(value);
      const expectedValue = styleValue(value, expectedType);
      const receivedValue = styleValue(value, receivedType);
      if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean$1(expectedType, receivedType)) {
        message += ` with value ${expectedValue}`;
      }
      message += `, got ${receivedType} `;
      if (isExplicable(receivedType)) {
        message += `with value ${receivedValue}.`;
      }
      return message;
    }
    function styleValue(value, type) {
      if (type === "String") {
        return `"${value}"`;
      } else if (type === "Number") {
        return `${Number(value)}`;
      } else {
        return `${value}`;
      }
    }
    function isExplicable(type) {
      const explicitTypes = ["string", "number", "boolean"];
      return explicitTypes.some((elem) => type.toLowerCase() === elem);
    }
    function isBoolean$1(...args) {
      return args.some((elem) => elem.toLowerCase() === "boolean");
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (currentInstance && (!ctx || ctx.root === currentInstance.root)) {
          warn$1(
            `Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
          );
        }
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key))
          continue;
        const value = rawSlots[key];
        if (isFunction$1(value)) {
          slots[key] = normalizeSlot(key, value, ctx);
        } else if (value != null) {
          {
            warn$1(
              `Non-function value encountered for slot "${key}". Prefer function slots for better performance.`
            );
          }
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      if (!isKeepAlive(instance.vnode) && true) {
        warn$1(
          `Non-function value encountered for default slot. Prefer function slots for better performance.`
        );
      }
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const initSlots = (instance, children) => {
      if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          instance.slots = toRaw(children);
          def(children, "_", type);
        } else {
          normalizeObjectSlots(
            children,
            instance.slots = {}
          );
        }
      } else {
        instance.slots = {};
        if (children) {
          normalizeVNodeSlots(instance, children);
        }
      }
      def(instance.slots, InternalObjectKey, 1);
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          if (isHmrUpdating) {
            extend(slots, children);
            trigger(instance, "set", "$slots");
          } else if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            extend(slots, children);
            if (!optimized && type === 1) {
              delete slots._;
            }
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$1(rawRef)) {
        rawRef.forEach(
          (r, i) => setRef(
            r,
            oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      if (!owner) {
        warn$1(
          `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`
        );
        return;
      }
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref3) {
        if (isString$2(oldRef)) {
          refs[oldRef] = null;
          if (hasOwn(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$1(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString = isString$2(ref3);
        const _isRef = isRef(ref3);
        const isVFor = rawRef.f;
        if (_isString || _isRef) {
          const doSet = () => {
            if (isVFor) {
              const existing = _isString ? hasOwn(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray$1(existing) && remove(existing, refValue);
              } else {
                if (!isArray$1(existing)) {
                  if (_isString) {
                    refs[ref3] = [refValue];
                    if (hasOwn(setupState, ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref3] = value;
              if (hasOwn(setupState, ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else {
              warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
            }
          };
          if (isUnmount || isVFor) {
            doSet();
          } else {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          }
        } else {
          warn$1("Invalid template ref type:", ref3, `(${typeof ref3})`);
        }
      }
    }
    let supported;
    let perf;
    function startMeasure(instance, type) {
      if (instance.appContext.config.performance && isSupported()) {
        perf.mark(`vue-${type}-${instance.uid}`);
      }
      {
        devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
      }
    }
    function endMeasure(instance, type) {
      if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(
          `<${formatComponentName(instance, instance.type)}> ${type}`,
          startTag,
          endTag
        );
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
      }
      {
        devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
      }
    }
    function isSupported() {
      if (supported !== void 0) {
        return supported;
      }
      if (typeof window !== "undefined" && window.performance) {
        supported = true;
        perf = window.performance;
      } else {
        supported = false;
      }
      return supported;
    }
    function initFeatureFlags() {
      const needWarn = [];
      if (needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(
          `Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
        );
      }
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      {
        initFeatureFlags();
      }
      const target = getGlobalThis();
      target.__VUE__ = true;
      {
        setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
      }
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type, ref: ref3, shapeFlag } = n2;
        switch (type) {
          case Text:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, namespace);
            } else {
              patchStaticNode(n1, n2, container, namespace);
            }
            break;
          case Fragment:
            processFragment(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else {
              warn$1("Invalid VNode type:", type, `(${typeof type})`);
            }
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, namespace) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace,
          n2.el,
          n2.anchor
        );
      };
      const patchStaticNode = (n1, n2, container, namespace) => {
        if (n2.children !== n1.children) {
          const anchor = hostNextSibling(n1.anchor);
          removeStaticNode(n1);
          [n2.el, n2.anchor] = hostInsertStaticContent(
            n2.children,
            container,
            anchor,
            namespace
          );
        } else {
          n2.el = n1.el;
          n2.anchor = n1.anchor;
        }
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace = "svg";
        } else if (n2.type === "math") {
          namespace = "mathml";
        }
        if (n1 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(
          vnode.type,
          namespace,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(
                el,
                key,
                null,
                props[key],
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value, namespace);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        {
          Object.defineProperty(el, "__vnode", {
            value: vnode,
            enumerable: false
          });
          Object.defineProperty(el, "__vueParentComponent", {
            value: parentComponent,
            enumerable: false
          });
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i = 0; i < slotScopeIds.length; i++) {
            hostSetScopeId(el, slotScopeIds[i]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
            subTree = filterSingleRoot(subTree.children) || subTree;
          }
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
          const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (isHmrUpdating) {
          patchFlag = 0;
          optimized = false;
          dynamicChildren = null;
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            el,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds
          );
          {
            traverseStaticChildren(n1, n2);
          }
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(
              el,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              namespace
            );
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, namespace);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(
                    el,
                    key,
                    prev,
                    next,
                    namespace,
                    n1.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(
            el,
            n2,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            namespace
          );
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
          const oldVNode = oldChildren[i];
          const newVNode = newChildren[i];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el,
                  key,
                  oldProps[key],
                  null,
                  namespace,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key))
              continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (
          // #5523 dev root fragment may inherit directives
          isHmrUpdating || patchFlag & 2048
        ) {
          patchFlag = 0;
          optimized = false;
          dynamicChildren = null;
        }
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            // #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n1.dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            {
              traverseStaticChildren(n1, n2);
            }
          } else {
            patchChildren(
              n1,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              namespace,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              optimized
            );
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (instance.type.__hmrId) {
          registerHMR(instance);
        }
        {
          pushWarningContext(initialVNode);
          startMeasure(instance, `mount`);
        }
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          {
            startMeasure(instance, `init`);
          }
          setupComponent(instance);
          {
            endMeasure(instance, `init`);
          }
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            namespace,
            optimized
          );
        }
        {
          popWarningContext();
          endMeasure(instance, `mount`);
        }
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            {
              pushWarningContext(n2);
            }
            updateComponentPreRender(instance, n2, optimized);
            {
              popWarningContext();
            }
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.effect.dirty = true;
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m, parent } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
              const hydrateSubTree = () => {
                {
                  startMeasure(instance, `render`);
                }
                instance.subTree = renderComponentRoot(instance);
                {
                  endMeasure(instance, `render`);
                }
                {
                  startMeasure(instance, `hydrate`);
                }
                hydrateNode(
                  el,
                  instance.subTree,
                  instance,
                  parentSuspense,
                  null
                );
                {
                  endMeasure(instance, `hydrate`);
                }
              };
              if (isAsyncWrapperVNode) {
                initialVNode.type.__asyncLoader().then(
                  // note: we are moving the render call into an async callback,
                  // which means it won't track dependencies - but it's ok because
                  // a server-rendered async wrapper is already in resolved state
                  // and it will never need to change.
                  () => !instance.isUnmounted && hydrateSubTree()
                );
              } else {
                hydrateSubTree();
              }
            } else {
              {
                startMeasure(instance, `render`);
              }
              const subTree = instance.subTree = renderComponentRoot(instance);
              {
                endMeasure(instance, `render`);
              }
              {
                startMeasure(instance, `patch`);
              }
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                namespace
              );
              {
                endMeasure(instance, `patch`);
              }
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            {
              devtoolsComponentAdded(instance);
            }
            initialVNode = container = anchor = null;
          } else {
            let { next, bu, u, parent, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next;
            let vnodeHook;
            {
              pushWarningContext(next || instance.vnode);
            }
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            {
              startMeasure(instance, `render`);
            }
            const nextTree = renderComponentRoot(instance);
            {
              endMeasure(instance, `render`);
            }
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            {
              startMeasure(instance, `patch`);
            }
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace
            );
            {
              endMeasure(instance, `patch`);
            }
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
            {
              devtoolsComponentUpdated(instance);
            }
            {
              popWarningContext();
            }
          }
        };
        const effect2 = instance.effect = new ReactiveEffect(
          componentUpdateFn,
          NOOP,
          () => queueJob(update),
          instance.scope
          // track it in component's effect scope
        );
        const update = instance.update = () => {
          if (effect2.dirty) {
            effect2.run();
          }
        };
        update.id = instance.uid;
        toggleRecurse(instance, true);
        {
          effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
          effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
          update.ownerInstance = instance;
        }
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          patch(
            c1[i],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c1,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i <= e1 && i <= e2) {
          const n1 = c1[i];
          const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i++;
        }
        while (i <= e1 && i <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i > e1) {
          if (i <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i <= e2) {
              patch(
                null,
                c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              i++;
            }
          }
        } else if (i > e2) {
          while (i <= e1) {
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
          }
        } else {
          const s1 = i;
          const s2 = i;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i = s2; i <= e2; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (nextChild.key != null) {
              if (keyToNewIndexMap.has(nextChild.key)) {
                warn$1(
                  `Duplicate keys found during update:`,
                  JSON.stringify(nextChild.key),
                  `Make sure keys are unique.`
                );
              }
              keyToNewIndexMap.set(nextChild.key, i);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i = 0; i < toBePatched; i++)
            newIndexToOldIndexMap[i] = 0;
          for (i = s1; i <= e1; i++) {
            const prevChild = c1[i];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i = toBePatched - 1; i >= 0; i--) {
            const nextIndex = s2 + i;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type.move(vnode, container, anchor, internals);
          return;
        }
        if (type === Fragment) {
          hostInsert(el, container, anchor);
          for (let i = 0; i < children.length; i++) {
            move(children[i], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type,
          props,
          ref: ref3,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs
        } = vnode;
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              optimized,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
          if (vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
            vnode.children.forEach((child) => {
              if (child.type === Comment) {
                hostRemove(child.el);
              } else {
                remove2(child);
              }
            });
          } else {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end) => {
        let next;
        while (cur !== end) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        if (instance.type.__hmrId) {
          unregisterHMR(instance);
        }
        const { bum, scope, update, subTree, um } = instance;
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (update) {
          update.active = false;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
        {
          devtoolsComponentRemoved(instance);
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
          unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        return hostNextSibling(vnode.anchor || vnode.el);
      };
      let isFlushing2 = false;
      const render2 = (vnode, container, namespace) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace
          );
        }
        if (!isFlushing2) {
          isFlushing2 = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing2 = false;
        }
        container._vnode = vnode;
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(
          internals
        );
      }
      return {
        render: render2,
        hydrate,
        createApp: createAppAPI(render2, hydrate)
      };
    }
    function resolveChildrenNamespace({ type, props }, currentNamespace) {
      return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect: effect2, update }, allowed) {
      effect2.allowRecurse = update.allowRecurse = allowed;
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray$1(ch1) && isArray$1(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
          const c1 = ch1[i];
          let c2 = ch2[i];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i] = cloneIfMounted(ch2[i]);
              c2.el = c1.el;
            }
            if (!shallow)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text) {
            c2.el = c1.el;
          }
          if (c2.type === Comment && !c2.el) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i, j, u, v, c;
      const len = arr.length;
      for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i] = j;
            result.push(i);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c = u + v >> 1;
            if (arr[result[c]] < arrI) {
              u = c + 1;
            } else {
              v = c;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i] = result[u - 1];
            }
            result[u] = i;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    const isTeleport = (type) => type.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString$2(targetSelector)) {
        if (!select) {
          warn$1(
            `Current renderer does not support string target for Teleports. (missing querySelector renderer option)`
          );
          return null;
        } else {
          const target = select(targetSelector);
          if (!target) {
            warn$1(
              `Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
            );
          }
          return target;
        }
      } else {
        if (!targetSelector && !isTeleportDisabled(props)) {
          warn$1(`Invalid Teleport target: ${targetSelector}`);
        }
        return targetSelector;
      }
    };
    const TeleportImpl = {
      name: "Teleport",
      __isTeleport: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (isHmrUpdating) {
          optimized = false;
          dynamicChildren = null;
        }
        if (n1 == null) {
          const placeholder = n2.el = createComment("teleport start");
          const mainAnchor = n2.anchor = createComment("teleport end");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = n2.targetAnchor = createText("");
          if (target) {
            insert(targetAnchor, target);
            if (namespace === "svg" || isTargetSVG(target)) {
              namespace = "svg";
            } else if (namespace === "mathml" || isTargetMathML(target)) {
              namespace = "mathml";
            }
          } else if (!disabled) {
            warn$1("Invalid Teleport target on mount:", target, `(${typeof target})`);
          }
          const mount = (container2, anchor2) => {
            if (shapeFlag & 16) {
              mountChildren(
                children,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          };
          if (disabled) {
            mount(container, mainAnchor);
          } else if (target) {
            mount(target, targetAnchor);
          }
        } else {
          n2.el = n1.el;
          const mainAnchor = n2.anchor = n1.anchor;
          const target = n2.target = n1.target;
          const targetAnchor = n2.targetAnchor = n1.targetAnchor;
          const wasDisabled = isTeleportDisabled(n1.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          if (namespace === "svg" || isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace === "mathml" || isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            traverseStaticChildren(n1, n2, true);
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            } else {
              if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                n2.props.to = n1.props.to;
              }
            }
          } else {
            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              } else {
                warn$1(
                  "Invalid Teleport target on update:",
                  target,
                  `(${typeof target})`
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
              );
            }
          }
        }
        updateCssVars(n2);
      },
      remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
          hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
          const shouldRemove = doRemove || !isTeleportDisabled(props);
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            unmount(
              child,
              parentComponent,
              parentSuspense,
              shouldRemove,
              !!child.dynamicChildren
            );
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i = 0; i < children.length; i++) {
            move(
              children[i],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode, querySelector }
    }, hydrateChildren) {
      const target = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (isTeleportDisabled(vnode.props)) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetAnchor = targetNode;
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              targetAnchor = nextSibling(targetAnchor);
              if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            hydrateChildren(
              targetNode,
              vnode,
              target,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode) {
      const ctx = vnode.ctx;
      if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while (node && node !== vnode.targetAnchor) {
          if (node.nodeType === 1)
            node.setAttribute("data-v-owner", ctx.uid);
          node = node.nextSibling;
        }
        ctx.ut();
      }
    }
    const Fragment = Symbol.for("v-fgt");
    const Text = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
        n1.shapeFlag &= ~256;
        n2.shapeFlag &= ~512;
        return false;
      }
      return n1.type === n2.type && n1.key === n2.key;
    }
    const createVNodeWithArgsTransform = (...args) => {
      return _createVNode(
        ...args
      );
    };
    const InternalObjectKey = `__vInternal`;
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString$2(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString$2(children) ? 8 : 16;
      }
      if (vnode.key !== vnode.key) {
        warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = createVNodeWithArgsTransform;
    function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (!type) {
          warn$1(`Invalid vnode type when creating vnode: ${type}.`);
        }
        type = Comment;
      }
      if (isVNode(type)) {
        const cloned = cloneVNode(
          type,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag |= -2;
        return cloned;
      }
      if (isClassComponent(type)) {
        type = type.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString$2(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$1(style)) {
          if (isProxy(style) && !isArray$1(style)) {
            style = extend({}, style);
          }
          props.style = normalizeStyle(style);
        }
      }
      const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
      if (shapeFlag & 4 && isProxy(type)) {
        type = toRaw(type);
        warn$1(
          `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
          `
Component that was made reactive: `,
          type
        );
      }
      return createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false) {
      const { props, ref: ref3, patchFlag, children } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: patchFlag === -1 && isArray$1(children) ? children.map(deepCloneVNode) : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      return cloned;
    }
    function deepCloneVNode(vnode) {
      const cloned = cloneVNode(vnode);
      if (isArray$1(vnode.children)) {
        cloned.children = vnode.children.map(deepCloneVNode);
      }
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$1(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (typeof child === "object") {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$1(children)) {
        type = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type = 32;
          const slotFlag = children._;
          if (!slotFlag && !(InternalObjectKey in children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$1(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type = 16;
          children = [createTextVNode(children)];
        } else {
          type = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = createDevRenderContext(instance);
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let setInSSRSetupState;
    {
      const g = getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g[key]))
          setters = g[key] = [];
        setters.push(setter);
        return (v) => {
          if (setters.length > 1)
            setters.forEach((set2) => set2(v));
          else
            setters[0](v);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v) => currentInstance = v
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v) => isInSSRComponentSetup = v
      );
    }
    const setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
    function validateComponentName(name, config) {
      const appIsNativeTag = config.isNativeTag || NO;
      if (isBuiltInTag(name) || appIsNativeTag(name)) {
        warn$1(
          "Do not use built-in or reserved HTML elements as component id: " + name
        );
      }
    }
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      var _a2;
      const Component = instance.type;
      {
        if (Component.name) {
          validateComponentName(Component.name, instance.appContext.config);
        }
        if (Component.components) {
          const names2 = Object.keys(Component.components);
          for (let i = 0; i < names2.length; i++) {
            validateComponentName(names2[i], instance.appContext.config);
          }
        }
        if (Component.directives) {
          const names2 = Object.keys(Component.directives);
          for (let i = 0; i < names2.length; i++) {
            validateDirectiveName(names2[i]);
          }
        }
        if (Component.compilerOptions && isRuntimeOnly()) {
          warn$1(
            `"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`
          );
        }
      }
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
      {
        exposePropsOnRenderContext(instance);
      }
      const { setup } = Component;
      if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(
          setup,
          instance,
          0,
          [
            shallowReadonly(instance.props),
            setupContext
          ]
        );
        resetTracking();
        reset();
        if (isPromise(setupResult)) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
            if (!instance.suspense) {
              const name = (_a2 = Component.name) != null ? _a2 : "Anonymous";
              warn$1(
                `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
              );
            }
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$1(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$1(setupResult)) {
        if (isVNode(setupResult)) {
          warn$1(
            `setup() should not return VNodes directly - return a render function instead.`
          );
        }
        {
          instance.devtoolsRawSetupState = setupResult;
        }
        instance.setupState = proxyRefs(setupResult);
        {
          exposeSetupStateOnRenderContext(instance);
        }
      } else if (setupResult !== void 0) {
        warn$1(
          `setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`
        );
      }
      finishComponentSetup(instance, isSSR);
    }
    let compile;
    const isRuntimeOnly = () => !compile;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            {
              startMeasure(instance, `compile`);
            }
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend(
              extend(
                {
                  isCustomElement,
                  delimiters
                },
                compilerOptions
              ),
              componentCompilerOptions
            );
            Component.render = compile(template, finalCompilerOptions);
            {
              endMeasure(instance, `compile`);
            }
          }
        }
        instance.render = Component.render || NOOP;
      }
      {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          reset();
        }
      }
      if (!Component.render && instance.render === NOOP && !isSSR) {
        if (Component.template) {
          warn$1(
            `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
          );
        } else {
          warn$1(`Component is missing template or render function.`);
        }
      }
    }
    function getAttrsProxy(instance) {
      return instance.attrsProxy || (instance.attrsProxy = new Proxy(
        instance.attrs,
        {
          get(target, key) {
            markAttrsAccessed();
            track(instance, "get", "$attrs");
            return target[key];
          },
          set() {
            warn$1(`setupContext.attrs is readonly.`);
            return false;
          },
          deleteProperty() {
            warn$1(`setupContext.attrs is readonly.`);
            return false;
          }
        }
      ));
    }
    function getSlotsProxy(instance) {
      return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {
        get(target, key) {
          track(instance, "get", "$slots");
          return target[key];
        }
      }));
    }
    function createSetupContext(instance) {
      const expose = (exposed) => {
        {
          if (instance.exposed) {
            warn$1(`expose() should be called only once per setup().`);
          }
          if (exposed != null) {
            let exposedType = typeof exposed;
            if (exposedType === "object") {
              if (isArray$1(exposed)) {
                exposedType = "array";
              } else if (isRef(exposed)) {
                exposedType = "ref";
              }
            }
            if (exposedType !== "object") {
              warn$1(
                `expose() should be passed a plain object, received ${exposedType}.`
              );
            }
          }
        }
        instance.exposed = exposed || {};
      };
      {
        return Object.freeze({
          get attrs() {
            return getAttrsProxy(instance);
          },
          get slots() {
            return getSlotsProxy(instance);
          },
          get emit() {
            return (event, ...args) => instance.emit(event, ...args);
          },
          expose
        });
      }
    }
    function getExposeProxy(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$1(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    };
    function h(type, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject$1(propsOrChildren) && !isArray$1(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type, propsOrChildren, children);
      }
    }
    function isShallow2(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function initCustomFormatter() {
      if (typeof window === "undefined") {
        return;
      }
      const vueStyle = { style: "color:#3ba776" };
      const numberStyle = { style: "color:#1677ff" };
      const stringStyle = { style: "color:#f5222d" };
      const keywordStyle = { style: "color:#eb2f96" };
      const formatter = {
        header(obj) {
          if (!isObject$1(obj)) {
            return null;
          }
          if (obj.__isVue) {
            return ["div", vueStyle, `VueInstance`];
          } else if (isRef(obj)) {
            return [
              "div",
              {},
              ["span", vueStyle, genRefFlag(obj)],
              "<",
              formatValue(obj.value),
              `>`
            ];
          } else if (isReactive(obj)) {
            return [
              "div",
              {},
              ["span", vueStyle, isShallow2(obj) ? "ShallowReactive" : "Reactive"],
              "<",
              formatValue(obj),
              `>${isReadonly(obj) ? ` (readonly)` : ``}`
            ];
          } else if (isReadonly(obj)) {
            return [
              "div",
              {},
              ["span", vueStyle, isShallow2(obj) ? "ShallowReadonly" : "Readonly"],
              "<",
              formatValue(obj),
              ">"
            ];
          }
          return null;
        },
        hasBody(obj) {
          return obj && obj.__isVue;
        },
        body(obj) {
          if (obj && obj.__isVue) {
            return [
              "div",
              {},
              ...formatInstance(obj.$)
            ];
          }
        }
      };
      function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) {
          blocks.push(createInstanceBlock("props", toRaw(instance.props)));
        }
        if (instance.setupState !== EMPTY_OBJ) {
          blocks.push(createInstanceBlock("setup", instance.setupState));
        }
        if (instance.data !== EMPTY_OBJ) {
          blocks.push(createInstanceBlock("data", toRaw(instance.data)));
        }
        const computed2 = extractKeys(instance, "computed");
        if (computed2) {
          blocks.push(createInstanceBlock("computed", computed2));
        }
        const injected = extractKeys(instance, "inject");
        if (injected) {
          blocks.push(createInstanceBlock("injected", injected));
        }
        blocks.push([
          "div",
          {},
          [
            "span",
            {
              style: keywordStyle.style + ";opacity:0.66"
            },
            "$ (internal): "
          ],
          ["object", { object: instance }]
        ]);
        return blocks;
      }
      function createInstanceBlock(type, target) {
        target = extend({}, target);
        if (!Object.keys(target).length) {
          return ["span", {}];
        }
        return [
          "div",
          { style: "line-height:1.25em;margin-bottom:0.6em" },
          [
            "div",
            {
              style: "color:#476582"
            },
            type
          ],
          [
            "div",
            {
              style: "padding-left:1.25em"
            },
            ...Object.keys(target).map((key) => {
              return [
                "div",
                {},
                ["span", keywordStyle, key + ": "],
                formatValue(target[key], false)
              ];
            })
          ]
        ];
      }
      function formatValue(v, asRaw = true) {
        if (typeof v === "number") {
          return ["span", numberStyle, v];
        } else if (typeof v === "string") {
          return ["span", stringStyle, JSON.stringify(v)];
        } else if (typeof v === "boolean") {
          return ["span", keywordStyle, v];
        } else if (isObject$1(v)) {
          return ["object", { object: asRaw ? toRaw(v) : v }];
        } else {
          return ["span", stringStyle, String(v)];
        }
      }
      function extractKeys(instance, type) {
        const Comp = instance.type;
        if (isFunction$1(Comp)) {
          return;
        }
        const extracted = {};
        for (const key in instance.ctx) {
          if (isKeyOfType(Comp, key, type)) {
            extracted[key] = instance.ctx[key];
          }
        }
        return extracted;
      }
      function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if (isArray$1(opts) && opts.includes(key) || isObject$1(opts) && key in opts) {
          return true;
        }
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
          return true;
        }
        if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
          return true;
        }
      }
      function genRefFlag(v) {
        if (isShallow2(v)) {
          return `ShallowRef`;
        }
        if (v.effect) {
          return `ComputedRef`;
        }
        return `Ref`;
      }
      if (window.devtoolsFormatters) {
        window.devtoolsFormatters.push(formatter);
      } else {
        window.devtoolsFormatters = [formatter];
      }
    }
    const version = "3.4.15";
    const warn = warn$1;
    /**
    * @vue/runtime-dom v3.4.15
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const svgNS = "http://www.w3.org/2000/svg";
    const mathmlNS = "http://www.w3.org/1998/Math/MathML";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, namespace, is, props) => {
        const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? { is } : void 0);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el, id) {
        el.setAttribute(id, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, namespace, start, end) {
        const before2 = anchor ? anchor.previousSibling : parent.lastChild;
        if (start && (start === end || start.nextSibling)) {
          while (true) {
            parent.insertBefore(start.cloneNode(true), anchor);
            if (start === end || !(start = start.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
          const template = templateContainer.content;
          if (namespace === "svg" || namespace === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before2 ? before2.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const vtcKey = Symbol("_vtc");
    const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
    Transition.displayName = "Transition";
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    Transition.props = /* @__PURE__ */ extend(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const callHook = (hook, args = []) => {
      if (isArray$1(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type,
        duration,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el, isAppear, done);
          callHook(hook, [el, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el, type, enterDuration, resolve2);
            }
          });
        };
      };
      return extend(baseProps, {
        onBeforeEnter(el) {
          callHook(onBeforeEnter, [el]);
          addTransitionClass(el, enterFromClass);
          addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
          callHook(onBeforeAppear, [el]);
          addTransitionClass(el, appearFromClass);
          addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
          el._isLeaving = true;
          const resolve2 = () => finishLeave(el, done);
          addTransitionClass(el, leaveFromClass);
          forceReflow();
          addTransitionClass(el, leaveActiveClass);
          nextFrame(() => {
            if (!el._isLeaving) {
              return;
            }
            removeTransitionClass(el, leaveFromClass);
            addTransitionClass(el, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el, type, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el, resolve2]);
        },
        onEnterCancelled(el) {
          finishEnter(el, false);
          callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
          finishEnter(el, true);
          callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
          finishLeave(el);
          callHook(onLeaveCancelled, [el]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (isObject$1(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n = NumberOf(duration);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber$1(val);
      {
        assertNumber(res, "<transition> explicit duration");
      }
      return res;
    }
    function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
      (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
      const id = el._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id === el._endId) {
          resolve2();
        }
      };
      if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
      if (!type) {
        return resolve2();
      }
      const endEvent = type + "end";
      let ended = 0;
      const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
          end();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout + 1);
      el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
    }
    function toMs(s) {
      if (s === "auto")
        return 0;
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el, value, isSVG) {
      const transitionClasses = el[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    const vShowOldKey = Symbol("_vod");
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el[vShowOldKey] = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    {
      vShow.name = "show";
    }
    function setDisplay(el, value) {
      el.style.display = value ? el[vShowOldKey] : "none";
    }
    const CSS_VAR_TEXT = Symbol("CSS_VAR_TEXT");
    function patchStyle(el, prev, next) {
      const style = el.style;
      const currentDisplay = style.display;
      const isCssString = isString$2(next);
      if (next && !isCssString) {
        if (prev && !isString$2(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
        for (const key in next) {
          setStyle(style, key, next[key]);
        }
      } else {
        if (isCssString) {
          if (prev !== next) {
            const cssVarText = style[CSS_VAR_TEXT];
            if (cssVarText) {
              next += ";" + cssVarText;
            }
            style.cssText = next;
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
      }
      if (vShowOldKey in el) {
        style.display = currentDisplay;
      }
    }
    const semicolonRE = /[^\\];\s*$/;
    const importantRE = /\s*!important$/;
    function setStyle(style, name, val) {
      if (isArray$1(val)) {
        val.forEach((v) => setStyle(style, name, v));
      } else {
        if (val == null)
          val = "";
        {
          if (semicolonRE.test(val)) {
            warn(
              `Unexpected semicolon at the end of '${name}' style value: '${val}'`
            );
          }
        }
        if (name.startsWith("--")) {
          style.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style, name);
          if (importantRE.test(val)) {
            style.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style) {
        return prefixCache[rawName] = name;
      }
      name = capitalize(name);
      for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG, instance) {
      if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        const isBoolean2 = isSpecialBooleanAttr(key);
        if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(key, isBoolean2 ? "" : value);
        }
      }
    }
    function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) {
          unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? "" : value;
        return;
      }
      const tag = el.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        el._value = value;
        const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
        const newValue = value == null ? "" : value;
        if (oldValue !== newValue) {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type === "string") {
          value = "";
          needRemove = true;
        } else if (type === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e) {
        if (!needRemove) {
          warn(
            `Failed setting prop "${key}" on <${tag.toLowerCase()}>: value ${value} is invalid.`,
            e
          );
        }
      }
      needRemove && el.removeAttribute(key);
    }
    function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el[veiKey] || (el[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(nextValue, instance);
          addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$1(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map((fn2) => (e2) => !e2._stopped && fn2 && fn2(e2));
      } else {
        return value;
      }
    }
    const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    const patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      const isSVG = namespace === "svg";
      if (key === "class") {
        patchClass(el, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(
          el,
          key,
          nextValue,
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        );
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG) {
      if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && isNativeOn(key) && isFunction$1(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key) && isString$2(value)) {
        return false;
      }
      return key in el;
    }
    const getModelAssigner = (vnode) => {
      const fn2 = vnode.props["onUpdate:modelValue"] || false;
      return isArray$1(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el, { modifiers: { lazy, trim, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e) => {
          if (e.target.composing)
            return;
          let domValue = el.value;
          if (trim) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el[assignKey](domValue);
        });
        if (trim) {
          addEventListener(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el, "compositionstart", onCompositionStart);
          addEventListener(el, "compositionend", onCompositionEnd);
          addEventListener(el, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (el.composing)
          return;
        const elValue = number || el.type === "number" ? looseToNumber(el.value) : el.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el && el.type !== "range") {
          if (lazy) {
            return;
          }
          if (trim && el.value.trim() === newValue) {
            return;
          }
        }
        el.value = newValue;
      }
    };
    const vModelCheckbox = {
      // #4096 array checkboxes need to be deep traversed
      deep: true,
      created(el, _, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          const modelValue = el._modelValue;
          const elementValue = getValue$1(el);
          const checked = el.checked;
          const assign2 = el[assignKey];
          if (isArray$1(modelValue)) {
            const index2 = looseIndexOf(modelValue, elementValue);
            const found = index2 !== -1;
            if (checked && !found) {
              assign2(modelValue.concat(elementValue));
            } else if (!checked && found) {
              const filtered = [...modelValue];
              filtered.splice(index2, 1);
              assign2(filtered);
            }
          } else if (isSet(modelValue)) {
            const cloned = new Set(modelValue);
            if (checked) {
              cloned.add(elementValue);
            } else {
              cloned.delete(elementValue);
            }
            assign2(cloned);
          } else {
            assign2(getCheckboxValue(el, checked));
          }
        });
      },
      // set initial checked on mount to wait for true-value/false-value
      mounted: setChecked,
      beforeUpdate(el, binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
      }
    };
    function setChecked(el, { value, oldValue }, vnode) {
      el._modelValue = value;
      if (isArray$1(value)) {
        el.checked = looseIndexOf(value, vnode.props.value) > -1;
      } else if (isSet(value)) {
        el.checked = value.has(vnode.props.value);
      } else if (value !== oldValue) {
        el.checked = looseEqual(value, getCheckboxValue(el, true));
      }
    }
    function getValue$1(el) {
      return "_value" in el ? el._value : el.value;
    }
    function getCheckboxValue(el, checked) {
      const key = checked ? "_trueValue" : "_falseValue";
      return key in el ? el[key] : checked;
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
    };
    const withModifiers = (fn2, modifiers) => {
      const cache = fn2._withMods || (fn2._withMods = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
          const guard = modifierGuards[modifiers[i]];
          if (guard && guard(event, modifiers))
            return;
        }
        return fn2(event, ...args);
      });
    };
    const keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace"
    };
    const withKeys = (fn2, modifiers) => {
      const cache = fn2._withKeys || (fn2._withKeys = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event) => {
        if (!("key" in event)) {
          return;
        }
        const eventKey = hyphenate(event.key);
        if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
          return fn2(event);
        }
      });
    };
    const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const render = (...args) => {
      ensureRenderer().render(...args);
    };
    const createApp = (...args) => {
      const app = ensureRenderer().createApp(...args);
      {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
      }
      const { mount } = app;
      app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component = app._component;
        if (!isFunction$1(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function injectNativeTagCheck(app) {
      Object.defineProperty(app.config, "isNativeTag", {
        value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
        writable: false
      });
    }
    function injectCompilerOptionsCheck(app) {
      {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, "isCustomElement", {
          get() {
            return isCustomElement;
          },
          set() {
            warn(
              `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
            );
          }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
        Object.defineProperty(app.config, "compilerOptions", {
          get() {
            warn(msg);
            return compilerOptions;
          },
          set() {
            warn(msg);
          }
        });
      }
    }
    function normalizeContainer(container) {
      if (isString$2(container)) {
        const res = document.querySelector(container);
        if (!res) {
          warn(
            `Failed to mount app: mount target selector "${container}" returned null.`
          );
        }
        return res;
      }
      if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
        warn(
          `mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`
        );
      }
      return container;
    }
    /**
    * vue v3.4.15
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    function initDev() {
      {
        initCustomFormatter();
      }
    }
    {
      initDev();
    }
    var _GM_deleteValue = /* @__PURE__ */ (() => typeof GM_deleteValue != "undefined" ? GM_deleteValue : void 0)();
    var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
    var _GM_info = /* @__PURE__ */ (() => typeof GM_info != "undefined" ? GM_info : void 0)();
    var _GM_listValues = /* @__PURE__ */ (() => typeof GM_listValues != "undefined" ? GM_listValues : void 0)();
    var _GM_openInTab = /* @__PURE__ */ (() => typeof GM_openInTab != "undefined" ? GM_openInTab : void 0)();
    var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
    const _sfc_main$Q = /* @__PURE__ */ defineComponent({
      __name: "user-button",
      props: {
        isAnchor: { type: Boolean },
        shadowBorder: { type: Boolean },
        unsetBackground: { type: Boolean },
        themeStyle: { type: Boolean },
        noBorder: { type: Boolean }
      },
      setup(__props) {
        const props = __props;
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(_ctx.isAnchor ? "a" : "button"), {
            class: normalizeClass(["user-button", { "shadow-border": props.shadowBorder, "unset-background": props.unsetBackground, "theme-style": props.themeStyle, "no-border": props.noBorder }]),
            type: "button"
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["class"]);
        };
      }
    });
    const _withScopeId$9 = (n) => (pushScopeId("data-v-a6de5a03"), n = n(), popScopeId(), n);
    const _hoisted_1$r = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("span", null, "|", -1));
    const _hoisted_2$m = { class: "toast-controls" };
    const _sfc_main$P = /* @__PURE__ */ defineComponent({
      __name: "toast",
      props: {
        message: {},
        duration: { default: 6e3 },
        icon: {},
        type: {},
        blurEffect: { type: Boolean }
      },
      setup(__props) {
        const props = __props;
        const toastContainer = ref();
        function chooseIcon() {
          if (props.icon) {
            return props.icon;
          } else {
            if (props.type) {
              switch (props.type) {
                case "basic":
                  return void 0;
                case "check":
                  return "check";
                case "warning":
                  return "warning";
                case "error":
                  return "error";
                default:
                  return void 0;
              }
            }
          }
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "toastContainer",
            ref: toastContainer,
            class: normalizeClass(["toast-container", { "blur-effect": props.blurEffect }])
          }, [
            chooseIcon() ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(["toast-icon icon", props.type])
            }, toDisplayString(chooseIcon()), 3)) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: normalizeClass(["toast-content", props.type])
            }, toDisplayString(props.message), 3),
            _hoisted_1$r,
            createBaseVNode("div", _hoisted_2$m, [
              createVNode(_sfc_main$Q, {
                class: "close-button icon",
                "shadow-border": true,
                onClick: unref(passToNextToast)
              }, {
                default: withCtx(() => [
                  createTextVNode("close")
                ]),
                _: 1
              }, 8, ["onClick"])
            ])
          ], 2);
        };
      }
    });
    const _export_sfc$1 = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const toastVue = /* @__PURE__ */ _export_sfc$1(_sfc_main$P, [["__scopeId", "data-v-a6de5a03"]]);
    class Queue {
      constructor(items) {
        __publicField(this, "items", []);
        if (items)
          this.items = items;
      }
      /** 队首 */
      peek() {
        return this.items[0] ? this.items[0] : void 0;
      }
      /** 队列长度 */
      length() {
        return this.items.length;
      }
      /** 入队 */
      enqueue(...elements) {
        this.items.push(...elements);
      }
      /** 出队 */
      dequeue() {
        return this.items.shift();
      }
      /** 队列是否为空 */
      isEmpty() {
        return this.items.length === 0;
      }
      /** 清空队列 */
      clear() {
        this.items = [];
      }
    }
    let publicToastInstance;
    let isToasting = false;
    const toastsQueue = new Queue();
    function toast(props) {
      toastsQueue.enqueue([props, -1]);
      const interval = setInterval(() => {
        if (!isToasting) {
          const peek = toastsQueue.peek();
          if (peek)
            renderToast(peek[0]);
          clearInterval(interval);
        }
      }, 100);
    }
    function renderToast(toastProps) {
      isToasting = true;
      publicToastInstance = createApp(toastVue, toastProps);
      if (!document.getElementById(
        "t-wrapper"
        /* toast-wrapper */
      )) {
        document.body.insertBefore(templateCreate("div", {
          "id": "t-wrapper"
        }), document.body.firstChild);
      }
      const vm = publicToastInstance.mount("#t-wrapper");
      const peek = toastsQueue.peek();
      if (!peek)
        return;
      peek[1] = setTimeout(() => {
        publicToastInstance.unmount();
        toastsQueue.dequeue();
        isToasting = false;
      }, toastProps.duration ? toastProps.duration : 6e3);
      return vm;
    }
    function passToNextToast() {
      publicToastInstance.unmount();
      const peek = toastsQueue.peek();
      if (peek) {
        clearTimeout(peek[1]);
      }
      toastsQueue.dequeue();
      isToasting = false;
      const next = toastsQueue.peek();
      if (next) {
        setTimeout(() => {
          renderToast(next[0]);
        }, 10);
      }
    }
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root.Symbol;
    var objectProto$g = Object.prototype;
    var hasOwnProperty$d = objectProto$g.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$g.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$d.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$f = Object.prototype;
    var nativeObjectToString = objectProto$f.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var symbolTag$1 = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    var isArray = Array.isArray;
    var INFINITY$3 = 1 / 0;
    var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
    }
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    var reTrimStart$1 = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart$1, "") : string;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    var INFINITY$2 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY$2 || value === -INFINITY$2) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function identity$1(value) {
      return value;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$e = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$c = objectProto$e.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString$1.call(hasOwnProperty$c).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var WeakMap$1 = getNative(root, "WeakMap");
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function copyArray(source, array) {
      var index2 = -1, length = source.length;
      array || (array = Array(length));
      while (++index2 < length) {
        array[index2] = source[index2];
      }
      return array;
    }
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var baseSetToString = !defineProperty ? identity$1 : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    const baseSetToString$1 = baseSetToString;
    var setToString = shortOut(baseSetToString$1);
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var MAX_SAFE_INTEGER$2 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$2 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var objectProto$d = Object.prototype;
    var hasOwnProperty$b = objectProto$d.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$b.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index2 = -1, length = props.length;
      while (++index2 < length) {
        var key = props[index2];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    var nativeMax$6 = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax$6(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index2 = -1, length = nativeMax$6(args.length - start, 0), array = Array(length);
        while (++index2 < length) {
          array[index2] = args[start + index2];
        }
        index2 = -1;
        var otherArgs = Array(start + 1);
        while (++index2 < start) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity$1), func + "");
    }
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isIterateeCall(value, index2, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index2;
      if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
        return eq(object[index2], value);
      }
      return false;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index2 < length) {
          var source = sources[index2];
          if (source) {
            assigner(object, source, index2, customizer);
          }
        }
        return object;
      });
    }
    var objectProto$c = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$c;
      return value === proto;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    var argsTag$2 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$2;
    }
    var objectProto$b = Object.prototype;
    var hasOwnProperty$a = objectProto$b.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$a.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$1 = "[object WeakMap]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$1] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    var objectProto$a = Object.prototype;
    var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$9.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var nativeKeys = overArg(Object.keys, Object);
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$8.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty$7.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });
    const assign$1 = assign;
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$5.call(data, key) ? data[key] : void 0;
    }
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty$4.call(data, key);
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
      return this;
    }
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto$2 = Array.prototype;
    var splice$1 = arrayProto$2.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice$1.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root, "Map");
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT$3 = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$3);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    var INFINITY$1 = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
    }
    function baseGet(object, path) {
      path = castPath(path, object);
      var index2 = 0, length = path.length;
      while (object != null && index2 < length) {
        object = object[toKey(path[index2++])];
      }
      return index2 && index2 == length ? object : void 0;
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function arrayPush(array, values2) {
      var index2 = -1, length = values2.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values2[index2];
      }
      return array;
    }
    var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index2 = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index2 < length) {
        var value = array[index2];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectTag$2 = "[object Object]";
    var funcProto = Function.prototype, objectProto$4 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$3.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var FUNC_ERROR_TEXT$2 = "Expected a function";
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$2);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    function baseSlice(array, start, end) {
      var index2 = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index2 < length) {
        result[index2] = array[index2 + start];
      }
      return result;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f";
    var rsZWJ$2 = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function asciiToArray(string) {
      return string.split("");
    }
    var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
    var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var deburrLetter = basePropertyOf(deburredLetters);
    const deburrLetter$1 = deburrLetter;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
    var rsCombo$1 = "[" + rsComboRange$1 + "]";
    var reComboMark = RegExp(rsCombo$1, "g");
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
    }
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos$1 = "['’]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    var rsApos = "['’]";
    var reApos = RegExp(rsApos, "g");
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    var nativeIsFinite = root.isFinite, nativeMin$2 = Math.min;
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin$2(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
          pair = (toString(value) + "e").split("e");
          return +(pair[0] + "e" + (+pair[1] - precision));
        }
        return func(number);
      };
    }
    var nativeCeil = Math.ceil, nativeMax$5 = Math.max;
    function chunk(array, size2, guard) {
      if (guard ? isIterateeCall(array, size2, guard) : size2 === void 0) {
        size2 = 1;
      } else {
        size2 = nativeMax$5(toInteger(size2), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size2 < 1) {
        return [];
      }
      var index2 = 0, resIndex = 0, result = Array(nativeCeil(length / size2));
      while (index2 < length) {
        result[resIndex++] = baseSlice(array, index2, index2 += size2);
      }
      return result;
    }
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== void 0) {
          number = number <= upper ? number : upper;
        }
        if (lower !== void 0) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var length = buffer2.length, result = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
      buffer2.copy(result);
      return result;
    }
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$3 = Object.prototype;
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    const getSymbols$1 = getSymbols;
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols$1);
    }
    var DataView = getNative(root, "DataView");
    var Promise$1 = getNative(root, "Promise");
    var Set$1 = getNative(root, "Set");
    var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
    var dataViewTag$1 = "[object DataView]";
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$1;
            case mapCtorString:
              return mapTag$1;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$1;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    const getTag$1 = getTag;
    var Uint8Array2 = root.Uint8Array;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    function SetCache(values2) {
      var index2 = -1, length = values2 == null ? 0 : values2.length;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values2[index2]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack2.get(array);
      var othStacked = stack2.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
      stack2.set(array, other);
      stack2.set(other, array);
      while (++index2 < arrLength) {
        var arrValue = array[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack2) : customizer(arrValue, othValue, index2, array, other, stack2);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
          result = false;
          break;
        }
      }
      stack2["delete"](array);
      stack2["delete"](other);
      return result;
    }
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
    var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag$1 = "[object RegExp]", setTag = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag$1:
        case stringTag$1:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack2.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;
          stack2.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
          stack2["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    var COMPARE_PARTIAL_FLAG$3 = 1;
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack2.get(object);
      var othStacked = stack2.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack2.set(object, other);
      stack2.set(other, object);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack2["delete"](object);
      stack2["delete"](other);
      return result;
    }
    var COMPARE_PARTIAL_FLAG$2 = 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack2 || (stack2 = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack2 || (stack2 = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack2 || (stack2 = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
    }
    function baseIsEqual(value, other, bitmask, customizer, stack2) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
    }
    var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index2 = matchData.length, length = index2, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index2--) {
        var data = matchData[index2];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index2 < length) {
        data = matchData[index2];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack2 = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack2);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index2 = -1, length = path.length, result = false;
      while (++index2 < length) {
        var key = toKey(path[index2]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index2 != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity$1;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index2-- : ++index2 < length) {
          if (iteratee(iterable[index2], index2, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    var baseEach = createBaseEach(baseForOwn);
    const baseEach$1 = baseEach;
    var now = function() {
      return root.Date.now();
    };
    var FUNC_ERROR_TEXT$1 = "Expected a function";
    var nativeMax$4 = Math.max, nativeMin$1 = Math.min;
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax$4(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function defaultTo(value, defaultValue) {
      return value == null || value !== value ? defaultValue : value;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index2 = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index2 < length) {
        var source = sources[index2];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    const defaults$1 = defaults;
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack2.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
        stack2["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseMerge(object, source, srcIndex, customizer, stack2) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack2 || (stack2 = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function castFunction(value) {
      return typeof value == "function" ? value : identity$1;
    }
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach$1;
      return func(collection, castFunction(iteratee));
    }
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach$1(collection, function(value, index2, collection2) {
        if (predicate(value, index2, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate));
    }
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate);
          collection = keys(collection);
          predicate = function(key) {
            return iteratee(iterable[key], key, iterable);
          };
        }
        var index2 = findIndexFunc(collection, predicate, fromIndex);
        return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
      };
    }
    var nativeMax$3 = Math.max;
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index2 < 0) {
        index2 = nativeMax$3(length + index2, 0);
      }
      return baseFindIndex(array, baseIteratee(predicate), index2);
    }
    var find = createFind(findIndex);
    const find$1 = find;
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function findKey(object, predicate) {
      return baseFindKey(object, baseIteratee(predicate), baseForOwn);
    }
    var nativeMax$2 = Math.max, nativeMin = Math.min;
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index2 = length - 1;
      if (fromIndex !== void 0) {
        index2 = toInteger(fromIndex);
        index2 = fromIndex < 0 ? nativeMax$2(length + index2, 0) : nativeMin(index2, length - 1);
      }
      return baseFindIndex(array, baseIteratee(predicate), index2, true);
    }
    function baseMap(collection, iteratee) {
      var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach$1(collection, function(value, key, collection2) {
        result[++index2] = iteratee(value, key, collection2);
      });
      return result;
    }
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee));
    }
    var INFINITY = 1 / 0;
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, castFunction(iteratee));
    }
    function fromPairs(pairs) {
      var index2 = -1, length = pairs == null ? 0 : pairs.length, result = {};
      while (++index2 < length) {
        var pair = pairs[index2];
        result[pair[0]] = pair[1];
      }
      return result;
    }
    var stringTag = "[object String]";
    function isString$1(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }
    var nativeMax$1 = Math.max;
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax$1(length + fromIndex, 0);
      }
      return isString$1(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    var nativeMax = Math.max;
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index2 < 0) {
        index2 = nativeMax(length + index2, 0);
      }
      return baseIndexOf(array, value, index2);
    }
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isNil(value) {
      return value == null;
    }
    var regexpTag = "[object RegExp]";
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }
    var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
    function isUndefined$1(value) {
      return value === void 0;
    }
    var arrayProto$1 = Array.prototype;
    var nativeJoin = arrayProto$1.join;
    function join(array, separator) {
      return array == null ? "" : nativeJoin.call(array, separator);
    }
    var kebabCase = createCompounder(function(result, word, index2) {
      return result + (index2 ? "-" : "") + word.toLowerCase();
    });
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function once(func) {
      return before(2, func);
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    var nativeFloor = Math.floor;
    function baseRepeat(string, n) {
      var result = "";
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);
      return result;
    }
    function baseIndexOfWith(array, value, fromIndex, comparator2) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (comparator2(array[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function basePullAll(array, values2, iteratee, comparator2) {
      var indexOf2 = comparator2 ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
      if (array === values2) {
        values2 = copyArray(values2);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index2 < length) {
        var fromIndex = 0, value = values2[index2], computed2 = iteratee ? iteratee(value) : value;
        while ((fromIndex = indexOf2(seen, computed2, fromIndex, comparator2)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }
    function pullAll(array, values2) {
      return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
    }
    var pull = baseRest(pullAll);
    const pull$1 = pull;
    function repeat(string, n, guard) {
      if (guard ? isIterateeCall(string, n, guard) : n === void 0) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }
    var round = createRound("round");
    function baseSome(collection, predicate) {
      var result;
      baseEach$1(collection, function(value, index2, collection2) {
        result = predicate(value, index2, collection2);
        return !result;
      });
      return !!result;
    }
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate));
    }
    var MAX_ARRAY_LENGTH = 4294967295;
    function split(string, separator, limit) {
      if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
        separator = limit = void 0;
      }
      limit = limit === void 0 ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = guard || n === void 0 ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    var reTrimStart = /^\s+/;
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === void 0)) {
        return string.replace(reTrimStart, "");
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
      return castSlice(strSymbols, start).join("");
    }
    function baseZipObject(props, values2, assignFunc) {
      var index2 = -1, length = props.length, valsLength = values2.length, result = {};
      while (++index2 < length) {
        var value = index2 < valsLength ? values2[index2] : void 0;
        assignFunc(result, props[index2], value);
      }
      return result;
    }
    function zipObject(props, values2) {
      return baseZipObject(props || [], values2 || [], assignValue);
    }
    async function requestInstance(api) {
      try {
        const response = await api;
        if (response.ok) {
          return await response.json();
        }
      } catch (error) {
        toast({
          message: errorMessage(error),
          type: "error",
          duration: 6e3
        });
      }
    }
    const modules = [];
    function AllModules() {
      return modules;
    }
    function errorMessage(error) {
      const errBody = error.stack ? error.stack : error.message;
      return `${_GM_info.script.name} ${_GM_info.script.version}
${errBody}`;
    }
    function spawnOffsetTS(year = 0, month = 0, day = 0, hours = 0, minutes = 0, seconds = 0) {
      const now2 = /* @__PURE__ */ new Date();
      const offset = new Date(
        now2.getFullYear() + year,
        now2.getMonth() + month,
        now2.getDate() + day,
        now2.getHours() + hours,
        now2.getMinutes() + minutes,
        now2.getSeconds() + seconds,
        0
      );
      return offset.getTime();
    }
    function requestBody(body) {
      let reqBody = "";
      forOwn(body, (value, key) => {
        if (!value)
          value = "";
        reqBody += `${key}=${value}&`;
      });
      return reqBody.slice(0, -1);
    }
    function waitUtil(condition, timeout = 1e4, interval = 100) {
      return new Promise((resolve2, reject) => {
        const start = Date.now();
        const intervalId = setInterval(() => {
          if (condition()) {
            clearInterval(intervalId);
            resolve2();
          } else if (Date.now() - start > timeout) {
            clearInterval(intervalId);
            reject(new Error("Timeout"));
            console.warn("[waitUtil] 等待超时，该函数未在指定时间内得到期望值：", condition);
            console.trace("发生错误的调用者：");
          }
        }, interval);
      });
    }
    function isRealObject(obj) {
      return obj && typeof obj === "object" && !Array.isArray(obj);
    }
    function outputFile(filename, content) {
      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename;
      link.click();
      URL.revokeObjectURL(url);
    }
    async function selectLocalFile() {
      return new Promise((resolve2, reject) => {
        const input = document.createElement("input");
        input.type = "file";
        input.addEventListener("change", function() {
          if (!input.files)
            return;
          const file = input.files[0];
          const reader = new FileReader();
          reader.addEventListener("loadend", function() {
            const base64String = reader.result;
            resolve2(base64String);
          });
          reader.addEventListener("error", function() {
            reject(new Error());
          });
          reader.readAsText(file);
        });
        input.click();
      });
    }
    const fadeInElems = [];
    const fadeInClass = "fade-in-elem";
    function DOMS(...args) {
      const selector = args[0];
      switch (args.length) {
        case 1:
          return document.querySelectorAll(selector);
        case 2:
          if (args[1] instanceof Element) {
            return args[1].querySelectorAll(selector);
          } else {
            return document.querySelectorAll(selector);
          }
        case 3:
          return args[2].querySelectorAll(selector);
      }
    }
    function afterHead(callbackfn) {
      new Promise((_resolve, reject) => {
        try {
          const head = document.getElementsByTagName("head");
          if (head && head.length) {
            callbackfn();
          }
        } catch (error) {
          reject(error);
        }
      });
    }
    function mergeNodeAttrs(node, attrs) {
      forOwn(attrs, (value, key) => {
        if (value !== node.getAttribute(key)) {
          if (isRealObject(value)) {
            node.setAttribute(key, JSON.stringify(attrs[key]));
          } else {
            node.setAttribute(key, attrs[key]);
          }
        }
      });
    }
    function templateCreate(tag, attrs, children, doc2) {
      const DOC = doc2 ? doc2 : document;
      const elem = DOC.createElement(tag);
      if (attrs) {
        mergeNodeAttrs(elem, attrs);
      }
      if (children) {
        for (const child of children) {
          elem.appendChild(child);
        }
      }
      return elem;
    }
    function findParentByClass(elem, parentClassName) {
      var _a2;
      while (((_a2 = elem.parentElement) == null ? void 0 : _a2.className.indexOf(parentClassName)) === -1) {
        elem = elem.parentElement;
      }
      return elem.parentElement;
    }
    function fadeInLoad(selector) {
      DOMS(selector).forEach((elem) => {
        elem.classList.add(fadeInClass);
        elem.addEventListener("animationend", () => {
          elem.style.opacity = "1";
          elem.classList.remove(fadeInClass);
        });
      });
    }
    const tiebaAPI = {
      /** 首页推荐 */
      feedlist: () => fetch(`/f/index/feedlist?${requestBody({
      "is_new": 1,
      "tag_id": "like"
    })}`),
      /** 用户头像 */
      URL_profile: (portrait) => `https://gss0.baidu.com/7Ls0a8Sm2Q5IlBGlnYG/sys/portrait/item/${portrait}`,
      /** 当前登录用户信息 */
      userInfo: (serverTime) => fetch(`/f/user/json_userinfo?${requestBody({
      "_": serverTime
    })}`),
      /** 用户主页 */
      URL_userHome: (portrait) => `/home/main?id=${portrait}&fr=index`,
      /** 搜索建议 */
      suggestions: (query, encoding = "UTF-8", serverTime) => fetch(`/suggestion?${requestBody({
      "query": query,
      "ie": encoding,
      "_": serverTime
    })}`),
      /** 贴吧热议 */
      topicList: () => fetch("/hottopic/browse/topicList"),
      /** 吧跳转 */
      URL_forum: (keywords, encoding = "utf-8") => `/f?ie=${encoding}&kw=${keywords}`,
      /** 未读消息 */
      unreadMessages: (serverTime) => fetch(`/im/pcmsg/query/getAllUnread?${requestBody({
      "_": serverTime
    })}`),
      /** 收藏更新 */
      favUpdateNum: () => fetch("/sysmsg/userpost/queryStoreUpdateNum"),
      /** 获取 tbs */
      tbs: () => fetch("/dc/common/tbs"),
      /** imgtbs */
      imgtbs: () => fetch("/dc/common/imgtbs"),
      /** 获取已关注的吧 */
      followedForums: () => fetch("/mo/q/newmoindex"),
      /** 更详细的用户信息 */
      userInfoAll: (un2, encoding = "UTF-8") => fetch(`/home/get/panel?${requestBody({
      "ie": encoding,
      "un": un2
    })}`),
      /** 关注吧 */
      followForum: (tbs, forumId, forumName) => fetch(`/mo/q/favolike?${requestBody({
      "itb_tbs": tbs,
      "fid": forumId,
      "kw": forumName
    })}`),
      /** 取消关注吧 */
      unfollowForum: (tbs, forumName) => fetch(`/mo/q/delmylike?${requestBody({
      "itb_tbs": tbs,
      "forum_name": forumName
    })}`),
      /** 通过 `uid` 查找用户 */
      getUserFromUID: (uid2) => fetch(`/im/pcmsg/query/getUserInfo?${requestBody({
      "chatUid": uid2
    })}`),
      /** 一键签到（Web 端） */
      oneKeySign: () => fetch("/tbmall/onekeySignin1"),
      /** 热门动态 */
      hotFeeds: (un2, pn2, encoding = "utf-8", serverTime) => fetch(`/mo/q/newmoindex?${requestBody({
      "un": un2,
      "pn": pn2,
      "ie": encoding,
      "_": serverTime
    })}`),
      /** 获取当前页所有楼中楼数据 */
      totalComments: (timeStamp, tid, fid, pn2, lzOnly = false) => fetch(`/p/totalComment?${requestBody({
      "t": timeStamp,
      "tid": tid,
      "fid": fid,
      "pn": pn2,
      "see_lz": Number(lzOnly)
    })}`),
      /** 获取热门话题相关贴 */
      topicRelatedThreads: (topicName, page, lastId, topicId, sortType = 1) => fetch(`/hottopic/browse/getTopicRelateThread?${requestBody({
      "topic_name": topicName,
      "page_no": page,
      "last_id": lastId,
      "topic_id": topicId,
      "sort_type": sortType
    })}`),
      /** 将贴子添加到收藏 */
      addFavoritePost: (tbs, tid, fid, encoding = "utf-8") => fetch("/i/submit/open_storethread", {
        method: "POST",
        body: JSON.stringify({ tbs, tid, fid, encoding })
      }),
      forumSignInfo: (forumName, encoding = "utf-8") => fetch(`/sign/info?${requestBody({
      "kw": forumName,
      "ie": encoding
    })}`),
      forumLoadMonth: (forumName, encoding = "utf-8") => fetch(`/sign/loadmonth?${requestBody({
      "kw": forumName,
      "ie": encoding
    })}`),
      addFloor: (tbs, forum, forumId, threadId, content, floorNum, richText, ev = "comment", __type__ = "reply") => fetch("/f/commit/post/add", {
        method: "POST",
        body: JSON.stringify({
          "ie": "utf-8",
          "kw": forum,
          "fid": forumId,
          "tid": threadId,
          "floor_num": floorNum,
          "rich_text": Number(richText),
          "tbs": tbs,
          "content": content,
          "basilisk": 1,
          "nick_name": PageData.user.user_nickname,
          "ev": ev,
          "biz[po]": PageData.user.portrait.split("?")[0],
          "__type__": __type__,
          "geetest_success": 0
        })
      })
    };
    function parsePostFromElement(elem) {
      const titleTagWrapperAnch = DOMS(".title-tag-wraper a", "a", elem)[0];
      const threadNameWrapper = elem.getElementsByClassName("thread-name-wraper")[0];
      const threadNameWrapperAnch = threadNameWrapper.getElementsByTagName("a")[0];
      const listPostNum = DOMS(".list-post-num em", threadNameWrapper)[0];
      const imgs = DOMS("img:not(.nicknameEmoji)", "img", elem);
      const nReply = elem.getElementsByClassName("n_reply")[0];
      const nReplyAnch = nReply.getElementsByTagName("a")[0];
      const imgArray = [];
      if (imgs.length > 0) {
        forEach(imgs, (img) => {
          imgArray.push({
            thumb: img.src,
            original: defaultTo(img.getAttribute("original"), "")
          });
        });
      }
      return {
        id: defaultTo(elem.getAttribute("data-thread-id"), ""),
        forum: {
          id: defaultTo(elem.getAttribute("data-forum-id"), ""),
          name: titleTagWrapperAnch.title,
          href: titleTagWrapperAnch.href
        },
        author: {
          portrait: split(nReplyAnch.href, /(\?id=)|&/)[2],
          name: transEmojiFromDOMString(nReplyAnch.innerHTML),
          href: nReplyAnch.href
        },
        time: defaultTo(elem.getElementsByClassName("time")[0].textContent, ""),
        title: threadNameWrapperAnch.title,
        content: defaultTo(elem.getElementsByClassName("n_txt")[0].textContent, ""),
        replies: defaultTo(listPostNum.getAttribute("data-num"), 0),
        images: imgArray
      };
    }
    function parsePostsFromString(responseString, callbackfn) {
      const feedList = [];
      const dom = new DOMParser().parseFromString(responseString, "text/html");
      const threads = dom.getElementsByClassName("j_feed_li");
      const undesired = "home-place-item";
      forEach(threads, (thread2) => {
        if (thread2.classList.contains(undesired))
          return;
        const post = parsePostFromElement(thread2);
        if (callbackfn)
          callbackfn(post);
        feedList.push(post);
      });
      return feedList;
    }
    function transEmojiFromDOMString(str) {
      const indexRegex = new RegExp("(?<=nickemoji\\/).*?(?=.png)", "gi");
      if (!str.match(indexRegex))
        return str;
      const emojis = [
        "º",
        "◎",
        "▫",
        "◆",
        "♤",
        "♀",
        "♂",
        "ლ",
        "♬",
        "☞",
        "☜",
        "✆",
        "☎",
        "♋",
        "Ω",
        "℃",
        "℉",
        "😄",
        "😍",
        "😘",
        "😚",
        "😜",
        "😳",
        "😁",
        "😞",
        "😢",
        "😂",
        "😫",
        "😨",
        "😱",
        "😡",
        "😷",
        "😲",
        "😈",
        "🐷",
        "🐶",
        "🐑",
        "🐵",
        "🐨",
        "🐴",
        "🐼",
        "🐯",
        "🍪",
        "🍺",
        "🍦",
        "🍭",
        "🍗",
        "🍼",
        "🔯",
        "🍒",
        "👀",
        "🐭",
        "😇",
        "😺",
        "😻",
        "🙀",
        "😿",
        "😹",
        "😾",
        "👹",
        "👺",
        "🌞",
        "🌝",
        "🌚",
        "🌜",
        "🌛",
        "👦",
        "👧",
        "🎎",
        "🌸",
        "🍀",
        "🌹",
        "🌻",
        "🌺",
        "🍁",
        "🌿",
        "🍄",
        "🌵",
        "🌴",
        "🌳",
        "🌰",
        "🌱",
        "🌼",
        "🌐",
        "🌙",
        "🌋",
        "🌌",
        "⛅",
        "⚡",
        "☔",
        "⛄",
        "🌀",
        "🌈",
        "🌊",
        "🔥",
        "✨",
        "🌟",
        "💥",
        "💫",
        "💢",
        "💦",
        "💧",
        "💤",
        "💨",
        "🎀",
        "🌂",
        "💄",
        "💕",
        "💖",
        "💞",
        "💘",
        "💌",
        "💋",
        "💝",
        "🎒",
        "🎓",
        "🎏",
        "🎃",
        "👻",
        "🎅",
        "🎄",
        "🎁",
        "🙈",
        "🐒",
        "💯",
        "👯",
        "💍"
      ];
      const transformed = [
        "1-1.png",
        "1-2.png",
        "1-4.png",
        "1-5.png",
        "1-6.png",
        "1-7.png",
        "1-8.png",
        "1-9.png",
        "1-10.png",
        "1-11.png",
        "1-12.png",
        "1-13.png",
        "1-14.png",
        "1-15.png",
        "1-16.png",
        "1-17.png",
        "1-18.png",
        "1-19.png",
        "1-20.png",
        "1-21.png",
        "1-22.png",
        "1-23.png",
        "1-24.png",
        "1-25.png",
        "1-26.png",
        "1-27.png",
        "1-28.png",
        "1-29.png",
        "1-30.png",
        "1-31.png",
        "1-32.png",
        "1-33.png",
        "1-34.png",
        "1-35.png",
        "2-1.png",
        "2-2.png",
        "2-3.png",
        "2-4.png",
        "2-5.png",
        "2-6.png",
        "2-7.png",
        "2-8.png",
        "2-9.png",
        "2-10.png",
        "2-11.png",
        "2-12.png",
        "2-13.png",
        "2-14.png",
        "2-15.png",
        "2-16.png",
        "2-17.png",
        "2-18.png",
        "2-19.png",
        "2-20.png",
        "2-21.png",
        "2-22.png",
        "2-23.png",
        "2-24.png",
        "2-25.png",
        "2-26.png",
        "2-27.png",
        "2-28.png",
        "2-29.png",
        "2-30.png",
        "2-31.png",
        "2-32.png",
        "2-33.png",
        "2-34.png",
        "2-35.png",
        "3-1.png",
        "3-2.png",
        "3-3.png",
        "3-4.png",
        "3-5.png",
        "3-6.png",
        "3-7.png",
        "3-8.png",
        "3-9.png",
        "3-10.png",
        "3-11.png",
        "3-12.png",
        "3-13.png",
        "3-14.png",
        "3-15.png",
        "3-16.png",
        "3-17.png",
        "3-18.png",
        "3-19.png",
        "3-20.png",
        "3-21.png",
        "3-22.png",
        "3-23.png",
        "3-24.png",
        "3-25.png",
        "3-26.png",
        "3-27.png",
        "3-28.png",
        "3-29.png",
        "3-30.png",
        "3-31.png",
        "3-32.png",
        "3-33.png",
        "3-34.png",
        "3-35.png",
        "4-1.png",
        "4-2.png",
        "4-3.png",
        "4-4.png",
        "4-5.png",
        "4-6.png",
        "4-7.png",
        "4-8.png",
        "4-9.png",
        "4-10.png",
        "4-11.png",
        "4-12.png",
        "4-13.png",
        "4-14.png",
        "4-15.png",
        "4-16.png",
        "4-17.png",
        "4-18.png",
        "4-19.png",
        "4-20.png",
        "4-21.png",
        "4-22.png",
        "4-23.png"
      ];
      const arrIndex = str.match(indexRegex);
      arrIndex == null ? void 0 : arrIndex.forEach((index2) => {
        const emoji = emojis[transformed.indexOf(`${index2}.png`)];
        const arrInner = split(str, RegExp(
          `<img[^>]*?${index2}.png(?:[^>]*?)*>`,
          "g"
        ));
        str = join(arrInner, decodeURIComponent(emoji));
      });
      return str;
    }
    function levelToClass(level) {
      if (level < 0)
        return;
      if (level >= 1 && level <= 3)
        return "green";
      if (level >= 4 && level <= 9)
        return "blue";
      if (level >= 9 && level <= 15)
        return "yellow";
      if (level >= 16)
        return "orange";
    }
    const _sfc_main$O = /* @__PURE__ */ defineComponent({
      __name: "dialog-wrapper",
      props: {
        dialog: {},
        childProps: {},
        blurEffect: { type: Boolean },
        forced: { type: Boolean, default: false },
        darker: { type: Boolean, default: true }
      },
      emits: ["RequestClose"],
      setup(__props, { emit: __emit }) {
        const props = __props;
        const emit2 = __emit;
        onMounted(() => {
          const dialog = createApp(props.dialog, props.childProps);
          dialog.mount(".dialog-wrapper");
        });
        function onClick(e) {
          if (!includes(e.target.classList, "dialog-toggle"))
            return;
          if (!props.forced) {
            emit2("RequestClose");
            unloadDialog();
          }
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["dialog-wrapper dialog-toggle", { "blur-effect": props.blurEffect, "darker": props.darker }]),
            onClick
          }, null, 2);
        };
      }
    });
    const dialogWrapperVue = /* @__PURE__ */ _export_sfc$1(_sfc_main$O, [["__scopeId", "data-v-4b280e9a"]]);
    const defaultStyle = document.createElement("style");
    defaultStyle.id = "default-stylesheet";
    afterHead(() => {
      document.head.appendChild(defaultStyle);
    });
    function parseMultiCSS(cssObject) {
      return flatMapDeep(cssObject, (value, key) => {
        if (isPlainObject(value)) {
          return [
            `${key} {`,
            ...flatMapDeep(value, (v, k) => `${k}: ${v};`),
            "}",
            ""
          ];
        } else {
          return `${key} {${value}}`;
        }
      }).join("\n");
    }
    function parseCSSRule(cssObject) {
      let css = "";
      forOwn(cssObject, (value, key) => {
        css += `${kebabCase(key)}:${value};`;
      });
      return css;
    }
    function injectCSSList(css) {
      const cssElem = document.createElement("style");
      cssElem.textContent = css;
      afterHead(() => {
        document.head.appendChild(cssElem);
      });
      return cssElem;
    }
    function injectCSSRule(selector, cssObject) {
      if (selector === "")
        return;
      if (cssObject.length === 0)
        return;
      if (!defaultStyle.sheet)
        return;
      const css = `${selector}{${parseCSSRule(cssObject)}}`;
      return defaultStyle.sheet.insertRule(css);
    }
    function removeCSSRule(index2) {
      if (!defaultStyle.sheet)
        return;
      defaultStyle.sheet.deleteRule(index2);
    }
    function assignCSSRule(el, cssRule) {
      assign$1(el.style, cssRule);
    }
    let publicDialogInstance;
    const dialogQueue = new Queue();
    function renderComponent(root2, container, rootProps) {
      const app = createApp(root2, rootProps);
      app.mount(container);
      return app;
    }
    const scrollbarWidth = once(function() {
      const temp = templateCreate("div");
      assignCSSRule(temp, {
        width: "100px",
        height: "100px",
        overflow: "scroll",
        position: "absolute",
        top: "-9999px"
      });
      document.body.appendChild(temp);
      const scrollbarWidth2 = temp.offsetWidth - temp.clientWidth;
      document.body.removeChild(temp);
      return scrollbarWidth2;
    });
    function renderPage(root2, rootProps) {
      if (document.getElementsByTagName("body").length === 0) {
        document.documentElement.appendChild(templateCreate("body"));
      }
      removeDefault();
      const page = templateCreate("div", {
        id: "remixed-page"
      });
      document.body.insertBefore(page, document.body.firstChild);
      document.body.appendChild(templateCreate("div", {
        "id": "carousel_wrap"
      }));
      injectCSSRule("#spage-tbshare-container, .tbui_aside_float_bar", {
        display: "none !important"
      });
      return renderComponent(root2, page, rootProps);
    }
    async function renderDialog(dialog, dialogProps, wrapperProps) {
      const dialogWrapper = document.getElementById("dialog-wrapper");
      if (!dialogWrapper) {
        document.body.insertBefore(templateCreate("div", {
          "id": "dialog-wrapper"
        }), document.body.firstChild);
      }
      document.body.setAttribute("no-scrollbar", "");
      document.body.style.paddingRight = `${scrollbarWidth()}px`;
      if (dialogWrapper == null ? void 0 : dialogWrapper.hasChildNodes()) {
        dialogQueue.enqueue([dialog, dialogProps, wrapperProps]);
        return new Promise((resolve2) => {
          const peek = dialogQueue.peek();
          const interval = setInterval(() => {
            if (dialogQueue.peek() !== peek) {
              clearInterval(interval);
              resolve2("");
            }
          });
        });
      } else {
        publicDialogInstance = createApp(dialogWrapperVue, {
          dialog,
          childProps: dialogProps,
          ...wrapperProps
        });
        const vm = publicDialogInstance.mount("#dialog-wrapper");
        return vm;
      }
    }
    function unloadDialog() {
      document.body.removeAttribute("no-scrollbar");
      document.body.style.paddingRight = "";
      if (publicDialogInstance)
        publicDialogInstance.unmount();
      const next = dialogQueue.dequeue();
      if (next) {
        renderDialog(next[0], next[1], next[2]);
      }
    }
    function removeDefault() {
      forEach(document.head.children, (el) => {
        if (el && el.tagName.toUpperCase() === "LINK" && includes(el.getAttribute("href"), "static-common/style")) {
          el.remove();
        }
        if (el && el.tagName.toUpperCase() === "SCRIPT" && includes(el.getAttribute("src"), "static-common/lib")) {
          el.remove();
        }
      });
      forEach(document.body.children, (el) => {
        if (el && el.tagName.toUpperCase() === "STYLE") {
          el.remove();
        }
        if (el && el.tagName.toUpperCase() === "SCRIPT") {
          el.remove();
        }
        if (el && el.tagName.toUpperCase() === "IFRAME") {
          el.remove();
        }
        if (el && includes(el.className, "translatorExtension")) {
          el.remove();
        }
        if (el && includes(el.className, "dialogJ")) {
          el.remove();
        }
      });
    }
    const _hoisted_1$q = { class: "message-box remove-default" };
    const _hoisted_2$l = {
      key: 0,
      class: "title"
    };
    const _hoisted_3$e = {
      key: 0,
      class: "message-controls"
    };
    const _hoisted_4$c = {
      key: 1,
      class: "message-controls"
    };
    const _sfc_main$N = /* @__PURE__ */ defineComponent({
      __name: "message-box",
      props: {
        title: {},
        message: {},
        type: { default: "basic" },
        embedded: { type: Boolean },
        buttons: {}
      },
      emits: ["positive", "cancel", "negative"],
      setup(__props, { emit: __emit }) {
        const props = __props;
        const messageWrapper = ref();
        const messageContent = ref();
        const emit2 = __emit;
        onMounted(function() {
          if (props.embedded) {
            if (messageContent.value) {
              if (props.message) {
                messageContent.value.innerHTML = props.message;
              }
            }
          }
        });
        function defaultClose(event) {
          event();
          emitAndClose("positive");
        }
        function emitAndClose(emitName) {
          emit2(emitName, emitName);
          setMessageInbox(emitName);
          unloadDialog();
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$q, [
            createBaseVNode("div", {
              ref_key: "messageWrapper",
              ref: messageWrapper,
              class: "message-wrapper"
            }, [
              props.title ? (openBlock(), createElementBlock("div", _hoisted_2$l, toDisplayString(props.title), 1)) : createCommentVNode("", true),
              props.message ? (openBlock(), createElementBlock("div", {
                key: 1,
                ref_key: "messageContent",
                ref: messageContent,
                class: "message markdown"
              }, toDisplayString(props.message), 513)) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "default", {}, void 0, true)
            ], 512),
            !props.buttons || props.buttons.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_3$e, [
              createVNode(_sfc_main$Q, {
                class: "message-button",
                "shadow-border": true,
                "theme-style": true,
                onClick: _cache[0] || (_cache[0] = ($event) => emitAndClose("positive"))
              }, {
                default: withCtx(() => [
                  createTextVNode(" 确定")
                ]),
                _: 1
              }),
              props.type === "OkCancel" ? (openBlock(), createBlock(_sfc_main$Q, {
                key: 0,
                class: "message-button",
                "shadow-border": true,
                onClick: _cache[1] || (_cache[1] = ($event) => emitAndClose("cancel"))
              }, {
                default: withCtx(() => [
                  createTextVNode("取消")
                ]),
                _: 1
              })) : createCommentVNode("", true),
              props.type === "forceTrueFalse" ? (openBlock(), createBlock(_sfc_main$Q, {
                key: 1,
                class: "message-button",
                "shadow-border": true,
                onClick: _cache[2] || (_cache[2] = ($event) => emitAndClose("cancel"))
              }, {
                default: withCtx(() => [
                  createTextVNode("拒绝")
                ]),
                _: 1
              })) : createCommentVNode("", true)
            ])) : (openBlock(), createElementBlock("div", _hoisted_4$c, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(props.buttons, (button, index2) => {
                return openBlock(), createBlock(_sfc_main$Q, {
                  class: "message-button",
                  "shadow-border": "",
                  "theme-style": index2 == 0,
                  onClick: ($event) => defaultClose(button.event)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(button.title), 1)
                  ]),
                  _: 2
                }, 1032, ["theme-style", "onClick"]);
              }), 256))
            ]))
          ]);
        };
      }
    });
    const messageBoxVue = /* @__PURE__ */ _export_sfc$1(_sfc_main$N, [["__scopeId", "data-v-8df9d0bc"]]);
    let messageInbox;
    function messageBox(messageBoxProps) {
      renderDialog(messageBoxVue, {
        message: messageBoxProps.message,
        title: messageBoxProps.title,
        type: messageBoxProps.type,
        embedded: messageBoxProps.embedded,
        buttons: messageBoxProps.buttons
      }, {
        forced: messageBoxProps.type === "forceTrueFalse"
      });
      return new Promise((resolve2) => {
        const interval = setInterval(() => {
          const inbox = getMessageInbox();
          if (inbox) {
            clearInterval(interval);
            resolve2(inbox);
          }
        }, 10);
      });
    }
    function getMessageInbox() {
      const inbox = messageInbox;
      messageInbox = void 0;
      return inbox;
    }
    function setMessageInbox(value) {
      messageInbox = value;
    }
    const MainTitle = "Tieba Remix";
    const Owner = "WiresawBlade";
    const RepoName = "Tieba-Remix";
    const GithubRepo = "https://github.com/WiresawBlade/Tieba-Remix";
    const GiteeRepo = "https://gitee.com/WiresawBlade/Tieba-Remix/";
    const BaiduPassport = "https://passport.baidu.com/";
    const REMIXED = "\n██████╗ ███████╗███╗   ███╗██╗██╗  ██╗███████╗██████╗ \n██╔══██╗██╔════╝████╗ ████║██║╚██╗██╔╝██╔════╝██╔══██╗\n██████╔╝█████╗  ██╔████╔██║██║ ╚███╔╝ █████╗  ██║  ██║\n██╔══██╗██╔══╝  ██║╚██╔╝██║██║ ██╔██╗ ██╔══╝  ██║  ██║\n██║  ██║███████╗██║ ╚═╝ ██║██║██╔╝ ██╗███████╗██████╔╝\n╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝╚═╝╚═╝  ╚═╝╚══════╝╚═════╝ \n";
    class UserKey {
      constructor(key, defaultValue) {
        __publicField(this, "key");
        __publicField(this, "defaultValue");
        this.key = key;
        this.defaultValue = defaultValue;
      }
      get() {
        let payload = _GM_getValue(this.key, this.defaultValue);
        if (isRealObject(payload) && keys(payload).length < keys(this.defaultValue).length) {
          payload = { ...this.defaultValue, ...payload };
        }
        return payload;
      }
      set(value) {
        _GM_setValue(this.key, value);
      }
      remove() {
        _GM_deleteValue(this.key);
      }
      merge(value) {
        if (isRealObject(value)) {
          this.set({ ...this.get(), ...value });
        }
      }
      mergeDeeply(value) {
        if (isRealObject(value)) {
          this.set(merge(this.get(), value));
        }
      }
    }
    class UserKeyTS extends UserKey {
      constructor(key, defaultValue, invalidfn) {
        super(key, defaultValue);
        __publicField(this, "defaultInvalid", () => spawnOffsetTS(0, 0, 0, 12));
        this.defaultInvalid = invalidfn ? invalidfn : this.defaultInvalid;
      }
      get() {
        let payload = getUserValueTS(this.key, this.defaultValue);
        if (isRealObject(payload) && keys(payload).length < keys(this.defaultValue).length) {
          payload = { ...this.defaultValue, ...payload };
        }
        return payload;
      }
      /**
       * 设置时间敏感的用户 key
       * @param value 需要设置的值
       * @param invalidTime 失效时间，默认为函数执行 12 小时后
       */
      set(value, invalidTime) {
        setUserValueTS(this.key, value, invalidTime ? invalidTime : this.defaultInvalid());
      }
      merge(value, invalidTime) {
        if (isRealObject(value)) {
          this.set({ ...this.get(), ...value }, invalidTime ? invalidTime : this.defaultInvalid());
        }
      }
      mergeDeeply(value, invalidTime) {
        if (isRealObject(value)) {
          this.set(merge(this.get(), value), invalidTime ? invalidTime : this.defaultInvalid());
        }
      }
    }
    const disabledModules = new UserKey("disabledModules", []);
    const unreadFeeds = new UserKeyTS("unreadFeeds", []);
    const experimental = new UserKey("experimental", {});
    const latestRelease = new UserKeyTS("latestRelease", void 0);
    const updateConfig = new UserKey("updateConfig", {
      time: "6h",
      notify: true
    });
    const showUpdateToday = new UserKeyTS("showUpdateToday", true, () => (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0) + 24 * 60 * 60 * 1e3);
    const ignoredTag = new UserKey("ignoredTag", "");
    const themeType = new UserKey("themeType", "auto");
    const compactLayout = new UserKey("compactLayout", false);
    const wideScreen = new UserKey("wideScreen", {
      maxPX: 1080,
      noLimit: false
    });
    const themeColor = new UserKey("themeColor", {
      light: "#614ec2",
      dark: "#7161c1"
    });
    const customBackground = new UserKey("customBackground", null);
    const pageExtensions = new UserKey("pageExtension", {
      index: true,
      thread: true
    });
    function getUserValueTS(key, def2) {
      try {
        const valueTS = _GM_getValue(key, {
          value: def2,
          invalidTime: 0
        });
        const timeStamp = Date.now();
        if (valueTS.invalidTime >= timeStamp) {
          return valueTS.value;
        } else {
          return def2;
        }
      } catch (error) {
        return def2;
      }
    }
    function setUserValueTS(key, value, invalidTime) {
      try {
        if (invalidTime) {
          _GM_setValue(key, {
            value,
            invalidTime
          });
        } else {
          _GM_setValue(key, value);
        }
      } catch (error) {
        console.warn("setUserValueTS", error);
      }
    }
    const _sfc_main$M = {};
    const _hoisted_1$p = { class: "block-panel blur-if-custom-background" };
    function _sfc_render$8(_ctx, _cache) {
      return openBlock(), createElementBlock("div", _hoisted_1$p, [
        renderSlot(_ctx.$slots, "default")
      ]);
    }
    const BlockPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$M, [["render", _sfc_render$8]]);
    /**
     * Flex Masonry
     * @author @WiresawBlade
     * @version 1.0
     * @license MIT
     */
    class FlexMasonry {
      constructor(options) {
        __publicField(this, "container");
        __publicField(this, "items");
        __publicField(this, "columnContainers", []);
        __publicField(this, "columnWidth");
        __publicField(this, "gap");
        __publicField(this, "options");
        __publicField(this, "containerSelector");
        __publicField(this, "itemsSelector");
        __publicField(this, "columnSelector", ".masonry-column");
        __publicField(this, "columnsHeight", []);
        __publicField(this, "fragment");
        /** 当前布局的列数 */
        __publicField(this, "columns");
        options = parseOptions(options);
        this.container = (() => {
          if (typeof options.container === "string") {
            this.containerSelector = options.container;
            const _container = document.querySelector(options.container);
            if (_container) {
              return _container;
            } else {
              throw new Error("Can't find container element.");
            }
          } else {
            return options.container;
          }
        })();
        if (options.items) {
          this.items = (() => {
            if (typeof options.items === "string") {
              this.itemsSelector = options.items;
              const _items = document.querySelectorAll(options.items);
              if (_items) {
                return Array.from(_items);
              } else {
                return [];
              }
            } else {
              return options.items;
            }
          })().map((el) => {
            el.style.visibility = "hidden";
            return { element: el, cachedHeight: el.clientHeight };
          });
        } else {
          this.items = [];
        }
        this.columnWidth = options.columnWidth;
        if (options.gap) {
          if (Array.isArray(options.gap)) {
            this.gap = options.gap;
          } else {
            this.gap = [options.gap, options.gap];
          }
        } else {
          this.gap = [0, 0];
        }
        this.columns = 0;
        this.options = options;
        this.initStyle();
        if (options.autoExec)
          this.exec();
      }
      initStyle() {
        this.container.style.display = "flex";
        this.container.style.alignItems = "flex-start";
        this.container.style.justifyContent = "center";
        this.container.style.gap = `${this.gap[0]}px`;
      }
      /** 执行布局 */
      exec() {
        this.calcColumns();
        const originalPosition = window.scrollY || window.pageYOffset;
        this.calc();
        this.layout();
        if (this.options.fixScrollOffset)
          window.scrollTo(0, originalPosition);
      }
      /** 仅计算布局 */
      calc() {
        this.columnsHeight = Array(this.calcColumns()).fill(0);
        const fragment = document.createDocumentFragment();
        const _col = this.container.querySelectorAll(this.columnSelector);
        _col.forEach((col) => {
          col.remove();
        });
        this.columnContainers.length = 0;
        for (let i = 0; i < this.columns; i++) {
          this.columnContainers.push(
            fragment.appendChild(createNewElement("div", {
              class: this.columnSelector.substring(1)
            }))
          );
        }
        this.columnContainers.forEach((ccontainer) => {
          ccontainer.style.display = "flex";
          ccontainer.style.flexDirection = "column";
          ccontainer.style.gap = `${this.gap[1]}px`;
        });
        this.items.forEach((el) => {
          this._appendElement(el);
        });
        this.fragment = fragment;
      }
      /**
       * 仅应用布局
       * 
       * 调用该函数前需要已经至少计算过一次布局
       */
      layout() {
        if (this.fragment) {
          this.container.appendChild(this.fragment);
        } else {
          throw Error("Never conducted layout calculations before. You should use exec() or calc() first.");
        }
      }
      removeUnusedColumns() {
        const _col = this.container.querySelectorAll(this.columnSelector);
        _col.forEach((col) => {
          if (col.children.length === 0)
            col.remove();
        });
      }
      /** 
       * 清空布局中的所有 `items`
       *  
       * 该操作并不会将元素从文档中移除
       */
      clear() {
        this.items.length = 0;
      }
      /** 仅计算当前需要的列数 */
      calcColumns() {
        this.columns = Math.ceil((this.container.clientWidth - this.columnWidth) / (this.columnWidth + this.gap[0]));
        return this.columns;
      }
      /**
       * 向布局中加入元素
       * @param el 要添加的元素
       */
      appendElement(...elems) {
        const masonryElements = elems.map((el) => {
          return {
            element: el,
            cachedHeight: el.clientHeight
          };
        });
        this._appendElement(...masonryElements);
        this.items.push(...masonryElements);
      }
      _appendElement(...elems) {
        elems.forEach((el) => {
          const minIndex = this.columnsHeight.indexOf(Math.min(...this.columnsHeight));
          this.columnsHeight[minIndex] += el.cachedHeight;
          this.columnContainers[minIndex].appendChild(el.element);
          el.element.style.visibility = "visible";
        });
      }
      /**
       * 在原有子项的基础上追加子项
       * @param newItems 要添加的新元素，接受 CSS选择器
       * @param interval 插入每个元素间的时间间隔
       */
      append(newItems, interval) {
        const appended = (() => {
          if (newItems) {
            if (typeof newItems === "string") {
              const _items = document.querySelectorAll(newItems);
              return Array.from(_items);
            } else {
              return newItems;
            }
          } else {
            if (this.itemsSelector) {
              const _items = Array.from(document.querySelectorAll(this.itemsSelector));
              const appendCount = _items.length - this.items.length;
              if (appendCount > 0) {
                const _appended = _items.slice(-appendCount);
                return _appended;
              }
            }
          }
        })();
        if (appended) {
          if (!interval || interval <= 0) {
            appended.forEach((el) => {
              this.appendElement(el);
            });
          } else {
            appended.forEach((el, index2) => {
              setTimeout(() => {
                this.appendElement(el);
              }, interval * index2);
            });
          }
        }
      }
      refreshContainer() {
        if (this.containerSelector) {
          const newContainer = document.querySelector(this.containerSelector);
          if (newContainer) {
            this.container = newContainer;
          }
        }
      }
    }
    function parseOptions(options) {
      options.gap = options.gap || 0;
      options.autoExec = options.autoExec === void 0 ? true : options.autoExec;
      options.fixScrollOffset = options.fixScrollOffset === void 0 ? false : options.fixScrollOffset;
      return options;
    }
    function createNewElement(tag, attrs) {
      const el = document.createElement(tag);
      for (const key in attrs) {
        el.setAttribute(key, attrs[key]);
      }
      return el;
    }
    const _sfc_main$L = /* @__PURE__ */ defineComponent({
      __name: "header-progress",
      props: {
        calc: { type: Function }
      },
      setup(__props) {
        const props = __props;
        const headerProgress2 = ref();
        const valueRef = ref(0);
        onMounted(function() {
          if (headerProgress2.value) {
            requestAnimationFrame(function() {
              calcValue();
            });
          }
        });
        function calcValue() {
          valueRef.value = props.calc();
          console.log(valueRef.value);
          if (valueRef.value < 100)
            requestAnimationFrame(calcValue);
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "headerProgress",
            ref: headerProgress2,
            id: "header-progress",
            style: normalizeStyle(`width: ${valueRef.value}vw;`)
          }, null, 4);
        };
      }
    });
    const HeaderProgress = /* @__PURE__ */ _export_sfc$1(_sfc_main$L, [["__scopeId", "data-v-da001943"]]);
    function renderJSX(jsxel, parent) {
      const vnode = createVNode(jsxel);
      vnode.props && (vnode.props.once = true);
      render(vnode, parent);
      return {
        el: parent.firstChild,
        vnode
      };
    }
    function insertJSX(jsxel, parent, position) {
      const tempContainer = templateCreate("div");
      const vnode = renderJSX(jsxel, parent.appendChild(tempContainer));
      forEach(tempContainer.children, (el) => {
        parent.insertBefore(el, position);
      });
      tempContainer.remove();
      return vnode;
    }
    function appendJSX(jsxel, parent) {
      const tempContainer = templateCreate("div");
      const vnode = renderJSX(jsxel, parent.appendChild(tempContainer));
      forEach(tempContainer.children, (el) => {
        parent.appendChild(el);
      });
      tempContainer.remove();
      return vnode;
    }
    function headerProgress(props, delay = 2e3, timeout = 1e4) {
      const progressBar = createVNode(HeaderProgress, {
        "calc": props.calc
      }, null);
      const rendered = insertJSX(progressBar, document.body, document.body.firstChild);
      const timeoutTimer = setTimeout(() => {
        rendered.el.remove();
      }, timeout);
      waitUtil(() => rendered.el.style.width === "100vw", timeout).then(function() {
        setTimeout(() => {
          rendered.el.remove();
          clearTimeout(timeoutTimer);
        }, delay);
      });
      return rendered;
    }
    function bindFloatMessage(target, message, delay = 500) {
      if (DOMS(".float-message").length <= 0) {
        appendJSX(createVNode("div", {
          "class": "float-message"
        }, [createVNode("div", {
          "class": "float-content"
        }, [message])]), document.body);
      }
      const floatMessage = DOMS(".float-message", "div")[0];
      let timeout = -1;
      target.addEventListener("mouseenter", function() {
        if (timeout >= 0)
          clearTimeout(timeout);
      });
      target.addEventListener("mouseleave", function() {
        if (timeout >= 0)
          clearTimeout(timeout);
        floatMessage.style.display = "none";
      });
      target.addEventListener("mousemove", function(e) {
        if (timeout >= 0)
          clearTimeout(timeout);
        timeout = setTimeout(() => {
          const x = e.clientX + 10;
          const y = e.clientY + 10;
          floatMessage.style.left = `${x}px`;
          floatMessage.style.top = `${y}px`;
          floatMessage.style.display = "block";
        }, delay);
      });
    }
    const _withScopeId$8 = (n) => (pushScopeId("data-v-e6108e1e"), n = n(), popScopeId(), n);
    const _hoisted_1$o = { class: "image-container dialog-toggle" };
    const _hoisted_2$k = ["src"];
    const _hoisted_3$d = { class: "control-panel head-controls" };
    const _hoisted_4$b = { class: "zoom-size" };
    const _hoisted_5$a = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("span", null, "|", -1));
    const _hoisted_6$8 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("span", null, "|", -1));
    const _hoisted_7$6 = { class: "control-panel bottom-controls" };
    const _hoisted_8$6 = ["src", "onClick"];
    const minSize = 0.2;
    const maxSize = 4;
    const _sfc_main$K = /* @__PURE__ */ defineComponent({
      __name: "images-viewer",
      props: {
        content: {},
        defaultIndex: { default: 0 }
      },
      emits: ["RequestClose"],
      setup(__props, { emit: __emit }) {
        const props = __props;
        const imageArray = [];
        if (typeof props.content === "string") {
          imageArray.push(props.content);
        } else if (Array.isArray(props.content)) {
          imageArray.push(...props.content);
        } else {
          map(props.content.images, (value) => {
            imageArray.push(value.original);
          });
        }
        const emit2 = __emit;
        const imageViewer = ref();
        const currImage = ref();
        const curr = ref(props.defaultIndex);
        const scale = ref(1);
        const deg = ref(0);
        onMounted(() => {
          var _a2;
          let offsetX = 0, offsetY = 0;
          (_a2 = currImage.value) == null ? void 0 : _a2.addEventListener("mousedown", (e) => {
            if (!currImage.value)
              return;
            e.preventDefault();
            offsetX = e.clientX - currImage.value.offsetLeft;
            offsetY = e.clientY - currImage.value.offsetTop;
            document.addEventListener("mousemove", moveHandler);
          });
          document.addEventListener("mouseup", (e) => {
            e.preventDefault();
            document.removeEventListener("mousemove", moveHandler);
          });
          function moveHandler(e) {
            if (!currImage.value)
              return;
            currImage.value.style.left = `${e.clientX - offsetX}px`;
            currImage.value.style.top = `${e.clientY - offsetY}px`;
          }
        });
        function unload() {
          emit2("RequestClose");
          unloadDialog();
        }
        function changeCurr(newIndex) {
          curr.value = newIndex;
          transformDefault();
        }
        function listBack() {
          if (curr.value > 0)
            changeCurr(--curr.value);
        }
        function listForward() {
          if (curr.value < imageArray.length - 1)
            changeCurr(++curr.value);
        }
        function transformImage() {
          if (currImage.value) {
            currImage.value.style.transform = `scale(${scale.value}) rotate(${deg.value}deg)`;
          }
        }
        function transformDefault() {
          scale.value = 1;
          deg.value = 0;
          transformImage();
        }
        function zoomImage(delta) {
          scale.value += delta;
          scale.value < minSize ? scale.value = minSize : scale.value > maxSize ? scale.value = maxSize : true;
          transformImage();
        }
        function rotateImage(delta) {
          deg.value += delta;
          deg.value % 360 ? true : deg.value = 0;
          transformImage();
        }
        function imageWheel(event) {
          event.preventDefault();
          zoomImage(-event.deltaY / 1e3);
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "imageViewer",
            ref: imageViewer,
            class: "images-viewer dialog-toggle",
            onWheel: imageWheel
          }, [
            createBaseVNode("div", _hoisted_1$o, [
              createBaseVNode("img", {
                ref_key: "currImage",
                ref: currImage,
                class: "curr-image",
                src: imageArray[curr.value],
                alt: ""
              }, null, 8, _hoisted_2$k)
            ]),
            createBaseVNode("div", _hoisted_3$d, [
              createVNode(_sfc_main$Q, {
                class: "zoom-in head-btn icon",
                title: "缩小",
                onClick: _cache[0] || (_cache[0] = ($event) => zoomImage(0.5))
              }, {
                default: withCtx(() => [
                  createTextVNode(" zoom_in ")
                ]),
                _: 1
              }),
              createVNode(_sfc_main$Q, {
                class: "zoom-out head-btn icon",
                title: "放大",
                onClick: _cache[1] || (_cache[1] = ($event) => zoomImage(-0.5))
              }, {
                default: withCtx(() => [
                  createTextVNode(" zoom_out ")
                ]),
                _: 1
              }),
              createBaseVNode("span", _hoisted_4$b, toDisplayString(unref(round)(scale.value * 100) + "%"), 1),
              _hoisted_5$a,
              createVNode(_sfc_main$Q, {
                class: "turn-left head-btn icon",
                title: "逆时针旋转",
                onClick: _cache[2] || (_cache[2] = ($event) => rotateImage(-90))
              }, {
                default: withCtx(() => [
                  createTextVNode(" undo ")
                ]),
                _: 1
              }),
              createVNode(_sfc_main$Q, {
                class: "turn-right head-btn icon",
                title: "顺时针旋转",
                onClick: _cache[3] || (_cache[3] = ($event) => rotateImage(90))
              }, {
                default: withCtx(() => [
                  createTextVNode(" redo ")
                ]),
                _: 1
              }),
              _hoisted_6$8,
              createVNode(_sfc_main$Q, {
                class: "close head-btn icon",
                title: "关闭",
                onClick: unload
              }, {
                default: withCtx(() => [
                  createTextVNode(" close ")
                ]),
                _: 1
              })
            ]),
            imageArray.length > 1 ? (openBlock(), createBlock(_sfc_main$Q, {
              key: 0,
              class: "control-panel back icon",
              title: "上一张",
              onClick: listBack
            }, {
              default: withCtx(() => [
                createTextVNode(" chevron_left ")
              ]),
              _: 1
            })) : createCommentVNode("", true),
            imageArray.length > 1 ? (openBlock(), createBlock(_sfc_main$Q, {
              key: 1,
              class: "control-panel forward icon",
              title: "下一张",
              onClick: listForward
            }, {
              default: withCtx(() => [
                createTextVNode(" chevron_right ")
              ]),
              _: 1
            })) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_7$6, [
              (openBlock(), createElementBlock(Fragment, null, renderList(imageArray, (image, index2) => {
                return createVNode(_sfc_main$Q, {
                  class: normalizeClass(["bottom-btn", { "selected": index2 === curr.value }])
                }, {
                  default: withCtx(() => [
                    createBaseVNode("img", {
                      class: "image-list",
                      src: image,
                      alt: "",
                      onClick: ($event) => changeCurr(index2)
                    }, null, 8, _hoisted_8$6)
                  ]),
                  _: 2
                }, 1032, ["class"]);
              }), 64))
            ])
          ], 544);
        };
      }
    });
    const imagesViewerVue = /* @__PURE__ */ _export_sfc$1(_sfc_main$K, [["__scopeId", "data-v-e6108e1e"]]);
    const _hoisted_1$n = { class: "main-content" };
    const _hoisted_2$j = { class: "title" };
    const _hoisted_3$c = {
      key: 0,
      class: "content"
    };
    const _hoisted_4$a = {
      key: 0,
      class: "img-container"
    };
    const _hoisted_5$9 = ["src"];
    const _hoisted_6$7 = { class: "bottom-controls" };
    const _hoisted_7$5 = ["src"];
    const _hoisted_8$5 = { class: "author-info" };
    const _hoisted_9$5 = { class: "author-name" };
    const _hoisted_10$5 = { class: "post-time" };
    const _hoisted_11$4 = { class: "replies" };
    const _sfc_main$J = /* @__PURE__ */ defineComponent({
      __name: "post-container",
      props: {
        post: {},
        lazyLoad: { type: Boolean, default: false },
        dynamic: { type: Boolean, default: false }
      },
      emits: ["ClickImage", "AssetsLoaded"],
      setup(__props, { emit: __emit }) {
        const props = __props;
        const emit2 = __emit;
        const postContainer = ref();
        const isIntersecting = ref(!props.lazyLoad);
        const loadedAssets = ref(0);
        onMounted(() => {
          if (!postContainer.value)
            return;
          if (props.post.images.length === 0) {
            emit2("AssetsLoaded", postContainer.value);
          }
          if (!props.lazyLoad)
            return;
          const iObs = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                isIntersecting.value = true;
                iObs.disconnect();
              }
            });
          });
          iObs.observe(postContainer.value.$el);
        });
        function showImage(e, index2) {
          e.preventDefault();
          emit2("ClickImage", (() => {
            const output = [];
            map(props.post.images, (value) => {
              output.push(value.original);
            });
            return output;
          })(), index2);
        }
        function addLoadedPost() {
          loadedAssets.value += 1;
          if (loadedAssets.value === props.post.images.length) {
            emit2("AssetsLoaded", postContainer.value);
          }
        }
        return (_ctx, _cache) => {
          return openBlock(), createBlock(_sfc_main$Q, {
            ref_key: "postContainer",
            ref: postContainer,
            "is-anchor": true,
            class: normalizeClass(["post-container", { "dynamic": props.dynamic, "assets-loaded": loadedAssets.value === props.post.images.length }]),
            href: "/p/" + props.post.id,
            target: "_blank"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", null, [
                createVNode(_sfc_main$Q, {
                  "is-anchor": true,
                  class: "forum-btn",
                  "shadow-border": true,
                  href: props.post.forum.href,
                  target: "_blank"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(props.post.forum.name + " 吧"), 1)
                  ]),
                  _: 1
                }, 8, ["href"])
              ]),
              createBaseVNode("div", _hoisted_1$n, [
                createBaseVNode("p", _hoisted_2$j, toDisplayString(props.post.title), 1),
                props.post.content && props.post.content !== " " ? (openBlock(), createElementBlock("p", _hoisted_3$c, toDisplayString(props.post.content), 1)) : createCommentVNode("", true)
              ]),
              props.post.images.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_4$a, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(props.post.images, (image, index2) => {
                  return openBlock(), createBlock(_sfc_main$Q, {
                    class: "img-button",
                    onClick: ($event) => showImage($event, index2)
                  }, {
                    default: withCtx(() => [
                      createBaseVNode("img", {
                        class: "post-img",
                        src: isIntersecting.value ? image.original : "",
                        onLoad: addLoadedPost
                      }, null, 40, _hoisted_5$9)
                    ]),
                    _: 2
                  }, 1032, ["onClick"]);
                }), 256))
              ])) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_6$7, [
                createVNode(_sfc_main$Q, {
                  class: "author",
                  "is-anchor": true,
                  href: props.post.author.href,
                  target: "_blank",
                  "shadow-border": true
                }, {
                  default: withCtx(() => [
                    createBaseVNode("img", {
                      class: "author-portrait",
                      src: isIntersecting.value ? unref(tiebaAPI).URL_profile(props.post.author.portrait) : ""
                    }, null, 8, _hoisted_7$5),
                    createBaseVNode("div", _hoisted_8$5, [
                      createBaseVNode("div", _hoisted_9$5, toDisplayString(props.post.author.name), 1),
                      createBaseVNode("div", _hoisted_10$5, toDisplayString(props.post.time), 1)
                    ])
                  ]),
                  _: 1
                }, 8, ["href"]),
                createBaseVNode("div", _hoisted_11$4, toDisplayString(props.post.replies), 1)
              ])
            ]),
            _: 1
          }, 8, ["href", "class"]);
        };
      }
    });
    const PostContainer = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["__scopeId", "data-v-6189916b"]]);
    const maxFeeds = 1e3;
    const nextFeedsMargin = 320;
    const unreadTTL = 2;
    const _sfc_main$I = /* @__PURE__ */ defineComponent({
      __name: "feeds-masonry",
      props: {
        initFeeds: { default: Array },
        showProgress: { type: Boolean, default: false }
      },
      setup(__props) {
        const props = __props;
        const feeds = ref([]);
        const masonryWrapper = ref();
        const masonryContainer = ref();
        const hasMoreFeeds = ref(true);
        let currentLoadedFeeds = [];
        let isFetchingFeeds = false;
        const debAddFeeds = debounce(addFeeds, 1e3, { leading: true });
        let flexMasonry;
        window.addEventListener("resize", throttle(function() {
          if (flexMasonry.columns !== flexMasonry.calcColumns())
            flexMasonry.exec();
        }, 100), { passive: true });
        onMounted(() => {
          if (!masonryWrapper.value)
            return;
          if (!masonryContainer.value)
            return;
          debAddFeeds(props.initFeeds);
          renderMasonry();
          window.addEventListener("scroll", () => {
            if (isFetchingFeeds)
              return;
            const scrollHeight = document.documentElement.scrollHeight;
            const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
            const clientHeight = document.documentElement.clientHeight;
            if (scrollTop + clientHeight >= scrollHeight - nextFeedsMargin) {
              if (feeds.value.length < maxFeeds) {
                debAddFeeds();
              }
            }
          });
        });
        watch(hasMoreFeeds, (newVal) => {
          if (!newVal) {
            toast({
              message: "没有更多推送了",
              type: "warning"
            });
          }
        });
        async function addFeeds(newFeeds) {
          if (!newFeeds)
            newFeeds = [];
          if (isFetchingFeeds)
            return;
          isFetchingFeeds = true;
          if (newFeeds.length <= 0) {
            const response = await requestInstance(tiebaAPI.feedlist());
            if (response) {
              newFeeds = parsePostsFromString(response.data.html);
              hasMoreFeeds.value = Boolean(response.data.has_more);
              if (props.showProgress) {
                headerProgress({ calc: () => currentLoadedFeeds.length / response.data.total * 100 });
              }
            }
          }
          feeds.value.push(...newFeeds);
          const interval = setInterval(() => {
            if (!newFeeds)
              return;
            if (currentLoadedFeeds.length >= newFeeds.length) {
              renderMasonry().then(function() {
                unreadFeeds.set(newFeeds ? newFeeds : [], spawnOffsetTS(0, 0, 0, unreadTTL));
                currentLoadedFeeds.length = 0;
                clearInterval(interval);
                isFetchingFeeds = false;
              });
            }
          }, 10);
        }
        async function renderMasonry() {
          await nextTick(() => {
            if (!masonryContainer.value)
              return;
            if (!flexMasonry) {
              flexMasonry = new FlexMasonry({
                container: masonryContainer.value,
                // items: ".post-elem.assets-loaded",
                columnWidth: 320,
                gap: 12,
                fixScrollOffset: true
              });
            } else {
              flexMasonry.append(".masonry-wrapper > .post-elem.assets-loaded", 60);
            }
          });
        }
        function addToLoaded(payload) {
          currentLoadedFeeds.push(payload.$el);
        }
        function showImages(images, index2) {
          renderDialog(imagesViewerVue, {
            content: images,
            defaultIndex: index2
          });
        }
        function refresh() {
          if (!isFetchingFeeds) {
            feeds.value.length = 0;
            flexMasonry.clear();
            debAddFeeds();
          }
        }
        function refreshAndMove() {
          var _a2;
          window.scrollTo({ top: (_a2 = masonryContainer.value) == null ? void 0 : _a2.offsetTop, behavior: "smooth" });
          refresh();
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "masonryWrapper",
            ref: masonryWrapper,
            class: "masonry-wrapper"
          }, [
            feeds.value.length > 0 || unref(isFetchingFeeds) ? (openBlock(), createBlock(BlockPanel, { key: 0 }, {
              default: withCtx(() => [
                createVNode(_sfc_main$Q, {
                  class: "panel-button icon refresh",
                  "unset-background": "",
                  onClick: refreshAndMove,
                  "no-border": ""
                }, {
                  default: withCtx(() => [
                    createTextVNode("refresh ")
                  ]),
                  _: 1
                }),
                createVNode(_sfc_main$Q, {
                  class: "panel-button icon settings",
                  "unset-background": "",
                  "no-border": ""
                }, {
                  default: withCtx(() => [
                    createTextVNode("settings")
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })) : createCommentVNode("", true),
            createBaseVNode("div", {
              ref_key: "masonryContainer",
              ref: masonryContainer,
              class: "masonry-container"
            }, null, 512),
            (openBlock(true), createElementBlock(Fragment, null, renderList(feeds.value, (post) => {
              return openBlock(), createBlock(PostContainer, {
                key: post.id,
                post,
                class: "post-elem",
                dynamic: "",
                "shadow-border": "",
                onClickImage: showImages,
                onAssetsLoaded: addToLoaded
              }, null, 8, ["post"]);
            }), 128))
          ], 512);
        };
      }
    });
    const FeedsMasonry = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["__scopeId", "data-v-0edff44b"]]);
    function _getDefaults() {
      return {
        async: false,
        breaks: false,
        extensions: null,
        gfm: true,
        hooks: null,
        pedantic: false,
        renderer: null,
        silent: false,
        tokenizer: null,
        walkTokens: null
      };
    }
    let _defaults = _getDefaults();
    function changeDefaults(newDefaults) {
      _defaults = newDefaults;
    }
    const escapeTest = /[&<>"']/;
    const escapeReplace = new RegExp(escapeTest.source, "g");
    const escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
    const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
    const escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    const getEscapeReplacement = (ch) => escapeReplacements[ch];
    function escape(html, encode) {
      if (encode) {
        if (escapeTest.test(html)) {
          return html.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html)) {
          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html;
    }
    const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape(html) {
      return html.replace(unescapeTest, (_, n) => {
        n = n.toLowerCase();
        if (n === "colon")
          return ":";
        if (n.charAt(0) === "#") {
          return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
        }
        return "";
      });
    }
    const caret = /(^|[^\[])\^/g;
    function edit(regex, opt) {
      regex = typeof regex === "string" ? regex : regex.source;
      opt = opt || "";
      const obj = {
        replace: (name, val) => {
          val = typeof val === "object" && "source" in val ? val.source : val;
          val = val.replace(caret, "$1");
          regex = regex.replace(name, val);
          return obj;
        },
        getRegex: () => {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }
    function cleanUrl(href) {
      try {
        href = encodeURI(href).replace(/%25/g, "%");
      } catch (e) {
        return null;
      }
      return href;
    }
    const noopTest = { exec: () => null };
    function splitCells(tableRow, count) {
      const row = tableRow.replace(/\|/g, (match, offset, str) => {
        let escaped = false;
        let curr = offset;
        while (--curr >= 0 && str[curr] === "\\")
          escaped = !escaped;
        if (escaped) {
          return "|";
        } else {
          return " |";
        }
      }), cells = row.split(/ \|/);
      let i = 0;
      if (!cells[0].trim()) {
        cells.shift();
      }
      if (cells.length > 0 && !cells[cells.length - 1].trim()) {
        cells.pop();
      }
      if (count) {
        if (cells.length > count) {
          cells.splice(count);
        } else {
          while (cells.length < count)
            cells.push("");
        }
      }
      for (; i < cells.length; i++) {
        cells[i] = cells[i].trim().replace(/\\\|/g, "|");
      }
      return cells;
    }
    function rtrim(str, c, invert) {
      const l = str.length;
      if (l === 0) {
        return "";
      }
      let suffLen = 0;
      while (suffLen < l) {
        const currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }
      return str.slice(0, l - suffLen);
    }
    function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      let level = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === "\\") {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }
    function outputLink(cap, link, raw, lexer) {
      const href = link.href;
      const title = link.title ? escape(link.title) : null;
      const text = cap[1].replace(/\\([\[\]])/g, "$1");
      if (cap[0].charAt(0) !== "!") {
        lexer.state.inLink = true;
        const token = {
          type: "link",
          raw,
          href,
          title,
          text,
          tokens: lexer.inlineTokens(text)
        };
        lexer.state.inLink = false;
        return token;
      }
      return {
        type: "image",
        raw,
        href,
        title,
        text: escape(text)
      };
    }
    function indentCodeCompensation(raw, text) {
      const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
        return text;
      }
      const indentToCode = matchIndentToCode[1];
      return text.split("\n").map((node) => {
        const matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
          return node;
        }
        const [indentInNode] = matchIndentInNode;
        if (indentInNode.length >= indentToCode.length) {
          return node.slice(indentToCode.length);
        }
        return node;
      }).join("\n");
    }
    class _Tokenizer {
      constructor(options) {
        __publicField(this, "options");
        // TODO: Fix this rules type
        __publicField(this, "rules");
        __publicField(this, "lexer");
        this.options = options || _defaults;
      }
      space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: "space",
            raw: cap[0]
          };
        }
      }
      code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text, "\n") : text
          };
        }
      }
      fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
          const raw = cap[0];
          const text = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
            text
          };
        }
      }
      heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
          let text = cap[2].trim();
          if (/#$/.test(text)) {
            const trimmed = rtrim(text, "#");
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text = trimmed.trim();
            }
          }
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text,
            tokens: this.lexer.inline(text)
          };
        }
      }
      hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      }
      blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          const text = rtrim(cap[0].replace(/^ *>[ \t]?/gm, ""), "\n");
          const top = this.lexer.state.top;
          this.lexer.state.top = true;
          const tokens = this.lexer.blockTokens(text);
          this.lexer.state.top = top;
          return {
            type: "blockquote",
            raw: cap[0],
            tokens,
            text
          };
        }
      }
      list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
          let bull = cap[1].trim();
          const isordered = bull.length > 1;
          const list = {
            type: "list",
            raw: "",
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
          if (this.options.pedantic) {
            bull = isordered ? bull : "[*+-]";
          }
          const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
          let raw = "";
          let itemContents = "";
          let endsWithBlankLine = false;
          while (src) {
            let endEarly = false;
            if (!(cap = itemRegex.exec(src))) {
              break;
            }
            if (this.rules.block.hr.test(src)) {
              break;
            }
            raw = cap[0];
            src = src.substring(raw.length);
            let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
            let nextLine = src.split("\n", 1)[0];
            let indent = 0;
            if (this.options.pedantic) {
              indent = 2;
              itemContents = line.trimStart();
            } else {
              indent = cap[2].search(/[^ ]/);
              indent = indent > 4 ? 1 : indent;
              itemContents = line.slice(indent);
              indent += cap[1].length;
            }
            let blankLine = false;
            if (!line && /^ *$/.test(nextLine)) {
              raw += nextLine + "\n";
              src = src.substring(nextLine.length + 1);
              endEarly = true;
            }
            if (!endEarly) {
              const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
              const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
              const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
              const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
              while (src) {
                const rawLine = src.split("\n", 1)[0];
                nextLine = rawLine;
                if (this.options.pedantic) {
                  nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                }
                if (fencesBeginRegex.test(nextLine)) {
                  break;
                }
                if (headingBeginRegex.test(nextLine)) {
                  break;
                }
                if (nextBulletRegex.test(nextLine)) {
                  break;
                }
                if (hrRegex.test(src)) {
                  break;
                }
                if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
                  itemContents += "\n" + nextLine.slice(indent);
                } else {
                  if (blankLine) {
                    break;
                  }
                  if (line.search(/[^ ]/) >= 4) {
                    break;
                  }
                  if (fencesBeginRegex.test(line)) {
                    break;
                  }
                  if (headingBeginRegex.test(line)) {
                    break;
                  }
                  if (hrRegex.test(line)) {
                    break;
                  }
                  itemContents += "\n" + nextLine;
                }
                if (!blankLine && !nextLine.trim()) {
                  blankLine = true;
                }
                raw += rawLine + "\n";
                src = src.substring(rawLine.length + 1);
                line = nextLine.slice(indent);
              }
            }
            if (!list.loose) {
              if (endsWithBlankLine) {
                list.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }
            let istask = null;
            let ischecked;
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== "[ ] ";
                itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
              }
            }
            list.items.push({
              type: "list_item",
              raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents,
              tokens: []
            });
            list.raw += raw;
          }
          list.items[list.items.length - 1].raw = raw.trimEnd();
          list.items[list.items.length - 1].text = itemContents.trimEnd();
          list.raw = list.raw.trimEnd();
          for (let i = 0; i < list.items.length; i++) {
            this.lexer.state.top = false;
            list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
            if (!list.loose) {
              const spacers = list.items[i].tokens.filter((t) => t.type === "space");
              const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
              list.loose = hasMultipleLineBreaks;
            }
          }
          if (list.loose) {
            for (let i = 0; i < list.items.length; i++) {
              list.items[i].loose = true;
            }
          }
          return list;
        }
      }
      html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
          const token = {
            type: "html",
            block: true,
            raw: cap[0],
            pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
            text: cap[0]
          };
          return token;
        }
      }
      def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
          const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
          const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
          return {
            type: "def",
            tag,
            raw: cap[0],
            href,
            title
          };
        }
      }
      table(src) {
        const cap = this.rules.block.table.exec(src);
        if (cap) {
          if (!/[:|]/.test(cap[2])) {
            return;
          }
          const item = {
            type: "table",
            raw: cap[0],
            header: splitCells(cap[1]).map((c) => {
              return { text: c, tokens: [] };
            }),
            align: cap[2].replace(/^\||\| *$/g, "").split("|"),
            rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            let l = item.align.length;
            let i, j, k, row;
            for (i = 0; i < l; i++) {
              const align = item.align[i];
              if (align) {
                if (/^ *-+: *$/.test(align)) {
                  item.align[i] = "right";
                } else if (/^ *:-+: *$/.test(align)) {
                  item.align[i] = "center";
                } else if (/^ *:-+ *$/.test(align)) {
                  item.align[i] = "left";
                } else {
                  item.align[i] = null;
                }
              }
            }
            l = item.rows.length;
            for (i = 0; i < l; i++) {
              item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
                return { text: c, tokens: [] };
              });
            }
            l = item.header.length;
            for (j = 0; j < l; j++) {
              item.header[j].tokens = this.lexer.inline(item.header[j].text);
            }
            l = item.rows.length;
            for (j = 0; j < l; j++) {
              row = item.rows[j];
              for (k = 0; k < row.length; k++) {
                row[k].tokens = this.lexer.inline(row[k].text);
              }
            }
            return item;
          }
        }
      }
      lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1],
            tokens: this.lexer.inline(cap[1])
          };
        }
      }
      paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
          return {
            type: "paragraph",
            raw: cap[0],
            text,
            tokens: this.lexer.inline(text)
          };
        }
      }
      text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
          return {
            type: "text",
            raw: cap[0],
            text: cap[0],
            tokens: this.lexer.inline(cap[0])
          };
        }
      }
      escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: escape(cap[1])
          };
        }
      }
      tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }
          return {
            type: "html",
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            block: false,
            text: cap[0]
          };
        }
      }
      link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
          const trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            const lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              const start = cap[0].indexOf("!") === 0 ? 5 : 4;
              const linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          let href = cap[2];
          let title = "";
          if (this.options.pedantic) {
            const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link) {
              href = link[1];
              title = link[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0], this.lexer);
        }
      }
      reflink(src, links) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link = links[link.toLowerCase()];
          if (!link) {
            const text = cap[0].charAt(0);
            return {
              type: "text",
              raw: text,
              text
            };
          }
          return outputLink(cap, link, cap[0], this.lexer);
        }
      }
      emStrong(src, maskedSrc, prevChar = "") {
        let match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match)
          return;
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
          return;
        const nextChar = match[1] || match[2] || "";
        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
          const lLength = [...match[0]].length - 1;
          let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
            if (!rDelim)
              continue;
            rLength = [...rDelim].length;
            if (match[3] || match[4]) {
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0)
              continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            const lastCharLength = [...match[0]][0].length;
            const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
            if (Math.min(lLength, rLength) % 2) {
              const text2 = raw.slice(1, -1);
              return {
                type: "em",
                raw,
                text: text2,
                tokens: this.lexer.inlineTokens(text2)
              };
            }
            const text = raw.slice(2, -2);
            return {
              type: "strong",
              raw,
              text,
              tokens: this.lexer.inlineTokens(text)
            };
          }
        }
      }
      codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
          let text = cap[2].replace(/\n/g, " ");
          const hasNonSpaceChars = /[^ ]/.test(text);
          const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = escape(text, true);
          return {
            type: "codespan",
            raw: cap[0],
            text
          };
        }
      }
      br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      }
      del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2])
          };
        }
      }
      autolink(src) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          let text, href;
          if (cap[2] === "@") {
            text = escape(cap[1]);
            href = "mailto:" + text;
          } else {
            text = escape(cap[1]);
            href = text;
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      url(src) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
          let text, href;
          if (cap[2] === "@") {
            text = escape(cap[0]);
            href = "mailto:" + text;
          } else {
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + cap[0];
            } else {
              href = cap[0];
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      inlineText(src) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
          let text;
          if (this.lexer.state.inRawBlock) {
            text = cap[0];
          } else {
            text = escape(cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text
          };
        }
      }
    }
    const block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: noopTest,
      lheading: /^(?!bull )((?:.|\n(?!\s*?\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be replaced according to different paragraph
      // interruption rules of commonmark and the original markdown spec:
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
    block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
    block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.lheading = edit(block.lheading).replace(/bull/g, block.bullet).getRegex();
    block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
    block.normal = { ...block };
    block.gfm = {
      ...block.normal,
      table: "^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
      // Cells
    };
    block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.pedantic = {
      ...block.normal,
      html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    };
    const inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,
        //         (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
        //         | Skip orphan inside strong      | Consume to delim | (1) #***              | (2) a***#, a***                    | (3) #***a, ***a                  | (4) ***#                 | (5) #***#                         | (6) a***a
        rDelimAst: /^[^_*]*?__[^_*]*?\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\*)[punct](\*+)(?=[\s]|$)|[^punct\s](\*+)(?!\*)(?=[punct\s]|$)|(?!\*)[punct\s](\*+)(?=[^punct\s])|[\s](\*+)(?!\*)(?=[punct])|(?!\*)[punct](\*+)(?!\*)(?=[punct])|[^punct\s](\*+)(?=[^punct\s])/,
        rDelimUnd: /^[^_*]*?\*\*[^_*]*?_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\s]|$)|[^punct\s](_+)(?!_)(?=[punct\s]|$)|(?!_)[punct\s](_+)(?=[^punct\s])|[\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/
        // ^- Not allowed for _
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^((?![*_])[\spunctuation])/
    };
    inline._punctuation = "\\p{P}$+<=>`^|~";
    inline.punctuation = edit(inline.punctuation, "u").replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
    inline.anyPunctuation = /\\[punct]/g;
    inline._escapes = /\\([punct])/g;
    inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
    inline.emStrong.lDelim = edit(inline.emStrong.lDelim, "u").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "gu").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "gu").replace(/punct/g, inline._punctuation).getRegex();
    inline.anyPunctuation = edit(inline.anyPunctuation, "gu").replace(/punct/g, inline._punctuation).getRegex();
    inline._escapes = edit(inline._escapes, "gu").replace(/punct/g, inline._punctuation).getRegex();
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
    inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
    inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
    inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
    inline.normal = { ...inline };
    inline.pedantic = {
      ...inline.normal,
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
    };
    inline.gfm = {
      ...inline.normal,
      escape: edit(inline.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    };
    inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
    inline.breaks = {
      ...inline.gfm,
      br: edit(inline.br).replace("{2,}", "*").getRegex(),
      text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    };
    class _Lexer {
      constructor(options) {
        __publicField(this, "tokens");
        __publicField(this, "options");
        __publicField(this, "state");
        __publicField(this, "tokenizer");
        __publicField(this, "inlineQueue");
        this.tokens = [];
        this.tokens.links = /* @__PURE__ */ Object.create(null);
        this.options = options || _defaults;
        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };
        const rules = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }
      /**
       * Expose Rules
       */
      static get rules() {
        return {
          block,
          inline
        };
      }
      /**
       * Static Lex Method
       */
      static lex(src, options) {
        const lexer = new _Lexer(options);
        return lexer.lex(src);
      }
      /**
       * Static Lex Inline Method
       */
      static lexInline(src, options) {
        const lexer = new _Lexer(options);
        return lexer.inlineTokens(src);
      }
      /**
       * Preprocessing
       */
      lex(src) {
        src = src.replace(/\r\n|\r/g, "\n");
        this.blockTokens(src, this.tokens);
        let next;
        while (next = this.inlineQueue.shift()) {
          this.inlineTokens(next.src, next.tokens);
        }
        return this.tokens;
      }
      blockTokens(src, tokens = []) {
        if (this.options.pedantic) {
          src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
        } else {
          src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
            return leading + "    ".repeat(tabs.length);
          });
        }
        let token;
        let lastToken;
        let cutSrc;
        let lastParagraphClipped;
        while (src) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.raw.length === 1 && tokens.length > 0) {
              tokens[tokens.length - 1].raw += "\n";
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startBlock.forEach((getStartIndex) => {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = cutSrc.length !== src.length;
            src = src.substring(token.raw.length);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        this.state.top = true;
        return tokens;
      }
      inline(src, tokens = []) {
        this.inlineQueue.push({ src, tokens });
        return tokens;
      }
      /**
       * Lexing/Compiling
       */
      inlineTokens(src, tokens = []) {
        let token, lastToken, cutSrc;
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;
        if (this.tokens.links) {
          const links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!this.state.inLink && (token = this.tokenizer.url(src))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startInline.forEach((getStartIndex) => {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (token = this.tokenizer.inlineText(cutSrc)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== "_") {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
    }
    class _Renderer {
      constructor(options) {
        __publicField(this, "options");
        this.options = options || _defaults;
      }
      code(code, infostring, escaped) {
        var _a2;
        const lang = (_a2 = (infostring || "").match(/^\S*/)) == null ? void 0 : _a2[0];
        code = code.replace(/\n$/, "") + "\n";
        if (!lang) {
          return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="language-' + escape(lang) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
      }
      blockquote(quote) {
        return `<blockquote>
${quote}</blockquote>
`;
      }
      html(html, block2) {
        return html;
      }
      heading(text, level, raw) {
        return `<h${level}>${text}</h${level}>
`;
      }
      hr() {
        return "<hr>\n";
      }
      list(body, ordered, start) {
        const type = ordered ? "ol" : "ul";
        const startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
      }
      listitem(text, task, checked) {
        return `<li>${text}</li>
`;
      }
      checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
      }
      paragraph(text) {
        return `<p>${text}</p>
`;
      }
      table(header, body) {
        if (body)
          body = `<tbody>${body}</tbody>`;
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      }
      tablerow(content) {
        return `<tr>
${content}</tr>
`;
      }
      tablecell(content, flags) {
        const type = flags.header ? "th" : "td";
        const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
        return tag + content + `</${type}>
`;
      }
      /**
       * span level renderer
       */
      strong(text) {
        return `<strong>${text}</strong>`;
      }
      em(text) {
        return `<em>${text}</em>`;
      }
      codespan(text) {
        return `<code>${text}</code>`;
      }
      br() {
        return "<br>";
      }
      del(text) {
        return `<del>${text}</del>`;
      }
      link(href, title, text) {
        const cleanHref = cleanUrl(href);
        if (cleanHref === null) {
          return text;
        }
        href = cleanHref;
        let out = '<a href="' + href + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text + "</a>";
        return out;
      }
      image(href, title, text) {
        const cleanHref = cleanUrl(href);
        if (cleanHref === null) {
          return text;
        }
        href = cleanHref;
        let out = `<img src="${href}" alt="${text}"`;
        if (title) {
          out += ` title="${title}"`;
        }
        out += ">";
        return out;
      }
      text(text) {
        return text;
      }
    }
    class _TextRenderer {
      // no need for block level renderers
      strong(text) {
        return text;
      }
      em(text) {
        return text;
      }
      codespan(text) {
        return text;
      }
      del(text) {
        return text;
      }
      html(text) {
        return text;
      }
      text(text) {
        return text;
      }
      link(href, title, text) {
        return "" + text;
      }
      image(href, title, text) {
        return "" + text;
      }
      br() {
        return "";
      }
    }
    class _Parser {
      constructor(options) {
        __publicField(this, "options");
        __publicField(this, "renderer");
        __publicField(this, "textRenderer");
        this.options = options || _defaults;
        this.options.renderer = this.options.renderer || new _Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new _TextRenderer();
      }
      /**
       * Static Parse Method
       */
      static parse(tokens, options) {
        const parser = new _Parser(options);
        return parser.parse(tokens);
      }
      /**
       * Static Parse Inline Method
       */
      static parseInline(tokens, options) {
        const parser = new _Parser(options);
        return parser.parseInline(tokens);
      }
      /**
       * Parse Loop
       */
      parse(tokens, top = true) {
        let out = "";
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            const genericToken = token;
            const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
            if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              const headingToken = token;
              out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));
              continue;
            }
            case "code": {
              const codeToken = token;
              out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
              continue;
            }
            case "table": {
              const tableToken = token;
              let header = "";
              let cell = "";
              for (let j = 0; j < tableToken.header.length; j++) {
                cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });
              }
              header += this.renderer.tablerow(cell);
              let body = "";
              for (let j = 0; j < tableToken.rows.length; j++) {
                const row = tableToken.rows[j];
                cell = "";
                for (let k = 0; k < row.length; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              const blockquoteToken = token;
              const body = this.parse(blockquoteToken.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              const listToken = token;
              const ordered = listToken.ordered;
              const start = listToken.start;
              const loose = listToken.loose;
              let body = "";
              for (let j = 0; j < listToken.items.length; j++) {
                const item = listToken.items[j];
                const checked = item.checked;
                const task = item.task;
                let itemBody = "";
                if (item.task) {
                  const checkbox = this.renderer.checkbox(!!checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox + " "
                      });
                    }
                  } else {
                    itemBody += checkbox + " ";
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, !!checked);
              }
              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case "html": {
              const htmlToken = token;
              out += this.renderer.html(htmlToken.text, htmlToken.block);
              continue;
            }
            case "paragraph": {
              const paragraphToken = token;
              out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
              continue;
            }
            case "text": {
              let textToken = token;
              let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
              while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
                textToken = tokens[++i];
                body += "\n" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return "";
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
      /**
       * Parse Inline Tokens
       */
      parseInline(tokens, renderer2) {
        renderer2 = renderer2 || this.renderer;
        let out = "";
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "escape": {
              const escapeToken = token;
              out += renderer2.text(escapeToken.text);
              break;
            }
            case "html": {
              const tagToken = token;
              out += renderer2.html(tagToken.text);
              break;
            }
            case "link": {
              const linkToken = token;
              out += renderer2.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer2));
              break;
            }
            case "image": {
              const imageToken = token;
              out += renderer2.image(imageToken.href, imageToken.title, imageToken.text);
              break;
            }
            case "strong": {
              const strongToken = token;
              out += renderer2.strong(this.parseInline(strongToken.tokens, renderer2));
              break;
            }
            case "em": {
              const emToken = token;
              out += renderer2.em(this.parseInline(emToken.tokens, renderer2));
              break;
            }
            case "codespan": {
              const codespanToken = token;
              out += renderer2.codespan(codespanToken.text);
              break;
            }
            case "br": {
              out += renderer2.br();
              break;
            }
            case "del": {
              const delToken = token;
              out += renderer2.del(this.parseInline(delToken.tokens, renderer2));
              break;
            }
            case "text": {
              const textToken = token;
              out += renderer2.text(textToken.text);
              break;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return "";
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
    }
    class _Hooks {
      constructor(options) {
        __publicField(this, "options");
        this.options = options || _defaults;
      }
      /**
       * Process markdown before marked
       */
      preprocess(markdown) {
        return markdown;
      }
      /**
       * Process HTML after marked is finished
       */
      postprocess(html) {
        return html;
      }
    }
    __publicField(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
      "preprocess",
      "postprocess"
    ]));
    class Marked {
      constructor(...args) {
        __privateAdd(this, _parseMarkdown);
        __privateAdd(this, _onError);
        __publicField(this, "defaults", _getDefaults());
        __publicField(this, "options", this.setOptions);
        __publicField(this, "parse", __privateMethod(this, _parseMarkdown, parseMarkdown_fn).call(this, _Lexer.lex, _Parser.parse));
        __publicField(this, "parseInline", __privateMethod(this, _parseMarkdown, parseMarkdown_fn).call(this, _Lexer.lexInline, _Parser.parseInline));
        __publicField(this, "Parser", _Parser);
        __publicField(this, "Renderer", _Renderer);
        __publicField(this, "TextRenderer", _TextRenderer);
        __publicField(this, "Lexer", _Lexer);
        __publicField(this, "Tokenizer", _Tokenizer);
        __publicField(this, "Hooks", _Hooks);
        this.use(...args);
      }
      /**
       * Run callback for every token
       */
      walkTokens(tokens, callback) {
        var _a2, _b;
        let values2 = [];
        for (const token of tokens) {
          values2 = values2.concat(callback.call(this, token));
          switch (token.type) {
            case "table": {
              const tableToken = token;
              for (const cell of tableToken.header) {
                values2 = values2.concat(this.walkTokens(cell.tokens, callback));
              }
              for (const row of tableToken.rows) {
                for (const cell of row) {
                  values2 = values2.concat(this.walkTokens(cell.tokens, callback));
                }
              }
              break;
            }
            case "list": {
              const listToken = token;
              values2 = values2.concat(this.walkTokens(listToken.items, callback));
              break;
            }
            default: {
              const genericToken = token;
              if ((_b = (_a2 = this.defaults.extensions) == null ? void 0 : _a2.childTokens) == null ? void 0 : _b[genericToken.type]) {
                this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                  values2 = values2.concat(this.walkTokens(genericToken[childTokens], callback));
                });
              } else if (genericToken.tokens) {
                values2 = values2.concat(this.walkTokens(genericToken.tokens, callback));
              }
            }
          }
        }
        return values2;
      }
      use(...args) {
        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
        args.forEach((pack) => {
          const opts = { ...pack };
          opts.async = this.defaults.async || opts.async || false;
          if (pack.extensions) {
            pack.extensions.forEach((ext) => {
              if (!ext.name) {
                throw new Error("extension name required");
              }
              if ("renderer" in ext) {
                const prevRenderer = extensions.renderers[ext.name];
                if (prevRenderer) {
                  extensions.renderers[ext.name] = function(...args2) {
                    let ret = ext.renderer.apply(this, args2);
                    if (ret === false) {
                      ret = prevRenderer.apply(this, args2);
                    }
                    return ret;
                  };
                } else {
                  extensions.renderers[ext.name] = ext.renderer;
                }
              }
              if ("tokenizer" in ext) {
                if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                  throw new Error("extension level must be 'block' or 'inline'");
                }
                const extLevel = extensions[ext.level];
                if (extLevel) {
                  extLevel.unshift(ext.tokenizer);
                } else {
                  extensions[ext.level] = [ext.tokenizer];
                }
                if (ext.start) {
                  if (ext.level === "block") {
                    if (extensions.startBlock) {
                      extensions.startBlock.push(ext.start);
                    } else {
                      extensions.startBlock = [ext.start];
                    }
                  } else if (ext.level === "inline") {
                    if (extensions.startInline) {
                      extensions.startInline.push(ext.start);
                    } else {
                      extensions.startInline = [ext.start];
                    }
                  }
                }
              }
              if ("childTokens" in ext && ext.childTokens) {
                extensions.childTokens[ext.name] = ext.childTokens;
              }
            });
            opts.extensions = extensions;
          }
          if (pack.renderer) {
            const renderer2 = this.defaults.renderer || new _Renderer(this.defaults);
            for (const prop in pack.renderer) {
              const rendererFunc = pack.renderer[prop];
              const rendererKey = prop;
              const prevRenderer = renderer2[rendererKey];
              renderer2[rendererKey] = (...args2) => {
                let ret = rendererFunc.apply(renderer2, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(renderer2, args2);
                }
                return ret || "";
              };
            }
            opts.renderer = renderer2;
          }
          if (pack.tokenizer) {
            const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
            for (const prop in pack.tokenizer) {
              const tokenizerFunc = pack.tokenizer[prop];
              const tokenizerKey = prop;
              const prevTokenizer = tokenizer[tokenizerKey];
              tokenizer[tokenizerKey] = (...args2) => {
                let ret = tokenizerFunc.apply(tokenizer, args2);
                if (ret === false) {
                  ret = prevTokenizer.apply(tokenizer, args2);
                }
                return ret;
              };
            }
            opts.tokenizer = tokenizer;
          }
          if (pack.hooks) {
            const hooks = this.defaults.hooks || new _Hooks();
            for (const prop in pack.hooks) {
              const hooksFunc = pack.hooks[prop];
              const hooksKey = prop;
              const prevHook = hooks[hooksKey];
              if (_Hooks.passThroughHooks.has(prop)) {
                hooks[hooksKey] = (arg) => {
                  if (this.defaults.async) {
                    return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                      return prevHook.call(hooks, ret2);
                    });
                  }
                  const ret = hooksFunc.call(hooks, arg);
                  return prevHook.call(hooks, ret);
                };
              } else {
                hooks[hooksKey] = (...args2) => {
                  let ret = hooksFunc.apply(hooks, args2);
                  if (ret === false) {
                    ret = prevHook.apply(hooks, args2);
                  }
                  return ret;
                };
              }
            }
            opts.hooks = hooks;
          }
          if (pack.walkTokens) {
            const walkTokens = this.defaults.walkTokens;
            const packWalktokens = pack.walkTokens;
            opts.walkTokens = function(token) {
              let values2 = [];
              values2.push(packWalktokens.call(this, token));
              if (walkTokens) {
                values2 = values2.concat(walkTokens.call(this, token));
              }
              return values2;
            };
          }
          this.defaults = { ...this.defaults, ...opts };
        });
        return this;
      }
      setOptions(opt) {
        this.defaults = { ...this.defaults, ...opt };
        return this;
      }
      lexer(src, options) {
        return _Lexer.lex(src, options ?? this.defaults);
      }
      parser(tokens, options) {
        return _Parser.parse(tokens, options ?? this.defaults);
      }
    }
    _parseMarkdown = new WeakSet();
    parseMarkdown_fn = function(lexer, parser) {
      return (src, options) => {
        const origOpt = { ...options };
        const opt = { ...this.defaults, ...origOpt };
        if (this.defaults.async === true && origOpt.async === false) {
          if (!opt.silent) {
            console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.");
          }
          opt.async = true;
        }
        const throwError2 = __privateMethod(this, _onError, onError_fn).call(this, !!opt.silent, !!opt.async);
        if (typeof src === "undefined" || src === null) {
          return throwError2(new Error("marked(): input parameter is undefined or null"));
        }
        if (typeof src !== "string") {
          return throwError2(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
        }
        if (opt.hooks) {
          opt.hooks.options = opt;
        }
        if (opt.async) {
          return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError2);
        }
        try {
          if (opt.hooks) {
            src = opt.hooks.preprocess(src);
          }
          const tokens = lexer(src, opt);
          if (opt.walkTokens) {
            this.walkTokens(tokens, opt.walkTokens);
          }
          let html = parser(tokens, opt);
          if (opt.hooks) {
            html = opt.hooks.postprocess(html);
          }
          return html;
        } catch (e) {
          return throwError2(e);
        }
      };
    };
    _onError = new WeakSet();
    onError_fn = function(silent, async) {
      return (e) => {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (silent) {
          const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
          if (async) {
            return Promise.resolve(msg);
          }
          return msg;
        }
        if (async) {
          return Promise.reject(e);
        }
        throw e;
      };
    };
    const markedInstance = new Marked();
    function marked(src, opt) {
      return markedInstance.parse(src, opt);
    }
    marked.options = marked.setOptions = function(options) {
      markedInstance.setOptions(options);
      marked.defaults = markedInstance.defaults;
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.getDefaults = _getDefaults;
    marked.defaults = _defaults;
    marked.use = function(...args) {
      markedInstance.use(...args);
      marked.defaults = markedInstance.defaults;
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.walkTokens = function(tokens, callback) {
      return markedInstance.walkTokens(tokens, callback);
    };
    marked.parseInline = markedInstance.parseInline;
    marked.Parser = _Parser;
    marked.parser = _Parser.parse;
    marked.Renderer = _Renderer;
    marked.TextRenderer = _TextRenderer;
    marked.Lexer = _Lexer;
    marked.lexer = _Lexer.lex;
    marked.Tokenizer = _Tokenizer;
    marked.Hooks = _Hooks;
    marked.parse = marked;
    marked.options;
    marked.setOptions;
    marked.use;
    marked.walkTokens;
    marked.parseInline;
    _Parser.parse;
    _Lexer.lex;
    marked.setOptions({});
    function currentPageType() {
      if (location.hostname.toLowerCase() !== "tieba.baidu.com")
        return "unhandled";
      const pathname = location.pathname.toLocaleLowerCase();
      if (includes(["/", "/index.html"], pathname))
        return "index";
      if (/\/p\/\d+/.test(pathname))
        return "thread";
      if (pathname === "/f")
        return "forum";
      if (pathname === "/home/main")
        return "user";
      return "unhandled";
    }
    async function getLatestReleaseFromGitee(owner = Owner, repo = RepoName, forceUpdate = false) {
      if (latestRelease.get() && !forceUpdate) {
        return latestRelease.get();
      } else {
        const TTL = function() {
          switch (updateConfig.get().time) {
            case "1h":
              return 1;
            case "3h":
              return 3;
            case "6h":
              return 6;
            case "never":
              return -1;
          }
        }();
        if (TTL < 0)
          return;
        const response = await fetch(`https://gitee.com/api/v5/repos/${owner}/${repo}/releases/latest/`);
        if (response.ok) {
          const result = await response.json();
          latestRelease.set(result, spawnOffsetTS(0, 0, 0, TTL));
          return result;
        } else {
          return void 0;
        }
      }
    }
    function checkUpdateAndNotify(showLatest = false) {
      if (updateConfig.get().time === "never")
        return;
      if (!updateConfig.get().notify)
        return;
      if (!showUpdateToday.get())
        return;
      if (_GM_info.script.version === "developer-only")
        return;
      getLatestReleaseFromGitee().then((latestRelease2) => {
        if (latestRelease2 && latestRelease2.tag_name.slice(1) !== _GM_info.script.version) {
          if (ignoredTag.get() === latestRelease2.tag_name)
            return;
          messageBox({
            title: latestRelease2.name,
            message: marked(latestRelease2.body),
            embedded: true,
            type: "OkCancel",
            buttons: [
              {
                title: "安装",
                event() {
                  installFromRelease(latestRelease2);
                }
              },
              {
                title: "今日不再提醒",
                event() {
                  showUpdateToday.set(false);
                }
              },
              {
                title: "跳过该版本",
                event() {
                  ignoredTag.set(latestRelease2.tag_name);
                }
              }
            ]
          });
        } else {
          if (showLatest)
            messageBox({
              title: "检查更新",
              message: "当前已是最新版本",
              type: "OkCancel"
            });
        }
      });
    }
    function installFromRelease(release) {
      function notFound() {
        toast({
          message: "安装失败：未找到可用的资源",
          type: "error",
          duration: 6e3,
          blurEffect: true
        });
      }
      if (!release.assets || release.assets.length <= 0) {
        notFound();
        return;
      }
      const asset = function() {
        for (const asset2 of release.assets) {
          if (asset2.name && asset2.name.endsWith(".user.js")) {
            return asset2.browser_download_url;
          }
        }
      }();
      if (asset) {
        _GM_openInTab(asset, {
          active: true
        });
      } else {
        notFound();
        return;
      }
    }
    function getResource(path) {
      return `${GiteeRepo}/raw/beta/${path}`;
    }
    function setTheme(theme) {
      requestAnimationFrame(autoTheme);
      switch (theme) {
        case "dark": {
          darkTheme();
          break;
        }
        case "light": {
          lightTheme();
          break;
        }
      }
      function autoTheme() {
        if (themeType.get() === "auto") {
          if (matchMedia && matchMedia("(prefers-color-scheme: dark)").matches)
            darkTheme();
          else
            lightTheme();
        }
        requestAnimationFrame(autoTheme);
      }
      function lightTheme() {
        document.body.classList.add("light-theme");
        document.body.classList.remove("dark-theme");
        document.documentElement.classList.remove("dark");
      }
      function darkTheme() {
        document.body.classList.add("dark-theme");
        document.body.classList.remove("light-theme");
        document.documentElement.classList.add("dark");
      }
    }
    function backupUserConfigs() {
      const excluded = ["unreadFeeds", "latestRelease", "showUpdateToday"];
      const userKeys = filter(_GM_listValues(), (key) => !includes(excluded, key));
      const userValues = map(userKeys, (key) => {
        return _GM_getValue(key);
      });
      const configs = zipObject(userKeys, userValues);
      outputFile(`tieba-remix-backup@${(/* @__PURE__ */ new Date()).getTime()}.json`, JSON.stringify(configs));
    }
    async function restoreUserConfigs() {
      const backupData = JSON.parse(await selectLocalFile());
      console.log(backupData);
      forEach(Object.entries(backupData), ([key, value]) => {
        _GM_setValue(key, value);
      });
    }
    const _withScopeId$7 = (n) => (pushScopeId("data-v-d80f8352"), n = n(), popScopeId(), n);
    const _hoisted_1$m = { class: "about-wrapper" };
    const _hoisted_2$i = { class: "main-title" };
    const _hoisted_3$b = ["src"];
    const _hoisted_4$9 = { class: "title" };
    const _hoisted_5$8 = { class: "script-info" };
    const _hoisted_6$6 = { class: "author-info" };
    const _hoisted_7$4 = { class: "version" };
    const _hoisted_8$4 = { class: "author" };
    const _hoisted_9$4 = { class: "about-desc" };
    const _hoisted_10$4 = { class: "line" };
    const _hoisted_11$3 = { class: "about-controls" };
    const _hoisted_12$3 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("div", { class: "about-desc" }, null, -1));
    const _sfc_main$H = /* @__PURE__ */ defineComponent({
      __name: "about.detail",
      emits: ["changeView"],
      setup(__props, { emit: __emit }) {
        const scriptInfo = _GM_info;
        const emit2 = __emit;
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$m, [
            createBaseVNode("div", _hoisted_2$i, [
              createBaseVNode("img", {
                src: unref(getResource)("/assets/images/main/icon.png"),
                alt: "icon",
                class: "main-icon"
              }, null, 8, _hoisted_3$b),
              createBaseVNode("div", _hoisted_4$9, toDisplayString(unref(MainTitle)), 1)
            ]),
            createBaseVNode("div", _hoisted_5$8, [
              createBaseVNode("div", _hoisted_6$6, [
                createBaseVNode("div", _hoisted_7$4, toDisplayString(unref(scriptInfo).script.version), 1),
                createBaseVNode("div", _hoisted_8$4, "@" + toDisplayString(unref(scriptInfo).script.author), 1)
              ]),
              createBaseVNode("div", _hoisted_9$4, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(`本开源项目使用 ${unref(_GM_info).script.license} 协议`.split("\n"), (line) => {
                  return openBlock(), createElementBlock("div", _hoisted_10$4, toDisplayString(line), 1);
                }), 256))
              ])
            ]),
            createBaseVNode("div", _hoisted_11$3, [
              createVNode(_sfc_main$Q, {
                class: "about-button github",
                "is-anchor": true,
                href: unref(GithubRepo),
                "shadow-border": true,
                target: "_balnk"
              }, {
                default: withCtx(() => [
                  createTextVNode("开放源代码 ")
                ]),
                _: 1
              }, 8, ["href"]),
              createVNode(_sfc_main$Q, {
                class: "about-button update",
                "shadow-border": true,
                onClick: _cache[0] || (_cache[0] = ($event) => emit2("changeView", "about", "update"))
              }, {
                default: withCtx(() => [
                  createTextVNode(" 检查更新 ")
                ]),
                _: 1
              })
            ]),
            _hoisted_12$3
          ]);
        };
      }
    });
    const AboutDetail = /* @__PURE__ */ _export_sfc$1(_sfc_main$H, [["__scopeId", "data-v-d80f8352"]]);
    const _withScopeId$6 = (n) => (pushScopeId("data-v-eeb67353"), n = n(), popScopeId(), n);
    const _hoisted_1$l = {
      key: 0,
      class: "update-wrapper"
    };
    const _hoisted_2$h = { class: "icon" };
    const _hoisted_3$a = { class: "content" };
    const _hoisted_4$8 = { class: "title-container" };
    const _hoisted_5$7 = { class: "title" };
    const _hoisted_6$5 = {
      key: 0,
      class: "is-pre-release"
    };
    const _hoisted_7$3 = { class: "main-info" };
    const _hoisted_8$3 = ["src"];
    const _hoisted_9$3 = { class: "owner" };
    const _hoisted_10$3 = ["innerHTML"];
    const _hoisted_11$2 = { class: "update-controls" };
    const _hoisted_12$2 = {
      key: 1,
      class: "forbidden-wrapper"
    };
    const _hoisted_13$2 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("div", { class: "icon" }, "warning", -1));
    const _hoisted_14$2 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("div", { class: "forbidden-text" }, "请求过于频繁，请稍后重试", -1));
    const _hoisted_15$2 = [
      _hoisted_13$2,
      _hoisted_14$2
    ];
    const _sfc_main$G = /* @__PURE__ */ defineComponent({
      __name: "about.update",
      setup(__props) {
        const release = ref();
        const forbidden = ref(false);
        const isLatest = ref();
        const scriptInfo = _GM_info;
        marked.setOptions({});
        onMounted(async () => {
          const latest = await getLatestReleaseFromGitee();
          if (latest) {
            forbidden.value = false;
            release.value = latest;
            isLatest.value = `v${scriptInfo.script.version}` >= release.value.tag_name;
          } else {
            forbidden.value = true;
          }
        });
        return (_ctx, _cache) => {
          var _a2, _b, _c, _d, _e, _f, _g, _h;
          return !forbidden.value ? (openBlock(), createElementBlock("div", _hoisted_1$l, [
            isLatest.value !== void 0 ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(["latest-info", { "is-latest": isLatest.value }])
            }, [
              createBaseVNode("div", _hoisted_2$h, toDisplayString(isLatest.value ? "check" : "warning"), 1),
              createBaseVNode("div", _hoisted_3$a, toDisplayString(isLatest.value ? "当前是最新版本" : "检测到新版本"), 1)
            ], 2)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_4$8, [
              createBaseVNode("div", _hoisted_5$7, toDisplayString((_a2 = release.value) == null ? void 0 : _a2.name), 1),
              ((_b = release.value) == null ? void 0 : _b.prerelease) ? (openBlock(), createElementBlock("div", _hoisted_6$5, "预览版")) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_7$3, [
              ((_c = release.value) == null ? void 0 : _c.author.avatar_url) ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: (_d = release.value) == null ? void 0 : _d.author.avatar_url,
                alt: "",
                class: "avatar"
              }, null, 8, _hoisted_8$3)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_9$3, toDisplayString((_e = release.value) == null ? void 0 : _e.author.name), 1)
            ]),
            createBaseVNode("div", {
              class: "release-body markdown",
              innerHTML: ((_f = release.value) == null ? void 0 : _f.body) ? unref(marked)((_g = release.value) == null ? void 0 : _g.body) : ""
            }, null, 8, _hoisted_10$3),
            createBaseVNode("div", _hoisted_11$2, [
              createVNode(_sfc_main$Q, {
                class: "up-button download-button",
                "shadow-border": "",
                "theme-style": "",
                "is-anchor": "",
                href: (_h = release.value) == null ? void 0 : _h.assets[0].browser_download_url
              }, {
                default: withCtx(() => [
                  createTextVNode("安装更新 ")
                ]),
                _: 1
              }, 8, ["href"])
            ])
          ])) : (openBlock(), createElementBlock("div", _hoisted_12$2, _hoisted_15$2));
        };
      }
    });
    const AboutUpdate = /* @__PURE__ */ _export_sfc$1(_sfc_main$G, [["__scopeId", "data-v-eeb67353"]]);
    const dynCSSRules = {
      customBackground: () => {
        var _a2;
        return findIndex(Array.from(((_a2 = defaultStyle.sheet) == null ? void 0 : _a2.cssRules) ?? { length: 0 }), (rule) => rule.selectorText === "body.custom-background");
      }
    };
    function setCustomBackground() {
      afterHead(function() {
        if (dynCSSRules.customBackground() !== -1) {
          removeCSSRule(dynCSSRules.customBackground());
        }
        injectCSSRule("body.custom-background", {
          backgroundImage: `url('${customBackground.get()}') !important`,
          backgroundRepeat: "no-repeat !important",
          backgroundAttachment: "fixed !important",
          backgroundSize: "cover !important"
        }) ?? -1;
        waitUtil(() => document.body !== null, void 0, 4).then(function() {
          if (customBackground.get()) {
            document.body.classList.add("custom-background");
          } else {
            document.body.classList.remove("custom-background");
          }
        });
      });
    }
    const _hoisted_1$k = { class: "layout-custom-back" };
    const _hoisted_2$g = ["src"];
    const _hoisted_3$9 = { class: "custom-back-buttons" };
    const _sfc_main$F = /* @__PURE__ */ defineComponent({
      __name: "layout.custom-back",
      setup(__props) {
        const imageData = ref(customBackground.get());
        const alphaValue = ref("100");
        const imageAlphaInput = ref();
        watch(imageData, (newValue) => {
          customBackground.set(newValue);
          setCustomBackground();
        });
        watch(alphaValue, (newValue) => {
          var _a2;
          const inputElement = (_a2 = imageAlphaInput.value) == null ? void 0 : _a2.$el;
          if (newValue === "" || +newValue < 0)
            alphaValue.value = "0", inputElement.value = "0";
          if (+newValue > 100)
            alphaValue.value = "100", inputElement.value = "100";
        });
        onMounted(async function() {
          imageData.value = customBackground.get();
        });
        async function clearImage() {
          imageData.value = null;
        }
        async function selectImageFile() {
          imageData.value = await selectLocalFile();
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$k, [
            withDirectives(createBaseVNode("img", {
              class: "custom-image",
              src: imageData.value ?? "",
              title: "自定义背景",
              alt: "自定义背景",
              style: normalizeStyle(`opacity: ${+alphaValue.value / 100}`)
            }, null, 12, _hoisted_2$g), [
              [vShow, imageData.value]
            ]),
            createBaseVNode("div", _hoisted_3$9, [
              createVNode(_sfc_main$Q, { onClick: clearImage }, {
                default: withCtx(() => [
                  createTextVNode("清除")
                ]),
                _: 1
              }),
              createVNode(_sfc_main$Q, { onClick: selectImageFile }, {
                default: withCtx(() => [
                  createTextVNode("上传图片")
                ]),
                _: 1
              })
            ])
          ]);
        };
      }
    });
    const LayoutCustomBack = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["__scopeId", "data-v-486f1dc3"]]);
    const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
      const handleEvent = (event) => {
        const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
        if (checkForDefaultPrevented === false || !shouldPrevent) {
          return oursHandler == null ? void 0 : oursHandler(event);
        }
      };
      return handleEvent;
    };
    var _a;
    const isClient = typeof window !== "undefined";
    const isString = (val) => typeof val === "string";
    const noop = () => {
    };
    const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
    function resolveUnref(r) {
      return typeof r === "function" ? r() : unref(r);
    }
    function identity(arg) {
      return arg;
    }
    function tryOnScopeDispose(fn2) {
      if (getCurrentScope()) {
        onScopeDispose(fn2);
        return true;
      }
      return false;
    }
    function tryOnMounted(fn2, sync = true) {
      if (getCurrentInstance())
        onMounted(fn2);
      else if (sync)
        fn2();
      else
        nextTick(fn2);
    }
    function unrefElement(elRef) {
      var _a2;
      const plain = resolveUnref(elRef);
      return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
    }
    const defaultWindow = isClient ? window : void 0;
    function useEventListener(...args) {
      let target;
      let events;
      let listeners;
      let options;
      if (isString(args[0]) || Array.isArray(args[0])) {
        [events, listeners, options] = args;
        target = defaultWindow;
      } else {
        [target, events, listeners, options] = args;
      }
      if (!target)
        return noop;
      if (!Array.isArray(events))
        events = [events];
      if (!Array.isArray(listeners))
        listeners = [listeners];
      const cleanups = [];
      const cleanup = () => {
        cleanups.forEach((fn2) => fn2());
        cleanups.length = 0;
      };
      const register = (el, event, listener, options2) => {
        el.addEventListener(event, listener, options2);
        return () => el.removeEventListener(event, listener, options2);
      };
      const stopWatch = watch(() => [unrefElement(target), resolveUnref(options)], ([el, options2]) => {
        cleanup();
        if (!el)
          return;
        cleanups.push(...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, options2));
        }));
      }, { immediate: true, flush: "post" });
      const stop = () => {
        stopWatch();
        cleanup();
      };
      tryOnScopeDispose(stop);
      return stop;
    }
    let _iOSWorkaround = false;
    function onClickOutside(target, handler, options = {}) {
      const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
      if (!window2)
        return;
      if (isIOS && !_iOSWorkaround) {
        _iOSWorkaround = true;
        Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop));
      }
      let shouldListen = true;
      const shouldIgnore = (event) => {
        return ignore.some((target2) => {
          if (typeof target2 === "string") {
            return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
          } else {
            const el = unrefElement(target2);
            return el && (event.target === el || event.composedPath().includes(el));
          }
        });
      };
      const listener = (event) => {
        const el = unrefElement(target);
        if (!el || el === event.target || event.composedPath().includes(el))
          return;
        if (event.detail === 0)
          shouldListen = !shouldIgnore(event);
        if (!shouldListen) {
          shouldListen = true;
          return;
        }
        handler(event);
      };
      const cleanup = [
        useEventListener(window2, "click", listener, { passive: true, capture }),
        useEventListener(window2, "pointerdown", (e) => {
          const el = unrefElement(target);
          if (el)
            shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);
        }, { passive: true }),
        detectIframe && useEventListener(window2, "blur", (event) => {
          var _a2;
          const el = unrefElement(target);
          if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
            handler(event);
        })
      ].filter(Boolean);
      const stop = () => cleanup.forEach((fn2) => fn2());
      return stop;
    }
    function useSupported(callback, sync = false) {
      const isSupported2 = ref();
      const update = () => isSupported2.value = Boolean(callback());
      update();
      tryOnMounted(update, sync);
      return isSupported2;
    }
    const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    const globalKey = "__vueuse_ssr_handlers__";
    _global[globalKey] = _global[globalKey] || {};
    var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
    var __hasOwnProp$g = Object.prototype.hasOwnProperty;
    var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
    var __objRest$2 = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols$g)
        for (var prop of __getOwnPropSymbols$g(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    function useResizeObserver(target, callback, options = {}) {
      const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
      let observer;
      const isSupported2 = useSupported(() => window2 && "ResizeObserver" in window2);
      const cleanup = () => {
        if (observer) {
          observer.disconnect();
          observer = void 0;
        }
      };
      const stopWatch = watch(() => unrefElement(target), (el) => {
        cleanup();
        if (isSupported2.value && window2 && el) {
          observer = new ResizeObserver(callback);
          observer.observe(el, observerOptions);
        }
      }, { immediate: true, flush: "post" });
      const stop = () => {
        cleanup();
        stopWatch();
      };
      tryOnScopeDispose(stop);
      return {
        isSupported: isSupported2,
        stop
      };
    }
    var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
    var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
    var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
    var __objRest$1 = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols$8)
        for (var prop of __getOwnPropSymbols$8(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    function useMutationObserver(target, callback, options = {}) {
      const _a2 = options, { window: window2 = defaultWindow } = _a2, mutationOptions = __objRest$1(_a2, ["window"]);
      let observer;
      const isSupported2 = useSupported(() => window2 && "MutationObserver" in window2);
      const cleanup = () => {
        if (observer) {
          observer.disconnect();
          observer = void 0;
        }
      };
      const stopWatch = watch(() => unrefElement(target), (el) => {
        cleanup();
        if (isSupported2.value && window2 && el) {
          observer = new MutationObserver(callback);
          observer.observe(el, mutationOptions);
        }
      }, { immediate: true });
      const stop = () => {
        cleanup();
        stopWatch();
      };
      tryOnScopeDispose(stop);
      return {
        isSupported: isSupported2,
        stop
      };
    }
    var SwipeDirection;
    (function(SwipeDirection2) {
      SwipeDirection2["UP"] = "UP";
      SwipeDirection2["RIGHT"] = "RIGHT";
      SwipeDirection2["DOWN"] = "DOWN";
      SwipeDirection2["LEFT"] = "LEFT";
      SwipeDirection2["NONE"] = "NONE";
    })(SwipeDirection || (SwipeDirection = {}));
    var __defProp2 = Object.defineProperty;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp2(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp2(a, prop, b[prop]);
        }
      return a;
    };
    const _TransitionPresets = {
      easeInSine: [0.12, 0, 0.39, 0],
      easeOutSine: [0.61, 1, 0.88, 1],
      easeInOutSine: [0.37, 0, 0.63, 1],
      easeInQuad: [0.11, 0, 0.5, 0],
      easeOutQuad: [0.5, 1, 0.89, 1],
      easeInOutQuad: [0.45, 0, 0.55, 1],
      easeInCubic: [0.32, 0, 0.67, 0],
      easeOutCubic: [0.33, 1, 0.68, 1],
      easeInOutCubic: [0.65, 0, 0.35, 1],
      easeInQuart: [0.5, 0, 0.75, 0],
      easeOutQuart: [0.25, 1, 0.5, 1],
      easeInOutQuart: [0.76, 0, 0.24, 1],
      easeInQuint: [0.64, 0, 0.78, 0],
      easeOutQuint: [0.22, 1, 0.36, 1],
      easeInOutQuint: [0.83, 0, 0.17, 1],
      easeInExpo: [0.7, 0, 0.84, 0],
      easeOutExpo: [0.16, 1, 0.3, 1],
      easeInOutExpo: [0.87, 0, 0.13, 1],
      easeInCirc: [0.55, 0, 1, 0.45],
      easeOutCirc: [0, 0.55, 0.45, 1],
      easeInOutCirc: [0.85, 0, 0.15, 1],
      easeInBack: [0.36, 0, 0.66, -0.56],
      easeOutBack: [0.34, 1.56, 0.64, 1],
      easeInOutBack: [0.68, -0.6, 0.32, 1.6]
    };
    __spreadValues({
      linear: identity
    }, _TransitionPresets);
    const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
    const getClientXY = (event) => {
      let clientX;
      let clientY;
      if (event.type === "touchend") {
        clientY = event.changedTouches[0].clientY;
        clientX = event.changedTouches[0].clientX;
      } else if (event.type.startsWith("touch")) {
        clientY = event.touches[0].clientY;
        clientX = event.touches[0].clientX;
      } else {
        clientY = event.clientY;
        clientX = event.clientX;
      }
      return {
        clientX,
        clientY
      };
    };
    const isUndefined = (val) => val === void 0;
    const isBoolean = (val) => typeof val === "boolean";
    const isNumber = (val) => typeof val === "number";
    const isElement = (e) => {
      if (typeof Element === "undefined")
        return false;
      return e instanceof Element;
    };
    const isStringNumber = (val) => {
      if (!isString$2(val)) {
        return false;
      }
      return !Number.isNaN(Number(val));
    };
    const escapeStringRegexp = (string = "") => string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    class ElementPlusError extends Error {
      constructor(m) {
        super(m);
        this.name = "ElementPlusError";
      }
    }
    function throwError(scope, m) {
      throw new ElementPlusError(`[${scope}] ${m}`);
    }
    function debugWarn(scope, message) {
      {
        const error = isString$2(scope) ? new ElementPlusError(`[${scope}] ${message}`) : scope;
        console.warn(error);
      }
    }
    const SCOPE = "utils/dom/style";
    function addUnit(value, defaultUnit = "px") {
      if (!value)
        return "";
      if (isNumber(value) || isStringNumber(value)) {
        return `${value}${defaultUnit}`;
      } else if (isString$2(value)) {
        return value;
      }
      debugWarn(SCOPE, "binding value must be a string or number");
    }
    function scrollIntoView(container, selected) {
      if (!isClient)
        return;
      if (!selected) {
        container.scrollTop = 0;
        return;
      }
      const offsetParents = [];
      let pointer = selected.offsetParent;
      while (pointer !== null && container !== pointer && container.contains(pointer)) {
        offsetParents.push(pointer);
        pointer = pointer.offsetParent;
      }
      const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
      const bottom = top + selected.offsetHeight;
      const viewRectTop = container.scrollTop;
      const viewRectBottom = viewRectTop + container.clientHeight;
      if (top < viewRectTop) {
        container.scrollTop = top;
      } else if (bottom > viewRectBottom) {
        container.scrollTop = bottom - container.clientHeight;
      }
    }
    /*! Element Plus Icons Vue v2.3.1 */
    var arrow_down_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "ArrowDown",
      __name: "arrow-down",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
          })
        ]));
      }
    });
    var arrow_down_default = arrow_down_vue_vue_type_script_setup_true_lang_default;
    var arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "ArrowLeft",
      __name: "arrow-left",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
          })
        ]));
      }
    });
    var arrow_left_default = arrow_left_vue_vue_type_script_setup_true_lang_default;
    var arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "ArrowRight",
      __name: "arrow-right",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
          })
        ]));
      }
    });
    var arrow_right_default = arrow_right_vue_vue_type_script_setup_true_lang_default;
    var circle_check_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "CircleCheck",
      __name: "circle-check",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
          }),
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
          })
        ]));
      }
    });
    var circle_check_default = circle_check_vue_vue_type_script_setup_true_lang_default;
    var circle_close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "CircleClose",
      __name: "circle-close",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
          }),
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
          })
        ]));
      }
    });
    var circle_close_default = circle_close_vue_vue_type_script_setup_true_lang_default;
    var close_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Close",
      __name: "close",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
          })
        ]));
      }
    });
    var close_default = close_vue_vue_type_script_setup_true_lang_default;
    var d_arrow_left_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "DArrowLeft",
      __name: "d-arrow-left",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
          })
        ]));
      }
    });
    var d_arrow_left_default = d_arrow_left_vue_vue_type_script_setup_true_lang_default;
    var d_arrow_right_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "DArrowRight",
      __name: "d-arrow-right",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
          })
        ]));
      }
    });
    var d_arrow_right_default = d_arrow_right_vue_vue_type_script_setup_true_lang_default;
    var hide_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Hide",
      __name: "hide",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
          }),
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
          })
        ]));
      }
    });
    var hide_default = hide_vue_vue_type_script_setup_true_lang_default;
    var loading_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "Loading",
      __name: "loading",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
          })
        ]));
      }
    });
    var loading_default = loading_vue_vue_type_script_setup_true_lang_default;
    var more_filled_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "MoreFilled",
      __name: "more-filled",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
          })
        ]));
      }
    });
    var more_filled_default = more_filled_vue_vue_type_script_setup_true_lang_default;
    var view_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
      name: "View",
      __name: "view",
      setup(__props) {
        return (_ctx, _cache) => (openBlock(), createElementBlock("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 1024 1024"
        }, [
          createBaseVNode("path", {
            fill: "currentColor",
            d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
          })
        ]));
      }
    });
    var view_default = view_vue_vue_type_script_setup_true_lang_default;
    const epPropKey = "__epPropKey";
    const definePropType = (val) => val;
    const isEpProp = (val) => isObject$1(val) && !!val[epPropKey];
    const buildProp = (prop, key) => {
      if (!isObject$1(prop) || isEpProp(prop))
        return prop;
      const { values: values2, required, default: defaultValue, type, validator } = prop;
      const _validator = values2 || validator ? (val) => {
        let valid = false;
        let allowedValues = [];
        if (values2) {
          allowedValues = Array.from(values2);
          if (hasOwn(prop, "default")) {
            allowedValues.push(defaultValue);
          }
          valid || (valid = allowedValues.includes(val));
        }
        if (validator)
          valid || (valid = validator(val));
        if (!valid && allowedValues.length > 0) {
          const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
          warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
        }
        return valid;
      } : void 0;
      const epProp = {
        type,
        required: !!required,
        validator: _validator,
        [epPropKey]: true
      };
      if (hasOwn(prop, "default"))
        epProp.default = defaultValue;
      return epProp;
    };
    const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
      key,
      buildProp(option, key)
    ]));
    const iconPropType = definePropType([
      String,
      Object,
      Function
    ]);
    const ValidateComponentsMap = {
      validating: loading_default,
      success: circle_check_default,
      error: circle_close_default
    };
    const withInstall = (main2, extra) => {
      main2.install = (app) => {
        for (const comp of [main2, ...Object.values(extra != null ? extra : {})]) {
          app.component(comp.name, comp);
        }
      };
      if (extra) {
        for (const [key, comp] of Object.entries(extra)) {
          main2[key] = comp;
        }
      }
      return main2;
    };
    const withNoopInstall = (component) => {
      component.install = NOOP;
      return component;
    };
    const EVENT_CODE = {
      tab: "Tab",
      enter: "Enter",
      space: "Space",
      left: "ArrowLeft",
      up: "ArrowUp",
      right: "ArrowRight",
      down: "ArrowDown",
      esc: "Escape",
      delete: "Delete",
      backspace: "Backspace",
      numpadEnter: "NumpadEnter",
      pageUp: "PageUp",
      pageDown: "PageDown",
      home: "Home",
      end: "End"
    };
    const UPDATE_MODEL_EVENT = "update:modelValue";
    const CHANGE_EVENT = "change";
    const componentSizes = ["", "default", "small", "large"];
    const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
    const mutable = (val) => val;
    const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
    const LISTENER_PREFIX = /^on[A-Z]/;
    const useAttrs = (params = {}) => {
      const { excludeListeners = false, excludeKeys } = params;
      const allExcludeKeys = computed(() => {
        return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
      });
      const instance = getCurrentInstance();
      if (!instance) {
        debugWarn("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function");
        return computed(() => ({}));
      }
      return computed(() => {
        var _a2;
        return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
      });
    };
    const useDeprecated = ({ from, replacement, scope, version: version2, ref: ref2, type = "API" }, condition) => {
      watch(() => unref(condition), (val) => {
        if (val) {
          debugWarn(scope, `[${type}] ${from} is about to be deprecated in version ${version2}, please use ${replacement} instead.
For more detail, please visit: ${ref2}
`);
        }
      }, {
        immediate: true
      });
    };
    var English = {
      name: "en",
      el: {
        colorpicker: {
          confirm: "OK",
          clear: "Clear",
          defaultLabel: "color picker",
          description: "current color is {color}. press enter to select a new color."
        },
        datepicker: {
          now: "Now",
          today: "Today",
          cancel: "Cancel",
          clear: "Clear",
          confirm: "OK",
          dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
          monthTablePrompt: "Use the arrow keys and enter to select the month",
          yearTablePrompt: "Use the arrow keys and enter to select the year",
          selectedDate: "Selected date",
          selectDate: "Select date",
          selectTime: "Select time",
          startDate: "Start Date",
          startTime: "Start Time",
          endDate: "End Date",
          endTime: "End Time",
          prevYear: "Previous Year",
          nextYear: "Next Year",
          prevMonth: "Previous Month",
          nextMonth: "Next Month",
          year: "",
          month1: "January",
          month2: "February",
          month3: "March",
          month4: "April",
          month5: "May",
          month6: "June",
          month7: "July",
          month8: "August",
          month9: "September",
          month10: "October",
          month11: "November",
          month12: "December",
          week: "week",
          weeks: {
            sun: "Sun",
            mon: "Mon",
            tue: "Tue",
            wed: "Wed",
            thu: "Thu",
            fri: "Fri",
            sat: "Sat"
          },
          weeksFull: {
            sun: "Sunday",
            mon: "Monday",
            tue: "Tuesday",
            wed: "Wednesday",
            thu: "Thursday",
            fri: "Friday",
            sat: "Saturday"
          },
          months: {
            jan: "Jan",
            feb: "Feb",
            mar: "Mar",
            apr: "Apr",
            may: "May",
            jun: "Jun",
            jul: "Jul",
            aug: "Aug",
            sep: "Sep",
            oct: "Oct",
            nov: "Nov",
            dec: "Dec"
          }
        },
        inputNumber: {
          decrease: "decrease number",
          increase: "increase number"
        },
        select: {
          loading: "Loading",
          noMatch: "No matching data",
          noData: "No data",
          placeholder: "Select"
        },
        dropdown: {
          toggleDropdown: "Toggle Dropdown"
        },
        cascader: {
          noMatch: "No matching data",
          loading: "Loading",
          placeholder: "Select",
          noData: "No data"
        },
        pagination: {
          goto: "Go to",
          pagesize: "/page",
          total: "Total {total}",
          pageClassifier: "",
          page: "Page",
          prev: "Go to previous page",
          next: "Go to next page",
          currentPage: "page {pager}",
          prevPages: "Previous {pager} pages",
          nextPages: "Next {pager} pages",
          deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
        },
        dialog: {
          close: "Close this dialog"
        },
        drawer: {
          close: "Close this dialog"
        },
        messagebox: {
          title: "Message",
          confirm: "OK",
          cancel: "Cancel",
          error: "Illegal input",
          close: "Close this dialog"
        },
        upload: {
          deleteTip: "press delete to remove",
          delete: "Delete",
          preview: "Preview",
          continue: "Continue"
        },
        slider: {
          defaultLabel: "slider between {min} and {max}",
          defaultRangeStartLabel: "pick start value",
          defaultRangeEndLabel: "pick end value"
        },
        table: {
          emptyText: "No Data",
          confirmFilter: "Confirm",
          resetFilter: "Reset",
          clearFilter: "All",
          sumText: "Sum"
        },
        tour: {
          next: "Next",
          previous: "Previous",
          finish: "Finish"
        },
        tree: {
          emptyText: "No Data"
        },
        transfer: {
          noMatch: "No matching data",
          noData: "No data",
          titles: ["List 1", "List 2"],
          filterPlaceholder: "Enter keyword",
          noCheckedFormat: "{total} items",
          hasCheckedFormat: "{checked}/{total} checked"
        },
        image: {
          error: "FAILED"
        },
        pageHeader: {
          title: "Back"
        },
        popconfirm: {
          confirmButtonText: "Yes",
          cancelButtonText: "No"
        }
      }
    };
    const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
    const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_, key) => {
      var _a2;
      return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
    });
    const buildLocaleContext = (locale) => {
      const lang = computed(() => unref(locale).name);
      const localeRef = isRef(locale) ? locale : ref(locale);
      return {
        lang,
        locale: localeRef,
        t: buildTranslator(locale)
      };
    };
    const localeContextKey = Symbol("localeContextKey");
    const useLocale = (localeOverrides) => {
      const locale = localeOverrides || inject(localeContextKey, ref());
      return buildLocaleContext(computed(() => locale.value || English));
    };
    const defaultNamespace = "el";
    const statePrefix = "is-";
    const _bem = (namespace, block2, blockSuffix, element, modifier) => {
      let cls = `${namespace}-${block2}`;
      if (blockSuffix) {
        cls += `-${blockSuffix}`;
      }
      if (element) {
        cls += `__${element}`;
      }
      if (modifier) {
        cls += `--${modifier}`;
      }
      return cls;
    };
    const namespaceContextKey = Symbol("namespaceContextKey");
    const useGetDerivedNamespace = (namespaceOverrides) => {
      const derivedNamespace = namespaceOverrides || (getCurrentInstance() ? inject(namespaceContextKey, ref(defaultNamespace)) : ref(defaultNamespace));
      const namespace = computed(() => {
        return unref(derivedNamespace) || defaultNamespace;
      });
      return namespace;
    };
    const useNamespace = (block2, namespaceOverrides) => {
      const namespace = useGetDerivedNamespace(namespaceOverrides);
      const b = (blockSuffix = "") => _bem(namespace.value, block2, blockSuffix, "", "");
      const e = (element) => element ? _bem(namespace.value, block2, "", element, "") : "";
      const m = (modifier) => modifier ? _bem(namespace.value, block2, "", "", modifier) : "";
      const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block2, blockSuffix, element, "") : "";
      const em = (element, modifier) => element && modifier ? _bem(namespace.value, block2, "", element, modifier) : "";
      const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block2, blockSuffix, "", modifier) : "";
      const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block2, blockSuffix, element, modifier) : "";
      const is = (name, ...args) => {
        const state = args.length >= 1 ? args[0] : true;
        return name && state ? `${statePrefix}${name}` : "";
      };
      const cssVar = (object) => {
        const styles = {};
        for (const key in object) {
          if (object[key]) {
            styles[`--${namespace.value}-${key}`] = object[key];
          }
        }
        return styles;
      };
      const cssVarBlock = (object) => {
        const styles = {};
        for (const key in object) {
          if (object[key]) {
            styles[`--${namespace.value}-${block2}-${key}`] = object[key];
          }
        }
        return styles;
      };
      const cssVarName = (name) => `--${namespace.value}-${name}`;
      const cssVarBlockName = (name) => `--${namespace.value}-${block2}-${name}`;
      return {
        namespace,
        b,
        e,
        m,
        be: be2,
        em,
        bm,
        bem,
        is,
        cssVar,
        cssVarName,
        cssVarBlock,
        cssVarBlockName
      };
    };
    const _prop = buildProp({
      type: definePropType(Boolean),
      default: null
    });
    const _event = buildProp({
      type: definePropType(Function)
    });
    const createModelToggleComposable = (name) => {
      const updateEventKey = `update:${name}`;
      const updateEventKeyRaw = `onUpdate:${name}`;
      const useModelToggleEmits2 = [updateEventKey];
      const useModelToggleProps2 = {
        [name]: _prop,
        [updateEventKeyRaw]: _event
      };
      const useModelToggle2 = ({
        indicator,
        toggleReason,
        shouldHideWhenRouteChanges,
        shouldProceed,
        onShow,
        onHide
      }) => {
        const instance = getCurrentInstance();
        const { emit: emit2 } = instance;
        const props = instance.props;
        const hasUpdateHandler = computed(() => isFunction$1(props[updateEventKeyRaw]));
        const isModelBindingAbsent = computed(() => props[name] === null);
        const doShow = (event) => {
          if (indicator.value === true) {
            return;
          }
          indicator.value = true;
          if (toggleReason) {
            toggleReason.value = event;
          }
          if (isFunction$1(onShow)) {
            onShow(event);
          }
        };
        const doHide = (event) => {
          if (indicator.value === false) {
            return;
          }
          indicator.value = false;
          if (toggleReason) {
            toggleReason.value = event;
          }
          if (isFunction$1(onHide)) {
            onHide(event);
          }
        };
        const show = (event) => {
          if (props.disabled === true || isFunction$1(shouldProceed) && !shouldProceed())
            return;
          const shouldEmit = hasUpdateHandler.value && isClient;
          if (shouldEmit) {
            emit2(updateEventKey, true);
          }
          if (isModelBindingAbsent.value || !shouldEmit) {
            doShow(event);
          }
        };
        const hide = (event) => {
          if (props.disabled === true || !isClient)
            return;
          const shouldEmit = hasUpdateHandler.value && isClient;
          if (shouldEmit) {
            emit2(updateEventKey, false);
          }
          if (isModelBindingAbsent.value || !shouldEmit) {
            doHide(event);
          }
        };
        const onChange = (val) => {
          if (!isBoolean(val))
            return;
          if (props.disabled && val) {
            if (hasUpdateHandler.value) {
              emit2(updateEventKey, false);
            }
          } else if (indicator.value !== val) {
            if (val) {
              doShow();
            } else {
              doHide();
            }
          }
        };
        const toggle = () => {
          if (indicator.value) {
            hide();
          } else {
            show();
          }
        };
        watch(() => props[name], onChange);
        if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
          watch(() => ({
            ...instance.proxy.$route
          }), () => {
            if (shouldHideWhenRouteChanges.value && indicator.value) {
              hide();
            }
          });
        }
        onMounted(() => {
          onChange(props[name]);
        });
        return {
          hide,
          show,
          toggle,
          hasUpdateHandler
        };
      };
      return {
        useModelToggle: useModelToggle2,
        useModelToggleProps: useModelToggleProps2,
        useModelToggleEmits: useModelToggleEmits2
      };
    };
    const useProp = (name) => {
      const vm = getCurrentInstance();
      return computed(() => {
        var _a2, _b;
        return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
      });
    };
    var E = "top", R = "bottom", W = "right", P = "left", me = "auto", G = [E, R, W, P], U = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e) {
      return t.concat([e + "-" + U, e + "-" + J]);
    }, []), Ee = [].concat(G, [me]).reduce(function(t, e) {
      return t.concat([e, e + "-" + U, e + "-" + J]);
    }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
    function C(t) {
      return t ? (t.nodeName || "").toLowerCase() : null;
    }
    function H(t) {
      if (t == null)
        return window;
      if (t.toString() !== "[object Window]") {
        var e = t.ownerDocument;
        return e && e.defaultView || window;
      }
      return t;
    }
    function Q(t) {
      var e = H(t).Element;
      return t instanceof e || t instanceof Element;
    }
    function B(t) {
      var e = H(t).HTMLElement;
      return t instanceof e || t instanceof HTMLElement;
    }
    function Pe(t) {
      if (typeof ShadowRoot == "undefined")
        return false;
      var e = H(t).ShadowRoot;
      return t instanceof e || t instanceof ShadowRoot;
    }
    function Mt(t) {
      var e = t.state;
      Object.keys(e.elements).forEach(function(n) {
        var r = e.styles[n] || {}, o = e.attributes[n] || {}, i = e.elements[n];
        !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function(a) {
          var s = o[a];
          s === false ? i.removeAttribute(a) : i.setAttribute(a, s === true ? "" : s);
        }));
      });
    }
    function Rt(t) {
      var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
      return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
        Object.keys(e.elements).forEach(function(r) {
          var o = e.elements[r], i = e.attributes[r] || {}, a = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s = a.reduce(function(f, c) {
            return f[c] = "", f;
          }, {});
          !B(o) || !C(o) || (Object.assign(o.style, s), Object.keys(i).forEach(function(f) {
            o.removeAttribute(f);
          }));
        });
      };
    }
    var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
    function q(t) {
      return t.split("-")[0];
    }
    var X = Math.max, ve = Math.min, Z = Math.round;
    function ee(t, e) {
      e === void 0 && (e = false);
      var n = t.getBoundingClientRect(), r = 1, o = 1;
      if (B(t) && e) {
        var i = t.offsetHeight, a = t.offsetWidth;
        a > 0 && (r = Z(n.width) / a || 1), i > 0 && (o = Z(n.height) / i || 1);
      }
      return { width: n.width / r, height: n.height / o, top: n.top / o, right: n.right / r, bottom: n.bottom / o, left: n.left / r, x: n.left / r, y: n.top / o };
    }
    function ke(t) {
      var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
      return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
    }
    function it(t, e) {
      var n = e.getRootNode && e.getRootNode();
      if (t.contains(e))
        return true;
      if (n && Pe(n)) {
        var r = e;
        do {
          if (r && t.isSameNode(r))
            return true;
          r = r.parentNode || r.host;
        } while (r);
      }
      return false;
    }
    function N(t) {
      return H(t).getComputedStyle(t);
    }
    function Wt(t) {
      return ["table", "td", "th"].indexOf(C(t)) >= 0;
    }
    function I(t) {
      return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
    }
    function ge(t) {
      return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I(t);
    }
    function at(t) {
      return !B(t) || N(t).position === "fixed" ? null : t.offsetParent;
    }
    function Bt(t) {
      var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
      if (n && B(t)) {
        var r = N(t);
        if (r.position === "fixed")
          return null;
      }
      var o = ge(t);
      for (Pe(o) && (o = o.host); B(o) && ["html", "body"].indexOf(C(o)) < 0; ) {
        var i = N(o);
        if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
          return o;
        o = o.parentNode;
      }
      return null;
    }
    function se(t) {
      for (var e = H(t), n = at(t); n && Wt(n) && N(n).position === "static"; )
        n = at(n);
      return n && (C(n) === "html" || C(n) === "body" && N(n).position === "static") ? e : n || Bt(t) || e;
    }
    function Le(t) {
      return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
    }
    function fe(t, e, n) {
      return X(t, ve(e, n));
    }
    function St(t, e, n) {
      var r = fe(t, e, n);
      return r > n ? n : r;
    }
    function st() {
      return { top: 0, right: 0, bottom: 0, left: 0 };
    }
    function ft(t) {
      return Object.assign({}, st(), t);
    }
    function ct(t, e) {
      return e.reduce(function(n, r) {
        return n[r] = t, n;
      }, {});
    }
    var Tt = function(t, e) {
      return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
    };
    function Ht(t) {
      var e, n = t.state, r = t.name, o = t.options, i = n.elements.arrow, a = n.modifiersData.popperOffsets, s = q(n.placement), f = Le(s), c = [P, W].indexOf(s) >= 0, u = c ? "height" : "width";
      if (!(!i || !a)) {
        var m = Tt(o.padding, n), v = ke(i), l = f === "y" ? E : P, h2 = f === "y" ? R : W, p2 = n.rects.reference[u] + n.rects.reference[f] - a[f] - n.rects.popper[u], g = a[f] - n.rects.reference[f], x = se(i), y = x ? f === "y" ? x.clientHeight || 0 : x.clientWidth || 0 : 0, $ = p2 / 2 - g / 2, d = m[l], b = y - v[u] - m[h2], w = y / 2 - v[u] / 2 + $, O = fe(d, w, b), j = f;
        n.modifiersData[r] = (e = {}, e[j] = O, e.centerOffset = O - w, e);
      }
    }
    function Ct(t) {
      var e = t.state, n = t.options, r = n.element, o = r === void 0 ? "[data-popper-arrow]" : r;
      o != null && (typeof o == "string" && (o = e.elements.popper.querySelector(o), !o) || !it(e.elements.popper, o) || (e.elements.arrow = o));
    }
    var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
    function te(t) {
      return t.split("-")[1];
    }
    var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
    function Vt(t) {
      var e = t.x, n = t.y, r = window, o = r.devicePixelRatio || 1;
      return { x: Z(e * o) / o || 0, y: Z(n * o) / o || 0 };
    }
    function ut(t) {
      var e, n = t.popper, r = t.popperRect, o = t.placement, i = t.variation, a = t.offsets, s = t.position, f = t.gpuAcceleration, c = t.adaptive, u = t.roundOffsets, m = t.isFixed, v = a.x, l = v === void 0 ? 0 : v, h2 = a.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u == "function" ? u({ x: l, y: p2 }) : { x: l, y: p2 };
      l = g.x, p2 = g.y;
      var x = a.hasOwnProperty("x"), y = a.hasOwnProperty("y"), $ = P, d = E, b = window;
      if (c) {
        var w = se(n), O = "clientHeight", j = "clientWidth";
        if (w === H(n) && (w = I(n), N(w).position !== "static" && s === "absolute" && (O = "scrollHeight", j = "scrollWidth")), w = w, o === E || (o === P || o === W) && i === J) {
          d = R;
          var A = m && w === b && b.visualViewport ? b.visualViewport.height : w[O];
          p2 -= A - r.height, p2 *= f ? 1 : -1;
        }
        if (o === P || (o === E || o === R) && i === J) {
          $ = W;
          var k = m && w === b && b.visualViewport ? b.visualViewport.width : w[j];
          l -= k - r.width, l *= f ? 1 : -1;
        }
      }
      var D = Object.assign({ position: s }, c && qt), S = u === true ? Vt({ x: l, y: p2 }) : { x: l, y: p2 };
      if (l = S.x, p2 = S.y, f) {
        var L;
        return Object.assign({}, D, (L = {}, L[d] = y ? "0" : "", L[$] = x ? "0" : "", L.transform = (b.devicePixelRatio || 1) <= 1 ? "translate(" + l + "px, " + p2 + "px)" : "translate3d(" + l + "px, " + p2 + "px, 0)", L));
      }
      return Object.assign({}, D, (e = {}, e[d] = y ? p2 + "px" : "", e[$] = x ? l + "px" : "", e.transform = "", e));
    }
    function Nt(t) {
      var e = t.state, n = t.options, r = n.gpuAcceleration, o = r === void 0 ? true : r, i = n.adaptive, a = i === void 0 ? true : i, s = n.roundOffsets, f = s === void 0 ? true : s, c = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o, isFixed: e.options.strategy === "fixed" };
      e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a, roundOffsets: f })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
    }
    var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
    function It(t) {
      var e = t.state, n = t.instance, r = t.options, o = r.scroll, i = o === void 0 ? true : o, a = r.resize, s = a === void 0 ? true : a, f = H(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
      return i && c.forEach(function(u) {
        u.addEventListener("scroll", n.update, ye);
      }), s && f.addEventListener("resize", n.update, ye), function() {
        i && c.forEach(function(u) {
          u.removeEventListener("scroll", n.update, ye);
        }), s && f.removeEventListener("resize", n.update, ye);
      };
    }
    var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
    }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
    function be(t) {
      return t.replace(/left|right|bottom|top/g, function(e) {
        return _t[e];
      });
    }
    var zt = { start: "end", end: "start" };
    function lt(t) {
      return t.replace(/start|end/g, function(e) {
        return zt[e];
      });
    }
    function We(t) {
      var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
      return { scrollLeft: n, scrollTop: r };
    }
    function Be(t) {
      return ee(I(t)).left + We(t).scrollLeft;
    }
    function Ft(t) {
      var e = H(t), n = I(t), r = e.visualViewport, o = n.clientWidth, i = n.clientHeight, a = 0, s = 0;
      return r && (o = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r.offsetLeft, s = r.offsetTop)), { width: o, height: i, x: a + Be(t), y: s };
    }
    function Ut(t) {
      var e, n = I(t), r = We(t), o = (e = t.ownerDocument) == null ? void 0 : e.body, i = X(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), a = X(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), s = -r.scrollLeft + Be(t), f = -r.scrollTop;
      return N(o || n).direction === "rtl" && (s += X(n.clientWidth, o ? o.clientWidth : 0) - i), { width: i, height: a, x: s, y: f };
    }
    function Se(t) {
      var e = N(t), n = e.overflow, r = e.overflowX, o = e.overflowY;
      return /auto|scroll|overlay|hidden/.test(n + o + r);
    }
    function dt(t) {
      return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
    }
    function ce(t, e) {
      var n;
      e === void 0 && (e = []);
      var r = dt(t), o = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a = o ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s = e.concat(a);
      return o ? s : s.concat(ce(ge(a)));
    }
    function Te(t) {
      return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
    }
    function Xt(t) {
      var e = ee(t);
      return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
    }
    function ht(t, e) {
      return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I(t)));
    }
    function Yt(t) {
      var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N(t).position) >= 0, r = n && B(t) ? se(t) : t;
      return Q(r) ? e.filter(function(o) {
        return Q(o) && it(o, r) && C(o) !== "body";
      }) : [];
    }
    function Gt(t, e, n) {
      var r = e === "clippingParents" ? Yt(t) : [].concat(e), o = [].concat(r, [n]), i = o[0], a = o.reduce(function(s, f) {
        var c = ht(t, f);
        return s.top = X(c.top, s.top), s.right = ve(c.right, s.right), s.bottom = ve(c.bottom, s.bottom), s.left = X(c.left, s.left), s;
      }, ht(t, i));
      return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
    }
    function mt(t) {
      var e = t.reference, n = t.element, r = t.placement, o = r ? q(r) : null, i = r ? te(r) : null, a = e.x + e.width / 2 - n.width / 2, s = e.y + e.height / 2 - n.height / 2, f;
      switch (o) {
        case E:
          f = { x: a, y: e.y - n.height };
          break;
        case R:
          f = { x: a, y: e.y + e.height };
          break;
        case W:
          f = { x: e.x + e.width, y: s };
          break;
        case P:
          f = { x: e.x - n.width, y: s };
          break;
        default:
          f = { x: e.x, y: e.y };
      }
      var c = o ? Le(o) : null;
      if (c != null) {
        var u = c === "y" ? "height" : "width";
        switch (i) {
          case U:
            f[c] = f[c] - (e[u] / 2 - n[u] / 2);
            break;
          case J:
            f[c] = f[c] + (e[u] / 2 - n[u] / 2);
            break;
        }
      }
      return f;
    }
    function ne(t, e) {
      e === void 0 && (e = {});
      var n = e, r = n.placement, o = r === void 0 ? t.placement : r, i = n.boundary, a = i === void 0 ? Xe : i, s = n.rootBoundary, f = s === void 0 ? je : s, c = n.elementContext, u = c === void 0 ? K : c, m = n.altBoundary, v = m === void 0 ? false : m, l = n.padding, h2 = l === void 0 ? 0 : l, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u === K ? Ye : K, x = t.rects.popper, y = t.elements[v ? g : u], $ = Gt(Q(y) ? y : y.contextElement || I(t.elements.popper), a, f), d = ee(t.elements.reference), b = mt({ reference: d, element: x, strategy: "absolute", placement: o }), w = Te(Object.assign({}, x, b)), O = u === K ? w : d, j = { top: $.top - O.top + p2.top, bottom: O.bottom - $.bottom + p2.bottom, left: $.left - O.left + p2.left, right: O.right - $.right + p2.right }, A = t.modifiersData.offset;
      if (u === K && A) {
        var k = A[o];
        Object.keys(j).forEach(function(D) {
          var S = [W, R].indexOf(D) >= 0 ? 1 : -1, L = [E, R].indexOf(D) >= 0 ? "y" : "x";
          j[D] += k[L] * S;
        });
      }
      return j;
    }
    function Jt(t, e) {
      e === void 0 && (e = {});
      var n = e, r = n.placement, o = n.boundary, i = n.rootBoundary, a = n.padding, s = n.flipVariations, f = n.allowedAutoPlacements, c = f === void 0 ? Ee : f, u = te(r), m = u ? s ? De : De.filter(function(h2) {
        return te(h2) === u;
      }) : G, v = m.filter(function(h2) {
        return c.indexOf(h2) >= 0;
      });
      v.length === 0 && (v = m);
      var l = v.reduce(function(h2, p2) {
        return h2[p2] = ne(t, { placement: p2, boundary: o, rootBoundary: i, padding: a })[q(p2)], h2;
      }, {});
      return Object.keys(l).sort(function(h2, p2) {
        return l[h2] - l[p2];
      });
    }
    function Kt(t) {
      if (q(t) === me)
        return [];
      var e = be(t);
      return [lt(t), e, lt(e)];
    }
    function Qt(t) {
      var e = t.state, n = t.options, r = t.name;
      if (!e.modifiersData[r]._skip) {
        for (var o = n.mainAxis, i = o === void 0 ? true : o, a = n.altAxis, s = a === void 0 ? true : a, f = n.fallbackPlacements, c = n.padding, u = n.boundary, m = n.rootBoundary, v = n.altBoundary, l = n.flipVariations, h2 = l === void 0 ? true : l, p2 = n.allowedAutoPlacements, g = e.options.placement, x = q(g), y = x === g, $ = f || (y || !h2 ? [be(g)] : Kt(g)), d = [g].concat($).reduce(function(z, V) {
          return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u, rootBoundary: m, padding: c, flipVariations: h2, allowedAutoPlacements: p2 }) : V);
        }, []), b = e.rects.reference, w = e.rects.popper, O = /* @__PURE__ */ new Map(), j = true, A = d[0], k = 0; k < d.length; k++) {
          var D = d[k], S = q(D), L = te(D) === U, re = [E, R].indexOf(S) >= 0, oe = re ? "width" : "height", M = ne(e, { placement: D, boundary: u, rootBoundary: m, altBoundary: v, padding: c }), T = re ? L ? W : P : L ? R : E;
          b[oe] > w[oe] && (T = be(T));
          var pe = be(T), _ = [];
          if (i && _.push(M[S] <= 0), s && _.push(M[T] <= 0, M[pe] <= 0), _.every(function(z) {
            return z;
          })) {
            A = D, j = false;
            break;
          }
          O.set(D, _);
        }
        if (j)
          for (var ue = h2 ? 3 : 1, xe = function(z) {
            var V = d.find(function(de) {
              var ae = O.get(de);
              if (ae)
                return ae.slice(0, z).every(function(Y) {
                  return Y;
                });
            });
            if (V)
              return A = V, "break";
          }, ie = ue; ie > 0; ie--) {
            var le = xe(ie);
            if (le === "break")
              break;
          }
        e.placement !== A && (e.modifiersData[r]._skip = true, e.placement = A, e.reset = true);
      }
    }
    var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
    function gt(t, e, n) {
      return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
    }
    function yt(t) {
      return [E, W, R, P].some(function(e) {
        return t[e] >= 0;
      });
    }
    function Zt(t) {
      var e = t.state, n = t.name, r = e.rects.reference, o = e.rects.popper, i = e.modifiersData.preventOverflow, a = ne(e, { elementContext: "reference" }), s = ne(e, { altBoundary: true }), f = gt(a, r), c = gt(s, o, i), u = yt(f), m = yt(c);
      e.modifiersData[n] = { referenceClippingOffsets: f, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: m }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": m });
    }
    var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
    function en(t, e, n) {
      var r = q(t), o = [P, E].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a = i[0], s = i[1];
      return a = a || 0, s = (s || 0) * o, [P, W].indexOf(r) >= 0 ? { x: s, y: a } : { x: a, y: s };
    }
    function tn(t) {
      var e = t.state, n = t.options, r = t.name, o = n.offset, i = o === void 0 ? [0, 0] : o, a = Ee.reduce(function(u, m) {
        return u[m] = en(m, e.rects, i), u;
      }, {}), s = a[e.placement], f = s.x, c = s.y;
      e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = a;
    }
    var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
    function nn(t) {
      var e = t.state, n = t.name;
      e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
    }
    var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
    function rn(t) {
      return t === "x" ? "y" : "x";
    }
    function on(t) {
      var e = t.state, n = t.options, r = t.name, o = n.mainAxis, i = o === void 0 ? true : o, a = n.altAxis, s = a === void 0 ? false : a, f = n.boundary, c = n.rootBoundary, u = n.altBoundary, m = n.padding, v = n.tether, l = v === void 0 ? true : v, h2 = n.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f, rootBoundary: c, padding: m, altBoundary: u }), x = q(e.placement), y = te(e.placement), $ = !y, d = Le(x), b = rn(d), w = e.modifiersData.popperOffsets, O = e.rects.reference, j = e.rects.popper, A = typeof p2 == "function" ? p2(Object.assign({}, e.rects, { placement: e.placement })) : p2, k = typeof A == "number" ? { mainAxis: A, altAxis: A } : Object.assign({ mainAxis: 0, altAxis: 0 }, A), D = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S = { x: 0, y: 0 };
      if (w) {
        if (i) {
          var L, re = d === "y" ? E : P, oe = d === "y" ? R : W, M = d === "y" ? "height" : "width", T = w[d], pe = T + g[re], _ = T - g[oe], ue = l ? -j[M] / 2 : 0, xe = y === U ? O[M] : j[M], ie = y === U ? -j[M] : -O[M], le = e.elements.arrow, z = l && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y = fe(0, O[M], z[M]), jt = $ ? O[M] / 2 - ue - Y - de - k.mainAxis : xe - Y - de - k.mainAxis, Dt = $ ? -O[M] / 2 + ue + Y + ae + k.mainAxis : ie + Y + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D == null ? void 0 : D[d]) != null ? L : 0, Pt = T + jt - Ce - Et, At = T + Dt - Ce, qe = fe(l ? ve(pe, Pt) : pe, T, l ? X(_, At) : _);
          w[d] = qe, S[d] = qe - T;
        }
        if (s) {
          var Ve, kt = d === "x" ? E : P, Lt = d === "x" ? R : W, F = w[b], he = b === "y" ? "height" : "width", Ne = F + g[kt], Ie = F - g[Lt], $e = [E, P].indexOf(x) !== -1, _e = (Ve = D == null ? void 0 : D[b]) != null ? Ve : 0, ze = $e ? Ne : F - O[he] - j[he] - _e + k.altAxis, Fe = $e ? F + O[he] + j[he] - _e - k.altAxis : Ie, Ue = l && $e ? St(ze, F, Fe) : fe(l ? ze : Ne, F, l ? Fe : Ie);
          w[b] = Ue, S[b] = Ue - F;
        }
        e.modifiersData[r] = S;
      }
    }
    var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
    function an(t) {
      return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
    }
    function sn(t) {
      return t === H(t) || !B(t) ? We(t) : an(t);
    }
    function fn(t) {
      var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
      return n !== 1 || r !== 1;
    }
    function cn(t, e, n) {
      n === void 0 && (n = false);
      var r = B(e), o = B(e) && fn(e), i = I(e), a = ee(t, o), s = { scrollLeft: 0, scrollTop: 0 }, f = { x: 0, y: 0 };
      return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s = sn(e)), B(e) ? (f = ee(e, true), f.x += e.clientLeft, f.y += e.clientTop) : i && (f.x = Be(i))), { x: a.left + s.scrollLeft - f.x, y: a.top + s.scrollTop - f.y, width: a.width, height: a.height };
    }
    function pn(t) {
      var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
      t.forEach(function(i) {
        e.set(i.name, i);
      });
      function o(i) {
        n.add(i.name);
        var a = [].concat(i.requires || [], i.requiresIfExists || []);
        a.forEach(function(s) {
          if (!n.has(s)) {
            var f = e.get(s);
            f && o(f);
          }
        }), r.push(i);
      }
      return t.forEach(function(i) {
        n.has(i.name) || o(i);
      }), r;
    }
    function un(t) {
      var e = pn(t);
      return ot.reduce(function(n, r) {
        return n.concat(e.filter(function(o) {
          return o.phase === r;
        }));
      }, []);
    }
    function ln(t) {
      var e;
      return function() {
        return e || (e = new Promise(function(n) {
          Promise.resolve().then(function() {
            e = void 0, n(t());
          });
        })), e;
      };
    }
    function dn(t) {
      var e = t.reduce(function(n, r) {
        var o = n[r.name];
        return n[r.name] = o ? Object.assign({}, o, r, { options: Object.assign({}, o.options, r.options), data: Object.assign({}, o.data, r.data) }) : r, n;
      }, {});
      return Object.keys(e).map(function(n) {
        return e[n];
      });
    }
    var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
    function $t() {
      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
        e[n] = arguments[n];
      return !e.some(function(r) {
        return !(r && typeof r.getBoundingClientRect == "function");
      });
    }
    function we(t) {
      t === void 0 && (t = {});
      var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o = e.defaultOptions, i = o === void 0 ? Ot : o;
      return function(a, s, f) {
        f === void 0 && (f = i);
        var c = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a, popper: s }, attributes: {}, styles: {} }, u = [], m = false, v = { state: c, setOptions: function(p2) {
          var g = typeof p2 == "function" ? p2(c.options) : p2;
          h2(), c.options = Object.assign({}, i, c.options, g), c.scrollParents = { reference: Q(a) ? ce(a) : a.contextElement ? ce(a.contextElement) : [], popper: ce(s) };
          var x = un(dn([].concat(r, c.options.modifiers)));
          return c.orderedModifiers = x.filter(function(y) {
            return y.enabled;
          }), l(), v.update();
        }, forceUpdate: function() {
          if (!m) {
            var p2 = c.elements, g = p2.reference, x = p2.popper;
            if ($t(g, x)) {
              c.rects = { reference: cn(g, se(x), c.options.strategy === "fixed"), popper: ke(x) }, c.reset = false, c.placement = c.options.placement, c.orderedModifiers.forEach(function(j) {
                return c.modifiersData[j.name] = Object.assign({}, j.data);
              });
              for (var y = 0; y < c.orderedModifiers.length; y++) {
                if (c.reset === true) {
                  c.reset = false, y = -1;
                  continue;
                }
                var $ = c.orderedModifiers[y], d = $.fn, b = $.options, w = b === void 0 ? {} : b, O = $.name;
                typeof d == "function" && (c = d({ state: c, options: w, name: O, instance: v }) || c);
              }
            }
          }
        }, update: ln(function() {
          return new Promise(function(p2) {
            v.forceUpdate(), p2(c);
          });
        }), destroy: function() {
          h2(), m = true;
        } };
        if (!$t(a, s))
          return v;
        v.setOptions(f).then(function(p2) {
          !m && f.onFirstUpdate && f.onFirstUpdate(p2);
        });
        function l() {
          c.orderedModifiers.forEach(function(p2) {
            var g = p2.name, x = p2.options, y = x === void 0 ? {} : x, $ = p2.effect;
            if (typeof $ == "function") {
              var d = $({ state: c, name: g, instance: v, options: y }), b = function() {
              };
              u.push(d || b);
            }
          });
        }
        function h2() {
          u.forEach(function(p2) {
            return p2();
          }), u = [];
        }
        return v;
      };
    }
    we();
    var mn = [Re, He, Me, Ae];
    we({ defaultModifiers: mn });
    var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
    const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
      const stateUpdater = {
        name: "updateState",
        enabled: true,
        phase: "write",
        fn: ({ state }) => {
          const derivedState = deriveState(state);
          Object.assign(states.value, derivedState);
        },
        requires: ["computeStyles"]
      };
      const options = computed(() => {
        const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
        return {
          onFirstUpdate,
          placement: placement || "bottom",
          strategy: strategy || "absolute",
          modifiers: [
            ...modifiers || [],
            stateUpdater,
            { name: "applyStyles", enabled: false }
          ]
        };
      });
      const instanceRef = shallowRef();
      const states = ref({
        styles: {
          popper: {
            position: unref(options).strategy,
            left: "0",
            top: "0"
          },
          arrow: {
            position: "absolute"
          }
        },
        attributes: {}
      });
      const destroy = () => {
        if (!instanceRef.value)
          return;
        instanceRef.value.destroy();
        instanceRef.value = void 0;
      };
      watch(options, (newOptions) => {
        const instance = unref(instanceRef);
        if (instance) {
          instance.setOptions(newOptions);
        }
      }, {
        deep: true
      });
      watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
        destroy();
        if (!referenceElement || !popperElement)
          return;
        instanceRef.value = yn(referenceElement, popperElement, unref(options));
      });
      onBeforeUnmount(() => {
        destroy();
      });
      return {
        state: computed(() => {
          var _a2;
          return { ...((_a2 = unref(instanceRef)) == null ? void 0 : _a2.state) || {} };
        }),
        styles: computed(() => unref(states).styles),
        attributes: computed(() => unref(states).attributes),
        update: () => {
          var _a2;
          return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.update();
        },
        forceUpdate: () => {
          var _a2;
          return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.forceUpdate();
        },
        instanceRef: computed(() => unref(instanceRef))
      };
    };
    function deriveState(state) {
      const elements = Object.keys(state.elements);
      const styles = fromPairs(elements.map((element) => [element, state.styles[element] || {}]));
      const attributes = fromPairs(elements.map((element) => [element, state.attributes[element]]));
      return {
        styles,
        attributes
      };
    }
    function useTimeout() {
      let timeoutHandle;
      const registerTimeout = (fn2, delay) => {
        cancelTimeout();
        timeoutHandle = window.setTimeout(fn2, delay);
      };
      const cancelTimeout = () => window.clearTimeout(timeoutHandle);
      tryOnScopeDispose(() => cancelTimeout());
      return {
        registerTimeout,
        cancelTimeout
      };
    }
    const defaultIdInjection = {
      prefix: Math.floor(Math.random() * 1e4),
      current: 0
    };
    const ID_INJECTION_KEY = Symbol("elIdInjection");
    const useIdInjection = () => {
      return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
    };
    const useId = (deterministicId) => {
      const idInjection = useIdInjection();
      if (!isClient && idInjection === defaultIdInjection) {
        debugWarn("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
      }
      const namespace = useGetDerivedNamespace();
      const idRef = computed(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
      return idRef;
    };
    let registeredEscapeHandlers = [];
    const cachedHandler = (e) => {
      const event = e;
      if (event.key === EVENT_CODE.esc) {
        registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
      }
    };
    const useEscapeKeydown = (handler) => {
      onMounted(() => {
        if (registeredEscapeHandlers.length === 0) {
          document.addEventListener("keydown", cachedHandler);
        }
        if (isClient)
          registeredEscapeHandlers.push(handler);
      });
      onBeforeUnmount(() => {
        registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
        if (registeredEscapeHandlers.length === 0) {
          if (isClient)
            document.removeEventListener("keydown", cachedHandler);
        }
      });
    };
    let cachedContainer;
    const usePopperContainerId = () => {
      const namespace = useGetDerivedNamespace();
      const idInjection = useIdInjection();
      const id = computed(() => {
        return `${namespace.value}-popper-container-${idInjection.prefix}`;
      });
      const selector = computed(() => `#${id.value}`);
      return {
        id,
        selector
      };
    };
    const createContainer = (id) => {
      const container = document.createElement("div");
      container.id = id;
      document.body.appendChild(container);
      return container;
    };
    const usePopperContainer = () => {
      const { id, selector } = usePopperContainerId();
      onBeforeMount(() => {
        if (!isClient)
          return;
        if (!cachedContainer && !document.body.querySelector(selector.value)) {
          cachedContainer = createContainer(id.value);
        }
      });
      return {
        id,
        selector
      };
    };
    const useDelayedToggleProps = buildProps({
      showAfter: {
        type: Number,
        default: 0
      },
      hideAfter: {
        type: Number,
        default: 200
      },
      autoClose: {
        type: Number,
        default: 0
      }
    });
    const useDelayedToggle = ({
      showAfter,
      hideAfter,
      autoClose,
      open,
      close
    }) => {
      const { registerTimeout } = useTimeout();
      const {
        registerTimeout: registerTimeoutForAutoClose,
        cancelTimeout: cancelTimeoutForAutoClose
      } = useTimeout();
      const onOpen = (event) => {
        registerTimeout(() => {
          open(event);
          const _autoClose = unref(autoClose);
          if (isNumber(_autoClose) && _autoClose > 0) {
            registerTimeoutForAutoClose(() => {
              close(event);
            }, _autoClose);
          }
        }, unref(showAfter));
      };
      const onClose = (event) => {
        cancelTimeoutForAutoClose();
        registerTimeout(() => {
          close(event);
        }, unref(hideAfter));
      };
      return {
        onOpen,
        onClose
      };
    };
    const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
    const useForwardRef = (forwardRef) => {
      const setForwardRef = (el) => {
        forwardRef.value = el;
      };
      provide(FORWARD_REF_INJECTION_KEY, {
        setForwardRef
      });
    };
    const useForwardRefDirective = (setForwardRef) => {
      return {
        mounted(el) {
          setForwardRef(el);
        },
        updated(el) {
          setForwardRef(el);
        },
        unmounted() {
          setForwardRef(null);
        }
      };
    };
    const zIndex = ref(0);
    const defaultInitialZIndex = 2e3;
    const zIndexContextKey = Symbol("zIndexContextKey");
    const useZIndex = (zIndexOverrides) => {
      const zIndexInjection = zIndexOverrides || (getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0);
      const initialZIndex = computed(() => {
        const zIndexFromInjection = unref(zIndexInjection);
        return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
      });
      const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
      const nextZIndex = () => {
        zIndex.value++;
        return currentZIndex.value;
      };
      return {
        initialZIndex,
        currentZIndex,
        nextZIndex
      };
    };
    function useCursor(input) {
      const selectionRef = ref();
      function recordCursor() {
        if (input.value == void 0)
          return;
        const { selectionStart, selectionEnd, value } = input.value;
        if (selectionStart == null || selectionEnd == null)
          return;
        const beforeTxt = value.slice(0, Math.max(0, selectionStart));
        const afterTxt = value.slice(Math.max(0, selectionEnd));
        selectionRef.value = {
          selectionStart,
          selectionEnd,
          value,
          beforeTxt,
          afterTxt
        };
      }
      function setCursor() {
        if (input.value == void 0 || selectionRef.value == void 0)
          return;
        const { value } = input.value;
        const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
        if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
          return;
        let startPos = value.length;
        if (value.endsWith(afterTxt)) {
          startPos = value.length - afterTxt.length;
        } else if (value.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else {
          const beforeLastChar = beforeTxt[selectionStart - 1];
          const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        input.value.setSelectionRange(startPos, startPos);
      }
      return [recordCursor, setCursor];
    }
    const useSizeProp = buildProp({
      type: String,
      values: componentSizes,
      required: false
    });
    const SIZE_INJECTION_KEY = Symbol("size");
    const useGlobalSize = () => {
      const injectedSize = inject(SIZE_INJECTION_KEY, {});
      return computed(() => {
        return unref(injectedSize.size) || "";
      });
    };
    function useFocusController(target, { afterFocus, beforeBlur, afterBlur } = {}) {
      const instance = getCurrentInstance();
      const { emit: emit2 } = instance;
      const wrapperRef = shallowRef();
      const isFocused = ref(false);
      const handleFocus = (event) => {
        if (isFocused.value)
          return;
        isFocused.value = true;
        emit2("focus", event);
        afterFocus == null ? void 0 : afterFocus();
      };
      const handleBlur = (event) => {
        var _a2;
        const cancelBlur = isFunction$1(beforeBlur) ? beforeBlur(event) : false;
        if (cancelBlur || event.relatedTarget && ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(event.relatedTarget)))
          return;
        isFocused.value = false;
        emit2("blur", event);
        afterBlur == null ? void 0 : afterBlur();
      };
      const handleClick = () => {
        var _a2;
        (_a2 = target.value) == null ? void 0 : _a2.focus();
      };
      watch(wrapperRef, (el) => {
        if (el) {
          el.setAttribute("tabindex", "-1");
        }
      });
      useEventListener(wrapperRef, "click", handleClick);
      return {
        wrapperRef,
        isFocused,
        handleFocus,
        handleBlur
      };
    }
    const configProviderContextKey = Symbol();
    const globalConfig = ref();
    function useGlobalConfig(key, defaultValue = void 0) {
      const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
      if (key) {
        return computed(() => {
          var _a2, _b;
          return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
        });
      } else {
        return config;
      }
    }
    var _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const iconProps = buildProps({
      size: {
        type: definePropType([Number, String])
      },
      color: {
        type: String
      }
    });
    const __default__$k = /* @__PURE__ */ defineComponent({
      name: "ElIcon",
      inheritAttrs: false
    });
    const _sfc_main$E = /* @__PURE__ */ defineComponent({
      ...__default__$k,
      props: iconProps,
      setup(__props) {
        const props = __props;
        const ns = useNamespace("icon");
        const style = computed(() => {
          const { size: size2, color } = props;
          if (!size2 && !color)
            return {};
          return {
            fontSize: isUndefined(size2) ? void 0 : addUnit(size2),
            "--color": color
          };
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("i", mergeProps({
            class: unref(ns).b(),
            style: unref(style)
          }, _ctx.$attrs), [
            renderSlot(_ctx.$slots, "default")
          ], 16);
        };
      }
    });
    var Icon = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["__file", "icon.vue"]]);
    const ElIcon = withInstall(Icon);
    const formContextKey = Symbol("formContextKey");
    const formItemContextKey = Symbol("formItemContextKey");
    const useFormSize = (fallback, ignore = {}) => {
      const emptyRef = ref(void 0);
      const size2 = ignore.prop ? emptyRef : useProp("size");
      const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
      const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
      const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
      return computed(() => size2.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
    };
    const useFormDisabled = (fallback) => {
      const disabled = useProp("disabled");
      const form = inject(formContextKey, void 0);
      return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
    };
    const useFormItem = () => {
      const form = inject(formContextKey, void 0);
      const formItem = inject(formItemContextKey, void 0);
      return {
        form,
        formItem
      };
    };
    const useFormItemInputId = (props, {
      formItemContext,
      disableIdGeneration,
      disableIdManagement
    }) => {
      if (!disableIdGeneration) {
        disableIdGeneration = ref(false);
      }
      if (!disableIdManagement) {
        disableIdManagement = ref(false);
      }
      const inputId = ref();
      let idUnwatch = void 0;
      const isLabeledByFormItem = computed(() => {
        var _a2;
        return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
      });
      onMounted(() => {
        idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
          const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
          if (newId !== inputId.value) {
            if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
              inputId.value && formItemContext.removeInputId(inputId.value);
              if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                formItemContext.addInputId(newId);
              }
            }
            inputId.value = newId;
          }
        }, { immediate: true });
      });
      onUnmounted(() => {
        idUnwatch && idUnwatch();
        if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
          inputId.value && formItemContext.removeInputId(inputId.value);
        }
      });
      return {
        isLabeledByFormItem,
        inputId
      };
    };
    let hiddenTextarea = void 0;
    const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
    const CONTEXT_STYLE = [
      "letter-spacing",
      "line-height",
      "padding-top",
      "padding-bottom",
      "font-family",
      "font-weight",
      "font-size",
      "text-rendering",
      "text-transform",
      "width",
      "text-indent",
      "padding-left",
      "padding-right",
      "border-width",
      "box-sizing"
    ];
    function calculateNodeStyling(targetElement) {
      const style = window.getComputedStyle(targetElement);
      const boxSizing = style.getPropertyValue("box-sizing");
      const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
      const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
      const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
      return { contextStyle, paddingSize, borderSize, boxSizing };
    }
    function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
      var _a2;
      if (!hiddenTextarea) {
        hiddenTextarea = document.createElement("textarea");
        document.body.appendChild(hiddenTextarea);
      }
      const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
      hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
      hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
      let height = hiddenTextarea.scrollHeight;
      const result = {};
      if (boxSizing === "border-box") {
        height = height + borderSize;
      } else if (boxSizing === "content-box") {
        height = height - paddingSize;
      }
      hiddenTextarea.value = "";
      const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
      if (isNumber(minRows)) {
        let minHeight = singleRowHeight * minRows;
        if (boxSizing === "border-box") {
          minHeight = minHeight + paddingSize + borderSize;
        }
        height = Math.max(minHeight, height);
        result.minHeight = `${minHeight}px`;
      }
      if (isNumber(maxRows)) {
        let maxHeight = singleRowHeight * maxRows;
        if (boxSizing === "border-box") {
          maxHeight = maxHeight + paddingSize + borderSize;
        }
        height = Math.min(maxHeight, height);
      }
      result.height = `${height}px`;
      (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
      hiddenTextarea = void 0;
      return result;
    }
    const inputProps = buildProps({
      id: {
        type: String,
        default: void 0
      },
      size: useSizeProp,
      disabled: Boolean,
      modelValue: {
        type: definePropType([
          String,
          Number,
          Object
        ]),
        default: ""
      },
      maxlength: {
        type: [String, Number]
      },
      minlength: {
        type: [String, Number]
      },
      type: {
        type: String,
        default: "text"
      },
      resize: {
        type: String,
        values: ["none", "both", "horizontal", "vertical"]
      },
      autosize: {
        type: definePropType([Boolean, Object]),
        default: false
      },
      autocomplete: {
        type: String,
        default: "off"
      },
      formatter: {
        type: Function
      },
      parser: {
        type: Function
      },
      placeholder: {
        type: String
      },
      form: {
        type: String
      },
      readonly: {
        type: Boolean,
        default: false
      },
      clearable: {
        type: Boolean,
        default: false
      },
      showPassword: {
        type: Boolean,
        default: false
      },
      showWordLimit: {
        type: Boolean,
        default: false
      },
      suffixIcon: {
        type: iconPropType
      },
      prefixIcon: {
        type: iconPropType
      },
      containerRole: {
        type: String,
        default: void 0
      },
      label: {
        type: String,
        default: void 0
      },
      tabindex: {
        type: [String, Number],
        default: 0
      },
      validateEvent: {
        type: Boolean,
        default: true
      },
      inputStyle: {
        type: definePropType([Object, Array, String]),
        default: () => mutable({})
      },
      autofocus: {
        type: Boolean,
        default: false
      }
    });
    const inputEmits = {
      [UPDATE_MODEL_EVENT]: (value) => isString$2(value),
      input: (value) => isString$2(value),
      change: (value) => isString$2(value),
      focus: (evt) => evt instanceof FocusEvent,
      blur: (evt) => evt instanceof FocusEvent,
      clear: () => true,
      mouseleave: (evt) => evt instanceof MouseEvent,
      mouseenter: (evt) => evt instanceof MouseEvent,
      keydown: (evt) => evt instanceof Event,
      compositionstart: (evt) => evt instanceof CompositionEvent,
      compositionupdate: (evt) => evt instanceof CompositionEvent,
      compositionend: (evt) => evt instanceof CompositionEvent
    };
    const _hoisted_1$j = ["role"];
    const _hoisted_2$f = ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus"];
    const _hoisted_3$8 = ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus"];
    const __default__$j = /* @__PURE__ */ defineComponent({
      name: "ElInput",
      inheritAttrs: false
    });
    const _sfc_main$D = /* @__PURE__ */ defineComponent({
      ...__default__$j,
      props: inputProps,
      emits: inputEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const rawAttrs = useAttrs$1();
        const slots = useSlots();
        const containerAttrs = computed(() => {
          const comboBoxAttrs = {};
          if (props.containerRole === "combobox") {
            comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
            comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
            comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
          }
          return comboBoxAttrs;
        });
        const containerKls = computed(() => [
          props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
          nsInput.m(inputSize.value),
          nsInput.is("disabled", inputDisabled.value),
          nsInput.is("exceed", inputExceed.value),
          {
            [nsInput.b("group")]: slots.prepend || slots.append,
            [nsInput.bm("group", "append")]: slots.append,
            [nsInput.bm("group", "prepend")]: slots.prepend,
            [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
            [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
            [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value
          },
          rawAttrs.class
        ]);
        const wrapperKls = computed(() => [
          nsInput.e("wrapper"),
          nsInput.is("focus", isFocused.value)
        ]);
        const attrs = useAttrs({
          excludeKeys: computed(() => {
            return Object.keys(containerAttrs.value);
          })
        });
        const { form: elForm, formItem: elFormItem } = useFormItem();
        const { inputId } = useFormItemInputId(props, {
          formItemContext: elFormItem
        });
        const inputSize = useFormSize();
        const inputDisabled = useFormDisabled();
        const nsInput = useNamespace("input");
        const nsTextarea = useNamespace("textarea");
        const input = shallowRef();
        const textarea = shallowRef();
        const hovering = ref(false);
        const isComposing = ref(false);
        const passwordVisible = ref(false);
        const countStyle = ref();
        const textareaCalcStyle = shallowRef(props.inputStyle);
        const _ref = computed(() => input.value || textarea.value);
        const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
          afterBlur() {
            var _a2;
            if (props.validateEvent) {
              (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "blur").catch((err) => debugWarn(err));
            }
          }
        });
        const needStatusIcon = computed(() => {
          var _a2;
          return (_a2 = elForm == null ? void 0 : elForm.statusIcon) != null ? _a2 : false;
        });
        const validateState = computed(() => (elFormItem == null ? void 0 : elFormItem.validateState) || "");
        const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
        const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
        const containerStyle = computed(() => [
          rawAttrs.style
        ]);
        const textareaStyle = computed(() => [
          props.inputStyle,
          textareaCalcStyle.value,
          { resize: props.resize }
        ]);
        const nativeInputValue = computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
        const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
        const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
        const isWordLimitVisible = computed(() => props.showWordLimit && !!props.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
        const textLength = computed(() => nativeInputValue.value.length);
        const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(props.maxlength));
        const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
        const [recordCursor, setCursor] = useCursor(input);
        useResizeObserver(textarea, (entries) => {
          onceInitSizeTextarea();
          if (!isWordLimitVisible.value || props.resize !== "both")
            return;
          const entry = entries[0];
          const { width } = entry.contentRect;
          countStyle.value = {
            right: `calc(100% - ${width + 15 + 6}px)`
          };
        });
        const resizeTextarea = () => {
          const { type, autosize } = props;
          if (!isClient || type !== "textarea" || !textarea.value)
            return;
          if (autosize) {
            const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
            const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
            const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
            textareaCalcStyle.value = {
              overflowY: "hidden",
              ...textareaStyle2
            };
            nextTick(() => {
              textarea.value.offsetHeight;
              textareaCalcStyle.value = textareaStyle2;
            });
          } else {
            textareaCalcStyle.value = {
              minHeight: calcTextareaHeight(textarea.value).minHeight
            };
          }
        };
        const createOnceInitResize = (resizeTextarea2) => {
          let isInit = false;
          return () => {
            var _a2;
            if (isInit || !props.autosize)
              return;
            const isElHidden = ((_a2 = textarea.value) == null ? void 0 : _a2.offsetParent) === null;
            if (!isElHidden) {
              resizeTextarea2();
              isInit = true;
            }
          };
        };
        const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
        const setNativeInputValue = () => {
          const input2 = _ref.value;
          const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
          if (!input2 || input2.value === formatterValue)
            return;
          input2.value = formatterValue;
        };
        const handleInput = async (event) => {
          recordCursor();
          let { value } = event.target;
          if (props.formatter) {
            value = props.parser ? props.parser(value) : value;
          }
          if (isComposing.value)
            return;
          if (value === nativeInputValue.value) {
            setNativeInputValue();
            return;
          }
          emit2(UPDATE_MODEL_EVENT, value);
          emit2("input", value);
          await nextTick();
          setNativeInputValue();
          setCursor();
        };
        const handleChange = (event) => {
          emit2("change", event.target.value);
        };
        const handleCompositionStart = (event) => {
          emit2("compositionstart", event);
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          var _a2;
          emit2("compositionupdate", event);
          const text = (_a2 = event.target) == null ? void 0 : _a2.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          emit2("compositionend", event);
          if (isComposing.value) {
            isComposing.value = false;
            handleInput(event);
          }
        };
        const handlePasswordVisible = () => {
          passwordVisible.value = !passwordVisible.value;
          focus();
        };
        const focus = async () => {
          var _a2;
          await nextTick();
          (_a2 = _ref.value) == null ? void 0 : _a2.focus();
        };
        const blur = () => {
          var _a2;
          return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
        };
        const handleMouseLeave = (evt) => {
          hovering.value = false;
          emit2("mouseleave", evt);
        };
        const handleMouseEnter = (evt) => {
          hovering.value = true;
          emit2("mouseenter", evt);
        };
        const handleKeydown = (evt) => {
          emit2("keydown", evt);
        };
        const select = () => {
          var _a2;
          (_a2 = _ref.value) == null ? void 0 : _a2.select();
        };
        const clear2 = () => {
          emit2(UPDATE_MODEL_EVENT, "");
          emit2("change", "");
          emit2("clear");
          emit2("input", "");
        };
        watch(() => props.modelValue, () => {
          var _a2;
          nextTick(() => resizeTextarea());
          if (props.validateEvent) {
            (_a2 = elFormItem == null ? void 0 : elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn(err));
          }
        });
        watch(nativeInputValue, () => setNativeInputValue());
        watch(() => props.type, async () => {
          await nextTick();
          setNativeInputValue();
          resizeTextarea();
        });
        onMounted(() => {
          if (!props.formatter && props.parser) {
            debugWarn("ElInput", "If you set the parser, you also need to set the formatter.");
          }
          setNativeInputValue();
          nextTick(resizeTextarea);
        });
        expose({
          input,
          textarea,
          ref: _ref,
          textareaStyle,
          autosize: toRef(props, "autosize"),
          focus,
          blur,
          select,
          clear: clear2,
          resizeTextarea
        });
        return (_ctx, _cache) => {
          return withDirectives((openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
            class: unref(containerKls),
            style: unref(containerStyle),
            role: _ctx.containerRole,
            onMouseenter: handleMouseEnter,
            onMouseleave: handleMouseLeave
          }), [
            createCommentVNode(" input "),
            _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createCommentVNode(" prepend slot "),
              _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(nsInput).be("group", "prepend"))
              }, [
                renderSlot(_ctx.$slots, "prepend")
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                ref_key: "wrapperRef",
                ref: wrapperRef,
                class: normalizeClass(unref(wrapperKls))
              }, [
                createCommentVNode(" prefix slot "),
                _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).e("prefix"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(nsInput).e("prefix-inner"))
                  }, [
                    renderSlot(_ctx.$slots, "prefix"),
                    _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(nsInput).e("icon"))
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("input", mergeProps({
                  id: unref(inputId),
                  ref_key: "input",
                  ref: input,
                  class: unref(nsInput).e("inner")
                }, unref(attrs), {
                  minlength: _ctx.minlength,
                  maxlength: _ctx.maxlength,
                  type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                  disabled: unref(inputDisabled),
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  tabindex: _ctx.tabindex,
                  "aria-label": _ctx.label,
                  placeholder: _ctx.placeholder,
                  style: _ctx.inputStyle,
                  form: _ctx.form,
                  autofocus: _ctx.autofocus,
                  onCompositionstart: handleCompositionStart,
                  onCompositionupdate: handleCompositionUpdate,
                  onCompositionend: handleCompositionEnd,
                  onInput: handleInput,
                  onFocus: _cache[0] || (_cache[0] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                  onBlur: _cache[1] || (_cache[1] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, _hoisted_2$f),
                createCommentVNode(" suffix slot "),
                unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).e("suffix"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(nsInput).e("suffix-inner"))
                  }, [
                    !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      renderSlot(_ctx.$slots, "suffix"),
                      _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 64)) : createCommentVNode("v-if", true),
                    unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 1,
                      class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                      onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                      onClick: clear2
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(circle_close_default))
                      ]),
                      _: 1
                    }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                    unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 2,
                      class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                      onClick: handlePasswordVisible
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true),
                    unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                      key: 3,
                      class: normalizeClass(unref(nsInput).e("count"))
                    }, [
                      createBaseVNode("span", {
                        class: normalizeClass(unref(nsInput).e("count-inner"))
                      }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 3)
                    ], 2)) : createCommentVNode("v-if", true),
                    unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 4,
                      class: normalizeClass([
                        unref(nsInput).e("icon"),
                        unref(nsInput).e("validateIcon"),
                        unref(nsInput).is("loading", unref(validateState) === "validating")
                      ])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true)
              ], 2),
              createCommentVNode(" append slot "),
              _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(nsInput).be("group", "append"))
              }, [
                renderSlot(_ctx.$slots, "append")
              ], 2)) : createCommentVNode("v-if", true)
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createCommentVNode(" textarea "),
              createBaseVNode("textarea", mergeProps({
                id: unref(inputId),
                ref_key: "textarea",
                ref: textarea,
                class: unref(nsTextarea).e("inner")
              }, unref(attrs), {
                minlength: _ctx.minlength,
                maxlength: _ctx.maxlength,
                tabindex: _ctx.tabindex,
                disabled: unref(inputDisabled),
                readonly: _ctx.readonly,
                autocomplete: _ctx.autocomplete,
                style: unref(textareaStyle),
                "aria-label": _ctx.label,
                placeholder: _ctx.placeholder,
                form: _ctx.form,
                autofocus: _ctx.autofocus,
                onCompositionstart: handleCompositionStart,
                onCompositionupdate: handleCompositionUpdate,
                onCompositionend: handleCompositionEnd,
                onInput: handleInput,
                onFocus: _cache[2] || (_cache[2] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                onBlur: _cache[3] || (_cache[3] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                onChange: handleChange,
                onKeydown: handleKeydown
              }), null, 16, _hoisted_3$8),
              unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                key: 0,
                style: normalizeStyle(countStyle.value),
                class: normalizeClass(unref(nsInput).e("count"))
              }, toDisplayString(unref(textLength)) + " / " + toDisplayString(_ctx.maxlength), 7)) : createCommentVNode("v-if", true)
            ], 64))
          ], 16, _hoisted_1$j)), [
            [vShow, _ctx.type !== "hidden"]
          ]);
        };
      }
    });
    var Input = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["__file", "input.vue"]]);
    const ElInput = withInstall(Input);
    const GAP = 4;
    const BAR_MAP = {
      vertical: {
        offset: "offsetHeight",
        scroll: "scrollTop",
        scrollSize: "scrollHeight",
        size: "height",
        key: "vertical",
        axis: "Y",
        client: "clientY",
        direction: "top"
      },
      horizontal: {
        offset: "offsetWidth",
        scroll: "scrollLeft",
        scrollSize: "scrollWidth",
        size: "width",
        key: "horizontal",
        axis: "X",
        client: "clientX",
        direction: "left"
      }
    };
    const renderThumbStyle = ({
      move,
      size: size2,
      bar
    }) => ({
      [bar.size]: size2,
      transform: `translate${bar.axis}(${move}%)`
    });
    const scrollbarContextKey = Symbol("scrollbarContextKey");
    const thumbProps = buildProps({
      vertical: Boolean,
      size: String,
      move: Number,
      ratio: {
        type: Number,
        required: true
      },
      always: Boolean
    });
    const COMPONENT_NAME$3 = "Thumb";
    const _sfc_main$C = /* @__PURE__ */ defineComponent({
      __name: "thumb",
      props: thumbProps,
      setup(__props) {
        const props = __props;
        const scrollbar = inject(scrollbarContextKey);
        const ns = useNamespace("scrollbar");
        if (!scrollbar)
          throwError(COMPONENT_NAME$3, "can not inject scrollbar context");
        const instance = ref();
        const thumb = ref();
        const thumbState = ref({});
        const visible = ref(false);
        let cursorDown = false;
        let cursorLeave = false;
        let originalOnSelectStart = isClient ? document.onselectstart : null;
        const bar = computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
        const thumbStyle = computed(() => renderThumbStyle({
          size: props.size,
          move: props.move,
          bar: bar.value
        }));
        const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
        const clickThumbHandler = (e) => {
          var _a2;
          e.stopPropagation();
          if (e.ctrlKey || [1, 2].includes(e.button))
            return;
          (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
          startDrag(e);
          const el = e.currentTarget;
          if (!el)
            return;
          thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
        };
        const clickTrackHandler = (e) => {
          if (!thumb.value || !instance.value || !scrollbar.wrapElement)
            return;
          const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
          const thumbHalf = thumb.value[bar.value.offset] / 2;
          const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
          scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
        };
        const startDrag = (e) => {
          e.stopImmediatePropagation();
          cursorDown = true;
          document.addEventListener("mousemove", mouseMoveDocumentHandler);
          document.addEventListener("mouseup", mouseUpDocumentHandler);
          originalOnSelectStart = document.onselectstart;
          document.onselectstart = () => false;
        };
        const mouseMoveDocumentHandler = (e) => {
          if (!instance.value || !thumb.value)
            return;
          if (cursorDown === false)
            return;
          const prevPage = thumbState.value[bar.value.axis];
          if (!prevPage)
            return;
          const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
          const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
          const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
          scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
        };
        const mouseUpDocumentHandler = () => {
          cursorDown = false;
          thumbState.value[bar.value.axis] = 0;
          document.removeEventListener("mousemove", mouseMoveDocumentHandler);
          document.removeEventListener("mouseup", mouseUpDocumentHandler);
          restoreOnselectstart();
          if (cursorLeave)
            visible.value = false;
        };
        const mouseMoveScrollbarHandler = () => {
          cursorLeave = false;
          visible.value = !!props.size;
        };
        const mouseLeaveScrollbarHandler = () => {
          cursorLeave = true;
          visible.value = cursorDown;
        };
        onBeforeUnmount(() => {
          restoreOnselectstart();
          document.removeEventListener("mouseup", mouseUpDocumentHandler);
        });
        const restoreOnselectstart = () => {
          if (document.onselectstart !== originalOnSelectStart)
            document.onselectstart = originalOnSelectStart;
        };
        useEventListener(toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
        useEventListener(toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Transition, {
            name: unref(ns).b("fade"),
            persisted: ""
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", {
                ref_key: "instance",
                ref: instance,
                class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
                onMousedown: clickTrackHandler
              }, [
                createBaseVNode("div", {
                  ref_key: "thumb",
                  ref: thumb,
                  class: normalizeClass(unref(ns).e("thumb")),
                  style: normalizeStyle(unref(thumbStyle)),
                  onMousedown: clickThumbHandler
                }, null, 38)
              ], 34), [
                [vShow, _ctx.always || visible.value]
              ])
            ]),
            _: 1
          }, 8, ["name"]);
        };
      }
    });
    var Thumb = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["__file", "thumb.vue"]]);
    const barProps = buildProps({
      always: {
        type: Boolean,
        default: true
      },
      width: String,
      height: String,
      ratioX: {
        type: Number,
        default: 1
      },
      ratioY: {
        type: Number,
        default: 1
      }
    });
    const _sfc_main$B = /* @__PURE__ */ defineComponent({
      __name: "bar",
      props: barProps,
      setup(__props, { expose }) {
        const props = __props;
        const moveX = ref(0);
        const moveY = ref(0);
        const handleScroll = (wrap) => {
          if (wrap) {
            const offsetHeight = wrap.offsetHeight - GAP;
            const offsetWidth = wrap.offsetWidth - GAP;
            moveY.value = wrap.scrollTop * 100 / offsetHeight * props.ratioY;
            moveX.value = wrap.scrollLeft * 100 / offsetWidth * props.ratioX;
          }
        };
        expose({
          handleScroll
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(Thumb, {
              move: moveX.value,
              ratio: _ctx.ratioX,
              size: _ctx.width,
              always: _ctx.always
            }, null, 8, ["move", "ratio", "size", "always"]),
            createVNode(Thumb, {
              move: moveY.value,
              ratio: _ctx.ratioY,
              size: _ctx.height,
              vertical: "",
              always: _ctx.always
            }, null, 8, ["move", "ratio", "size", "always"])
          ], 64);
        };
      }
    });
    var Bar = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["__file", "bar.vue"]]);
    const scrollbarProps = buildProps({
      height: {
        type: [String, Number],
        default: ""
      },
      maxHeight: {
        type: [String, Number],
        default: ""
      },
      native: {
        type: Boolean,
        default: false
      },
      wrapStyle: {
        type: definePropType([String, Object, Array]),
        default: ""
      },
      wrapClass: {
        type: [String, Array],
        default: ""
      },
      viewClass: {
        type: [String, Array],
        default: ""
      },
      viewStyle: {
        type: [String, Array, Object],
        default: ""
      },
      noresize: Boolean,
      tag: {
        type: String,
        default: "div"
      },
      always: Boolean,
      minSize: {
        type: Number,
        default: 20
      },
      id: String,
      role: String,
      ariaLabel: String,
      ariaOrientation: {
        type: String,
        values: ["horizontal", "vertical"]
      }
    });
    const scrollbarEmits = {
      scroll: ({
        scrollTop,
        scrollLeft
      }) => [scrollTop, scrollLeft].every(isNumber)
    };
    const COMPONENT_NAME$2 = "ElScrollbar";
    const __default__$i = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME$2
    });
    const _sfc_main$A = /* @__PURE__ */ defineComponent({
      ...__default__$i,
      props: scrollbarProps,
      emits: scrollbarEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const ns = useNamespace("scrollbar");
        let stopResizeObserver = void 0;
        let stopResizeListener = void 0;
        const scrollbarRef = ref();
        const wrapRef = ref();
        const resizeRef = ref();
        const sizeWidth = ref("0");
        const sizeHeight = ref("0");
        const barRef = ref();
        const ratioY = ref(1);
        const ratioX = ref(1);
        const wrapStyle = computed(() => {
          const style = {};
          if (props.height)
            style.height = addUnit(props.height);
          if (props.maxHeight)
            style.maxHeight = addUnit(props.maxHeight);
          return [props.wrapStyle, style];
        });
        const wrapKls = computed(() => {
          return [
            props.wrapClass,
            ns.e("wrap"),
            { [ns.em("wrap", "hidden-default")]: !props.native }
          ];
        });
        const resizeKls = computed(() => {
          return [ns.e("view"), props.viewClass];
        });
        const handleScroll = () => {
          var _a2;
          if (wrapRef.value) {
            (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
            emit2("scroll", {
              scrollTop: wrapRef.value.scrollTop,
              scrollLeft: wrapRef.value.scrollLeft
            });
          }
        };
        function scrollTo(arg1, arg2) {
          if (isObject$1(arg1)) {
            wrapRef.value.scrollTo(arg1);
          } else if (isNumber(arg1) && isNumber(arg2)) {
            wrapRef.value.scrollTo(arg1, arg2);
          }
        }
        const setScrollTop = (value) => {
          if (!isNumber(value)) {
            debugWarn(COMPONENT_NAME$2, "value must be a number");
            return;
          }
          wrapRef.value.scrollTop = value;
        };
        const setScrollLeft = (value) => {
          if (!isNumber(value)) {
            debugWarn(COMPONENT_NAME$2, "value must be a number");
            return;
          }
          wrapRef.value.scrollLeft = value;
        };
        const update = () => {
          if (!wrapRef.value)
            return;
          const offsetHeight = wrapRef.value.offsetHeight - GAP;
          const offsetWidth = wrapRef.value.offsetWidth - GAP;
          const originalHeight = offsetHeight ** 2 / wrapRef.value.scrollHeight;
          const originalWidth = offsetWidth ** 2 / wrapRef.value.scrollWidth;
          const height = Math.max(originalHeight, props.minSize);
          const width = Math.max(originalWidth, props.minSize);
          ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
          ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
          sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
          sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
        };
        watch(() => props.noresize, (noresize) => {
          if (noresize) {
            stopResizeObserver == null ? void 0 : stopResizeObserver();
            stopResizeListener == null ? void 0 : stopResizeListener();
          } else {
            ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
            stopResizeListener = useEventListener("resize", update);
          }
        }, { immediate: true });
        watch(() => [props.maxHeight, props.height], () => {
          if (!props.native)
            nextTick(() => {
              var _a2;
              update();
              if (wrapRef.value) {
                (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
              }
            });
        });
        provide(scrollbarContextKey, reactive({
          scrollbarElement: scrollbarRef,
          wrapElement: wrapRef
        }));
        onMounted(() => {
          if (!props.native)
            nextTick(() => {
              update();
            });
        });
        onUpdated(() => update());
        expose({
          wrapRef,
          update,
          scrollTo,
          setScrollTop,
          setScrollLeft,
          handleScroll
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "scrollbarRef",
            ref: scrollbarRef,
            class: normalizeClass(unref(ns).b())
          }, [
            createBaseVNode("div", {
              ref_key: "wrapRef",
              ref: wrapRef,
              class: normalizeClass(unref(wrapKls)),
              style: normalizeStyle(unref(wrapStyle)),
              onScroll: handleScroll
            }, [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                id: _ctx.id,
                ref_key: "resizeRef",
                ref: resizeRef,
                class: normalizeClass(unref(resizeKls)),
                style: normalizeStyle(_ctx.viewStyle),
                role: _ctx.role,
                "aria-label": _ctx.ariaLabel,
                "aria-orientation": _ctx.ariaOrientation
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
            ], 38),
            !_ctx.native ? (openBlock(), createBlock(Bar, {
              key: 0,
              ref_key: "barRef",
              ref: barRef,
              height: sizeHeight.value,
              width: sizeWidth.value,
              always: _ctx.always,
              "ratio-x": ratioX.value,
              "ratio-y": ratioY.value
            }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"])) : createCommentVNode("v-if", true)
          ], 2);
        };
      }
    });
    var Scrollbar = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["__file", "scrollbar.vue"]]);
    const ElScrollbar = withInstall(Scrollbar);
    const POPPER_INJECTION_KEY = Symbol("popper");
    const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
    const roleTypes = [
      "dialog",
      "grid",
      "group",
      "listbox",
      "menu",
      "navigation",
      "tooltip",
      "tree"
    ];
    const popperProps = buildProps({
      role: {
        type: String,
        values: roleTypes,
        default: "tooltip"
      }
    });
    const __default__$h = /* @__PURE__ */ defineComponent({
      name: "ElPopper",
      inheritAttrs: false
    });
    const _sfc_main$z = /* @__PURE__ */ defineComponent({
      ...__default__$h,
      props: popperProps,
      setup(__props, { expose }) {
        const props = __props;
        const triggerRef = ref();
        const popperInstanceRef = ref();
        const contentRef = ref();
        const referenceRef = ref();
        const role = computed(() => props.role);
        const popperProvides = {
          triggerRef,
          popperInstanceRef,
          contentRef,
          referenceRef,
          role
        };
        expose(popperProvides);
        provide(POPPER_INJECTION_KEY, popperProvides);
        return (_ctx, _cache) => {
          return renderSlot(_ctx.$slots, "default");
        };
      }
    });
    var Popper = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["__file", "popper.vue"]]);
    const popperArrowProps = buildProps({
      arrowOffset: {
        type: Number,
        default: 5
      }
    });
    const __default__$g = /* @__PURE__ */ defineComponent({
      name: "ElPopperArrow",
      inheritAttrs: false
    });
    const _sfc_main$y = /* @__PURE__ */ defineComponent({
      ...__default__$g,
      props: popperArrowProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns = useNamespace("popper");
        const { arrowOffset, arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
        watch(() => props.arrowOffset, (val) => {
          arrowOffset.value = val;
        });
        onBeforeUnmount(() => {
          arrowRef.value = void 0;
        });
        expose({
          arrowRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            ref_key: "arrowRef",
            ref: arrowRef,
            class: normalizeClass(unref(ns).e("arrow")),
            style: normalizeStyle(unref(arrowStyle)),
            "data-popper-arrow": ""
          }, null, 6);
        };
      }
    });
    var ElPopperArrow = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__file", "arrow.vue"]]);
    const NAME = "ElOnlyChild";
    const OnlyChild = /* @__PURE__ */ defineComponent({
      name: NAME,
      setup(_, {
        slots,
        attrs
      }) {
        var _a2;
        const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
        const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
        return () => {
          var _a22;
          const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
          if (!defaultSlot)
            return null;
          if (defaultSlot.length > 1) {
            debugWarn(NAME, "requires exact only one valid child.");
            return null;
          }
          const firstLegitNode = findFirstLegitChild(defaultSlot);
          if (!firstLegitNode) {
            debugWarn(NAME, "no valid child node found");
            return null;
          }
          return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
        };
      }
    });
    function findFirstLegitChild(node) {
      if (!node)
        return null;
      const children = node;
      for (const child of children) {
        if (isObject$1(child)) {
          switch (child.type) {
            case Comment:
              continue;
            case Text:
            case "svg":
              return wrapTextContent(child);
            case Fragment:
              return findFirstLegitChild(child.children);
            default:
              return child;
          }
        }
        return wrapTextContent(child);
      }
      return null;
    }
    function wrapTextContent(s) {
      const ns = useNamespace("only-child");
      return createVNode("span", {
        "class": ns.e("content")
      }, [s]);
    }
    const popperTriggerProps = buildProps({
      virtualRef: {
        type: definePropType(Object)
      },
      virtualTriggering: Boolean,
      onMouseenter: {
        type: definePropType(Function)
      },
      onMouseleave: {
        type: definePropType(Function)
      },
      onClick: {
        type: definePropType(Function)
      },
      onKeydown: {
        type: definePropType(Function)
      },
      onFocus: {
        type: definePropType(Function)
      },
      onBlur: {
        type: definePropType(Function)
      },
      onContextmenu: {
        type: definePropType(Function)
      },
      id: String,
      open: Boolean
    });
    const __default__$f = /* @__PURE__ */ defineComponent({
      name: "ElPopperTrigger",
      inheritAttrs: false
    });
    const _sfc_main$x = /* @__PURE__ */ defineComponent({
      ...__default__$f,
      props: popperTriggerProps,
      setup(__props, { expose }) {
        const props = __props;
        const { role, triggerRef } = inject(POPPER_INJECTION_KEY, void 0);
        useForwardRef(triggerRef);
        const ariaControls = computed(() => {
          return ariaHaspopup.value ? props.id : void 0;
        });
        const ariaDescribedby = computed(() => {
          if (role && role.value === "tooltip") {
            return props.open && props.id ? props.id : void 0;
          }
          return void 0;
        });
        const ariaHaspopup = computed(() => {
          if (role && role.value !== "tooltip") {
            return role.value;
          }
          return void 0;
        });
        const ariaExpanded = computed(() => {
          return ariaHaspopup.value ? `${props.open}` : void 0;
        });
        let virtualTriggerAriaStopWatch = void 0;
        onMounted(() => {
          watch(() => props.virtualRef, (virtualEl) => {
            if (virtualEl) {
              triggerRef.value = unrefElement(virtualEl);
            }
          }, {
            immediate: true
          });
          watch(triggerRef, (el, prevEl) => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
            if (isElement(el)) {
              [
                "onMouseenter",
                "onMouseleave",
                "onClick",
                "onKeydown",
                "onFocus",
                "onBlur",
                "onContextmenu"
              ].forEach((eventName) => {
                var _a2;
                const handler = props[eventName];
                if (handler) {
                  el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                  (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                }
              });
              virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key, idx) => {
                  isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                });
              }, { immediate: true });
            }
            if (isElement(prevEl)) {
              [
                "aria-controls",
                "aria-describedby",
                "aria-haspopup",
                "aria-expanded"
              ].forEach((key) => prevEl.removeAttribute(key));
            }
          }, {
            immediate: true
          });
        });
        onBeforeUnmount(() => {
          virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
          virtualTriggerAriaStopWatch = void 0;
        });
        expose({
          triggerRef
        });
        return (_ctx, _cache) => {
          return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
            "aria-controls": unref(ariaControls),
            "aria-describedby": unref(ariaDescribedby),
            "aria-expanded": unref(ariaExpanded),
            "aria-haspopup": unref(ariaHaspopup)
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
        };
      }
    });
    var ElPopperTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__file", "trigger.vue"]]);
    const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
    const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
    const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
    const FOCUS_AFTER_TRAPPED_OPTS = {
      cancelable: true,
      bubbles: false
    };
    const FOCUSOUT_PREVENTED_OPTS = {
      cancelable: true,
      bubbles: false
    };
    const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
    const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
    const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
    const focusReason = ref();
    const lastUserFocusTimestamp = ref(0);
    const lastAutomatedFocusTimestamp = ref(0);
    let focusReasonUserCount = 0;
    const obtainAllFocusableElements = (element) => {
      const nodes = [];
      const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
        acceptNode: (node) => {
          const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
          if (node.disabled || node.hidden || isHiddenInput)
            return NodeFilter.FILTER_SKIP;
          return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
      });
      while (walker.nextNode())
        nodes.push(walker.currentNode);
      return nodes;
    };
    const getVisibleElement = (elements, container) => {
      for (const element of elements) {
        if (!isHidden(element, container))
          return element;
      }
    };
    const isHidden = (element, container) => {
      if (getComputedStyle(element).visibility === "hidden")
        return true;
      while (element) {
        if (container && element === container)
          return false;
        if (getComputedStyle(element).display === "none")
          return true;
        element = element.parentElement;
      }
      return false;
    };
    const getEdges = (container) => {
      const focusable = obtainAllFocusableElements(container);
      const first = getVisibleElement(focusable, container);
      const last = getVisibleElement(focusable.reverse(), container);
      return [first, last];
    };
    const isSelectable = (element) => {
      return element instanceof HTMLInputElement && "select" in element;
    };
    const tryFocus = (element, shouldSelect) => {
      if (element && element.focus) {
        const prevFocusedElement = document.activeElement;
        element.focus({ preventScroll: true });
        lastAutomatedFocusTimestamp.value = window.performance.now();
        if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
          element.select();
        }
      }
    };
    function removeFromStack(list, item) {
      const copy = [...list];
      const idx = list.indexOf(item);
      if (idx !== -1) {
        copy.splice(idx, 1);
      }
      return copy;
    }
    const createFocusableStack = () => {
      let stack2 = [];
      const push = (layer) => {
        const currentLayer = stack2[0];
        if (currentLayer && layer !== currentLayer) {
          currentLayer.pause();
        }
        stack2 = removeFromStack(stack2, layer);
        stack2.unshift(layer);
      };
      const remove2 = (layer) => {
        var _a2, _b;
        stack2 = removeFromStack(stack2, layer);
        (_b = (_a2 = stack2[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
      };
      return {
        push,
        remove: remove2
      };
    };
    const focusFirstDescendant = (elements, shouldSelect = false) => {
      const prevFocusedElement = document.activeElement;
      for (const element of elements) {
        tryFocus(element, shouldSelect);
        if (document.activeElement !== prevFocusedElement)
          return;
      }
    };
    const focusableStack = createFocusableStack();
    const isFocusCausedByUserEvent = () => {
      return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
    };
    const notifyFocusReasonPointer = () => {
      focusReason.value = "pointer";
      lastUserFocusTimestamp.value = window.performance.now();
    };
    const notifyFocusReasonKeydown = () => {
      focusReason.value = "keyboard";
      lastUserFocusTimestamp.value = window.performance.now();
    };
    const useFocusReason = () => {
      onMounted(() => {
        if (focusReasonUserCount === 0) {
          document.addEventListener("mousedown", notifyFocusReasonPointer);
          document.addEventListener("touchstart", notifyFocusReasonPointer);
          document.addEventListener("keydown", notifyFocusReasonKeydown);
        }
        focusReasonUserCount++;
      });
      onBeforeUnmount(() => {
        focusReasonUserCount--;
        if (focusReasonUserCount <= 0) {
          document.removeEventListener("mousedown", notifyFocusReasonPointer);
          document.removeEventListener("touchstart", notifyFocusReasonPointer);
          document.removeEventListener("keydown", notifyFocusReasonKeydown);
        }
      });
      return {
        focusReason,
        lastUserFocusTimestamp,
        lastAutomatedFocusTimestamp
      };
    };
    const createFocusOutPreventedEvent = (detail) => {
      return new CustomEvent(FOCUSOUT_PREVENTED, {
        ...FOCUSOUT_PREVENTED_OPTS,
        detail
      });
    };
    const _sfc_main$w = /* @__PURE__ */ defineComponent({
      name: "ElFocusTrap",
      inheritAttrs: false,
      props: {
        loop: Boolean,
        trapped: Boolean,
        focusTrapEl: Object,
        focusStartEl: {
          type: [Object, String],
          default: "first"
        }
      },
      emits: [
        ON_TRAP_FOCUS_EVT,
        ON_RELEASE_FOCUS_EVT,
        "focusin",
        "focusout",
        "focusout-prevented",
        "release-requested"
      ],
      setup(props, { emit: emit2 }) {
        const forwardRef = ref();
        let lastFocusBeforeTrapped;
        let lastFocusAfterTrapped;
        const { focusReason: focusReason2 } = useFocusReason();
        useEscapeKeydown((event) => {
          if (props.trapped && !focusLayer.paused) {
            emit2("release-requested", event);
          }
        });
        const focusLayer = {
          paused: false,
          pause() {
            this.paused = true;
          },
          resume() {
            this.paused = false;
          }
        };
        const onKeydown = (e) => {
          if (!props.loop && !props.trapped)
            return;
          if (focusLayer.paused)
            return;
          const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
          const { loop } = props;
          const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
          const currentFocusingEl = document.activeElement;
          if (isTabbing && currentFocusingEl) {
            const container = currentTarget;
            const [first, last] = getEdges(container);
            const isTabbable = first && last;
            if (!isTabbable) {
              if (currentFocusingEl === container) {
                const focusoutPreventedEvent = createFocusOutPreventedEvent({
                  focusReason: focusReason2.value
                });
                emit2("focusout-prevented", focusoutPreventedEvent);
                if (!focusoutPreventedEvent.defaultPrevented) {
                  e.preventDefault();
                }
              }
            } else {
              if (!shiftKey && currentFocusingEl === last) {
                const focusoutPreventedEvent = createFocusOutPreventedEvent({
                  focusReason: focusReason2.value
                });
                emit2("focusout-prevented", focusoutPreventedEvent);
                if (!focusoutPreventedEvent.defaultPrevented) {
                  e.preventDefault();
                  if (loop)
                    tryFocus(first, true);
                }
              } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                const focusoutPreventedEvent = createFocusOutPreventedEvent({
                  focusReason: focusReason2.value
                });
                emit2("focusout-prevented", focusoutPreventedEvent);
                if (!focusoutPreventedEvent.defaultPrevented) {
                  e.preventDefault();
                  if (loop)
                    tryFocus(last, true);
                }
              }
            }
          }
        };
        provide(FOCUS_TRAP_INJECTION_KEY, {
          focusTrapRef: forwardRef,
          onKeydown
        });
        watch(() => props.focusTrapEl, (focusTrapEl) => {
          if (focusTrapEl) {
            forwardRef.value = focusTrapEl;
          }
        }, { immediate: true });
        watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
          if (forwardRef2) {
            forwardRef2.addEventListener("keydown", onKeydown);
            forwardRef2.addEventListener("focusin", onFocusIn);
            forwardRef2.addEventListener("focusout", onFocusOut);
          }
          if (oldForwardRef) {
            oldForwardRef.removeEventListener("keydown", onKeydown);
            oldForwardRef.removeEventListener("focusin", onFocusIn);
            oldForwardRef.removeEventListener("focusout", onFocusOut);
          }
        });
        const trapOnFocus = (e) => {
          emit2(ON_TRAP_FOCUS_EVT, e);
        };
        const releaseOnFocus = (e) => emit2(ON_RELEASE_FOCUS_EVT, e);
        const onFocusIn = (e) => {
          const trapContainer = unref(forwardRef);
          if (!trapContainer)
            return;
          const target = e.target;
          const relatedTarget = e.relatedTarget;
          const isFocusedInTrap = target && trapContainer.contains(target);
          if (!props.trapped) {
            const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
            if (!isPrevFocusedInTrap) {
              lastFocusBeforeTrapped = relatedTarget;
            }
          }
          if (isFocusedInTrap)
            emit2("focusin", e);
          if (focusLayer.paused)
            return;
          if (props.trapped) {
            if (isFocusedInTrap) {
              lastFocusAfterTrapped = target;
            } else {
              tryFocus(lastFocusAfterTrapped, true);
            }
          }
        };
        const onFocusOut = (e) => {
          const trapContainer = unref(forwardRef);
          if (focusLayer.paused || !trapContainer)
            return;
          if (props.trapped) {
            const relatedTarget = e.relatedTarget;
            if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
              setTimeout(() => {
                if (!focusLayer.paused && props.trapped) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    tryFocus(lastFocusAfterTrapped, true);
                  }
                }
              }, 0);
            }
          } else {
            const target = e.target;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!isFocusedInTrap)
              emit2("focusout", e);
          }
        };
        async function startTrap() {
          await nextTick();
          const trapContainer = unref(forwardRef);
          if (trapContainer) {
            focusableStack.push(focusLayer);
            const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
            lastFocusBeforeTrapped = prevFocusedElement;
            const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
            if (!isPrevFocusContained) {
              const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
              trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
              trapContainer.dispatchEvent(focusEvent);
              if (!focusEvent.defaultPrevented) {
                nextTick(() => {
                  let focusStartEl = props.focusStartEl;
                  if (!isString$2(focusStartEl)) {
                    tryFocus(focusStartEl);
                    if (document.activeElement !== focusStartEl) {
                      focusStartEl = "first";
                    }
                  }
                  if (focusStartEl === "first") {
                    focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                  }
                  if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                    tryFocus(trapContainer);
                  }
                });
              }
            }
          }
        }
        function stopTrap() {
          const trapContainer = unref(forwardRef);
          if (trapContainer) {
            trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
            const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {
              ...FOCUS_AFTER_TRAPPED_OPTS,
              detail: {
                focusReason: focusReason2.value
              }
            });
            trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
            trapContainer.dispatchEvent(releasedEvent);
            if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
              tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
            }
            trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
            focusableStack.remove(focusLayer);
          }
        }
        onMounted(() => {
          if (props.trapped) {
            startTrap();
          }
          watch(() => props.trapped, (trapped) => {
            if (trapped) {
              startTrap();
            } else {
              stopTrap();
            }
          });
        });
        onBeforeUnmount(() => {
          if (props.trapped) {
            stopTrap();
          }
        });
        return {
          onKeydown
        };
      }
    });
    function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
      return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
    }
    var ElFocusTrap = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$7], ["__file", "focus-trap.vue"]]);
    const POSITIONING_STRATEGIES = ["fixed", "absolute"];
    const popperCoreConfigProps = buildProps({
      boundariesPadding: {
        type: Number,
        default: 0
      },
      fallbackPlacements: {
        type: definePropType(Array),
        default: void 0
      },
      gpuAcceleration: {
        type: Boolean,
        default: true
      },
      offset: {
        type: Number,
        default: 12
      },
      placement: {
        type: String,
        values: Ee,
        default: "bottom"
      },
      popperOptions: {
        type: definePropType(Object),
        default: () => ({})
      },
      strategy: {
        type: String,
        values: POSITIONING_STRATEGIES,
        default: "absolute"
      }
    });
    const popperContentProps = buildProps({
      ...popperCoreConfigProps,
      id: String,
      style: {
        type: definePropType([String, Array, Object])
      },
      className: {
        type: definePropType([String, Array, Object])
      },
      effect: {
        type: String,
        default: "dark"
      },
      visible: Boolean,
      enterable: {
        type: Boolean,
        default: true
      },
      pure: Boolean,
      focusOnShow: {
        type: Boolean,
        default: false
      },
      trapping: {
        type: Boolean,
        default: false
      },
      popperClass: {
        type: definePropType([String, Array, Object])
      },
      popperStyle: {
        type: definePropType([String, Array, Object])
      },
      referenceEl: {
        type: definePropType(Object)
      },
      triggerTargetEl: {
        type: definePropType(Object)
      },
      stopPopperMouseEvent: {
        type: Boolean,
        default: true
      },
      ariaLabel: {
        type: String,
        default: void 0
      },
      virtualTriggering: Boolean,
      zIndex: Number
    });
    const popperContentEmits = {
      mouseenter: (evt) => evt instanceof MouseEvent,
      mouseleave: (evt) => evt instanceof MouseEvent,
      focus: () => true,
      blur: () => true,
      close: () => true
    };
    const buildPopperOptions = (props, modifiers = []) => {
      const { placement, strategy, popperOptions } = props;
      const options = {
        placement,
        strategy,
        ...popperOptions,
        modifiers: [...genModifiers(props), ...modifiers]
      };
      deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
      return options;
    };
    const unwrapMeasurableEl = ($el) => {
      if (!isClient)
        return;
      return unrefElement($el);
    };
    function genModifiers(options) {
      const { offset, gpuAcceleration, fallbackPlacements } = options;
      return [
        {
          name: "offset",
          options: {
            offset: [0, offset != null ? offset : 12]
          }
        },
        {
          name: "preventOverflow",
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        },
        {
          name: "flip",
          options: {
            padding: 5,
            fallbackPlacements
          }
        },
        {
          name: "computeStyles",
          options: {
            gpuAcceleration
          }
        }
      ];
    }
    function deriveExtraModifiers(options, modifiers) {
      if (modifiers) {
        options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
      }
    }
    const DEFAULT_ARROW_OFFSET = 0;
    const usePopperContent = (props) => {
      const { popperInstanceRef, contentRef, triggerRef, role } = inject(POPPER_INJECTION_KEY, void 0);
      const arrowRef = ref();
      const arrowOffset = ref();
      const eventListenerModifier = computed(() => {
        return {
          name: "eventListeners",
          enabled: !!props.visible
        };
      });
      const arrowModifier = computed(() => {
        var _a2;
        const arrowEl = unref(arrowRef);
        const offset = (_a2 = unref(arrowOffset)) != null ? _a2 : DEFAULT_ARROW_OFFSET;
        return {
          name: "arrow",
          enabled: !isUndefined$1(arrowEl),
          options: {
            element: arrowEl,
            padding: offset
          }
        };
      });
      const options = computed(() => {
        return {
          onFirstUpdate: () => {
            update();
          },
          ...buildPopperOptions(props, [
            unref(arrowModifier),
            unref(eventListenerModifier)
          ])
        };
      });
      const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef));
      const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
      watch(instanceRef, (instance) => popperInstanceRef.value = instance);
      onMounted(() => {
        watch(() => {
          var _a2;
          return (_a2 = unref(computedReference)) == null ? void 0 : _a2.getBoundingClientRect();
        }, () => {
          update();
        });
      });
      return {
        attributes,
        arrowRef,
        contentRef,
        instanceRef,
        state,
        styles,
        role,
        forceUpdate,
        update
      };
    };
    const usePopperContentDOM = (props, {
      attributes,
      styles,
      role
    }) => {
      const { nextZIndex } = useZIndex();
      const ns = useNamespace("popper");
      const contentAttrs = computed(() => unref(attributes).popper);
      const contentZIndex = ref(isNumber(props.zIndex) ? props.zIndex : nextZIndex());
      const contentClass = computed(() => [
        ns.b(),
        ns.is("pure", props.pure),
        ns.is(props.effect),
        props.popperClass
      ]);
      const contentStyle = computed(() => {
        return [
          { zIndex: unref(contentZIndex) },
          unref(styles).popper,
          props.popperStyle || {}
        ];
      });
      const ariaModal = computed(() => role.value === "dialog" ? "false" : void 0);
      const arrowStyle = computed(() => unref(styles).arrow || {});
      const updateZIndex = () => {
        contentZIndex.value = isNumber(props.zIndex) ? props.zIndex : nextZIndex();
      };
      return {
        ariaModal,
        arrowStyle,
        contentAttrs,
        contentClass,
        contentStyle,
        contentZIndex,
        updateZIndex
      };
    };
    const usePopperContentFocusTrap = (props, emit2) => {
      const trapped = ref(false);
      const focusStartRef = ref();
      const onFocusAfterTrapped = () => {
        emit2("focus");
      };
      const onFocusAfterReleased = (event) => {
        var _a2;
        if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
          focusStartRef.value = "first";
          emit2("blur");
        }
      };
      const onFocusInTrap = (event) => {
        if (props.visible && !trapped.value) {
          if (event.target) {
            focusStartRef.value = event.target;
          }
          trapped.value = true;
        }
      };
      const onFocusoutPrevented = (event) => {
        if (!props.trapping) {
          if (event.detail.focusReason === "pointer") {
            event.preventDefault();
          }
          trapped.value = false;
        }
      };
      const onReleaseRequested = () => {
        trapped.value = false;
        emit2("close");
      };
      return {
        focusStartRef,
        trapped,
        onFocusAfterReleased,
        onFocusAfterTrapped,
        onFocusInTrap,
        onFocusoutPrevented,
        onReleaseRequested
      };
    };
    const __default__$e = /* @__PURE__ */ defineComponent({
      name: "ElPopperContent"
    });
    const _sfc_main$v = /* @__PURE__ */ defineComponent({
      ...__default__$e,
      props: popperContentProps,
      emits: popperContentEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        } = usePopperContentFocusTrap(props, emit2);
        const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
        const {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          updateZIndex
        } = usePopperContentDOM(props, {
          styles,
          attributes,
          role
        });
        const formItemContext = inject(formItemContextKey, void 0);
        const arrowOffset = ref();
        provide(POPPER_CONTENT_INJECTION_KEY, {
          arrowStyle,
          arrowRef,
          arrowOffset
        });
        if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
          provide(formItemContextKey, {
            ...formItemContext,
            addInputId: NOOP,
            removeInputId: NOOP
          });
        }
        let triggerTargetAriaStopWatch = void 0;
        const updatePopper = (shouldUpdateZIndex = true) => {
          update();
          shouldUpdateZIndex && updateZIndex();
        };
        const togglePopperAlive = () => {
          updatePopper(false);
          if (props.visible && props.focusOnShow) {
            trapped.value = true;
          } else if (props.visible === false) {
            trapped.value = false;
          }
        };
        onMounted(() => {
          watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
            const el = unref(triggerTargetEl || contentRef.value);
            const prevEl = unref(prevTriggerTargetEl || contentRef.value);
            if (isElement(el)) {
              triggerTargetAriaStopWatch = watch([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
                ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                  isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                });
              }, { immediate: true });
            }
            if (prevEl !== el && isElement(prevEl)) {
              ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                prevEl.removeAttribute(key);
              });
            }
          }, { immediate: true });
          watch(() => props.visible, togglePopperAlive, { immediate: true });
        });
        onBeforeUnmount(() => {
          triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
          triggerTargetAriaStopWatch = void 0;
        });
        expose({
          popperContentRef: contentRef,
          popperInstanceRef: instanceRef,
          updatePopper,
          contentStyle
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", mergeProps({
            ref_key: "contentRef",
            ref: contentRef
          }, unref(contentAttrs), {
            style: unref(contentStyle),
            class: unref(contentClass),
            tabindex: "-1",
            onMouseenter: _cache[0] || (_cache[0] = (e) => _ctx.$emit("mouseenter", e)),
            onMouseleave: _cache[1] || (_cache[1] = (e) => _ctx.$emit("mouseleave", e))
          }), [
            createVNode(unref(ElFocusTrap), {
              trapped: unref(trapped),
              "trap-on-focus-in": true,
              "focus-trap-el": unref(contentRef),
              "focus-start-el": unref(focusStartRef),
              onFocusAfterTrapped: unref(onFocusAfterTrapped),
              onFocusAfterReleased: unref(onFocusAfterReleased),
              onFocusin: unref(onFocusInTrap),
              onFocusoutPrevented: unref(onFocusoutPrevented),
              onReleaseRequested: unref(onReleaseRequested)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
          ], 16);
        };
      }
    });
    var ElPopperContent = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["__file", "content.vue"]]);
    const ElPopper = withInstall(Popper);
    const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
    const useTooltipContentProps = buildProps({
      ...useDelayedToggleProps,
      ...popperContentProps,
      appendTo: {
        type: definePropType([String, Object])
      },
      content: {
        type: String,
        default: ""
      },
      rawContent: {
        type: Boolean,
        default: false
      },
      persistent: Boolean,
      ariaLabel: String,
      visible: {
        type: definePropType(Boolean),
        default: null
      },
      transition: String,
      teleported: {
        type: Boolean,
        default: true
      },
      disabled: Boolean
    });
    const useTooltipTriggerProps = buildProps({
      ...popperTriggerProps,
      disabled: Boolean,
      trigger: {
        type: definePropType([String, Array]),
        default: "hover"
      },
      triggerKeys: {
        type: definePropType(Array),
        default: () => [EVENT_CODE.enter, EVENT_CODE.space]
      }
    });
    const {
      useModelToggleProps: useTooltipModelToggleProps,
      useModelToggleEmits: useTooltipModelToggleEmits,
      useModelToggle: useTooltipModelToggle
    } = createModelToggleComposable("visible");
    const useTooltipProps = buildProps({
      ...popperProps,
      ...useTooltipModelToggleProps,
      ...useTooltipContentProps,
      ...useTooltipTriggerProps,
      ...popperArrowProps,
      showArrow: {
        type: Boolean,
        default: true
      }
    });
    const tooltipEmits = [
      ...useTooltipModelToggleEmits,
      "before-show",
      "before-hide",
      "show",
      "hide",
      "open",
      "close"
    ];
    const isTriggerType = (trigger2, type) => {
      if (isArray$1(trigger2)) {
        return trigger2.includes(type);
      }
      return trigger2 === type;
    };
    const whenTrigger = (trigger2, type, handler) => {
      return (e) => {
        isTriggerType(unref(trigger2), type) && handler(e);
      };
    };
    const __default__$d = /* @__PURE__ */ defineComponent({
      name: "ElTooltipTrigger"
    });
    const _sfc_main$u = /* @__PURE__ */ defineComponent({
      ...__default__$d,
      props: useTooltipTriggerProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns = useNamespace("tooltip");
        const { controlled, id, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
        const triggerRef = ref(null);
        const stopWhenControlledOrDisabled = () => {
          if (unref(controlled) || props.disabled) {
            return true;
          }
        };
        const trigger2 = toRef(props, "trigger");
        const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onOpen));
        const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onClose));
        const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "click", (e) => {
          if (e.button === 0) {
            onToggle(e);
          }
        }));
        const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onOpen));
        const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onClose));
        const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "contextmenu", (e) => {
          e.preventDefault();
          onToggle(e);
        }));
        const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
          const { code } = e;
          if (props.triggerKeys.includes(code)) {
            e.preventDefault();
            onToggle(e);
          }
        });
        expose({
          triggerRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElPopperTrigger), {
            id: unref(id),
            "virtual-ref": _ctx.virtualRef,
            open: unref(open),
            "virtual-triggering": _ctx.virtualTriggering,
            class: normalizeClass(unref(ns).e("trigger")),
            onBlur: unref(onBlur),
            onClick: unref(onClick),
            onContextmenu: unref(onContextMenu),
            onFocus: unref(onFocus),
            onMouseenter: unref(onMouseenter),
            onMouseleave: unref(onMouseleave),
            onKeydown: unref(onKeydown)
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
        };
      }
    });
    var ElTooltipTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__file", "trigger.vue"]]);
    const __default__$c = /* @__PURE__ */ defineComponent({
      name: "ElTooltipContent",
      inheritAttrs: false
    });
    const _sfc_main$t = /* @__PURE__ */ defineComponent({
      ...__default__$c,
      props: useTooltipContentProps,
      setup(__props, { expose }) {
        const props = __props;
        const { selector } = usePopperContainerId();
        const ns = useNamespace("tooltip");
        const contentRef = ref(null);
        const destroyed = ref(false);
        const {
          controlled,
          id,
          open,
          trigger: trigger2,
          onClose,
          onOpen,
          onShow,
          onHide,
          onBeforeShow,
          onBeforeHide
        } = inject(TOOLTIP_INJECTION_KEY, void 0);
        const transitionClass = computed(() => {
          return props.transition || `${ns.namespace.value}-fade-in-linear`;
        });
        const persistentRef = computed(() => {
          return props.persistent;
        });
        onBeforeUnmount(() => {
          destroyed.value = true;
        });
        const shouldRender = computed(() => {
          return unref(persistentRef) ? true : unref(open);
        });
        const shouldShow = computed(() => {
          return props.disabled ? false : unref(open);
        });
        const appendTo = computed(() => {
          return props.appendTo || selector.value;
        });
        const contentStyle = computed(() => {
          var _a2;
          return (_a2 = props.style) != null ? _a2 : {};
        });
        const ariaHidden = computed(() => !unref(open));
        const onTransitionLeave = () => {
          onHide();
        };
        const stopWhenControlled = () => {
          if (unref(controlled))
            return true;
        };
        const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
          if (props.enterable && unref(trigger2) === "hover") {
            onOpen();
          }
        });
        const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
          if (unref(trigger2) === "hover") {
            onClose();
          }
        });
        const onBeforeEnter = () => {
          var _a2, _b;
          (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          onBeforeShow == null ? void 0 : onBeforeShow();
        };
        const onBeforeLeave = () => {
          onBeforeHide == null ? void 0 : onBeforeHide();
        };
        const onAfterShow = () => {
          onShow();
          stopHandle = onClickOutside(computed(() => {
            var _a2;
            return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
          }), () => {
            if (unref(controlled))
              return;
            const $trigger = unref(trigger2);
            if ($trigger !== "hover") {
              onClose();
            }
          });
        };
        const onBlur = () => {
          if (!props.virtualTriggering) {
            onClose();
          }
        };
        let stopHandle;
        watch(() => unref(open), (val) => {
          if (!val) {
            stopHandle == null ? void 0 : stopHandle();
          }
        }, {
          flush: "post"
        });
        watch(() => props.content, () => {
          var _a2, _b;
          (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        });
        expose({
          contentRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Teleport, {
            disabled: !_ctx.teleported,
            to: unref(appendTo)
          }, [
            createVNode(Transition, {
              name: unref(transitionClass),
              onAfterLeave: onTransitionLeave,
              onBeforeEnter,
              onAfterEnter: onAfterShow,
              onBeforeLeave
            }, {
              default: withCtx(() => [
                unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
                  key: 0,
                  id: unref(id),
                  ref_key: "contentRef",
                  ref: contentRef
                }, _ctx.$attrs, {
                  "aria-label": _ctx.ariaLabel,
                  "aria-hidden": unref(ariaHidden),
                  "boundaries-padding": _ctx.boundariesPadding,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  strategy: _ctx.strategy,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  pure: _ctx.pure,
                  "popper-class": _ctx.popperClass,
                  "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  visible: unref(shouldShow),
                  "z-index": _ctx.zIndex,
                  onMouseenter: unref(onContentEnter),
                  onMouseleave: unref(onContentLeave),
                  onBlur,
                  onClose: unref(onClose)
                }), {
                  default: withCtx(() => [
                    !destroyed.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                  [vShow, unref(shouldShow)]
                ]) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["name"])
          ], 8, ["disabled", "to"]);
        };
      }
    });
    var ElTooltipContent = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["__file", "content.vue"]]);
    const _hoisted_1$i = ["innerHTML"];
    const _hoisted_2$e = { key: 1 };
    const __default__$b = /* @__PURE__ */ defineComponent({
      name: "ElTooltip"
    });
    const _sfc_main$s = /* @__PURE__ */ defineComponent({
      ...__default__$b,
      props: useTooltipProps,
      emits: tooltipEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        usePopperContainer();
        const id = useId();
        const popperRef = ref();
        const contentRef = ref();
        const updatePopper = () => {
          var _a2;
          const popperComponent = unref(popperRef);
          if (popperComponent) {
            (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
          }
        };
        const open = ref(false);
        const toggleReason = ref();
        const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
          indicator: open,
          toggleReason
        });
        const { onOpen, onClose } = useDelayedToggle({
          showAfter: toRef(props, "showAfter"),
          hideAfter: toRef(props, "hideAfter"),
          autoClose: toRef(props, "autoClose"),
          open: show,
          close: hide
        });
        const controlled = computed(() => isBoolean(props.visible) && !hasUpdateHandler.value);
        provide(TOOLTIP_INJECTION_KEY, {
          controlled,
          id,
          open: readonly(open),
          trigger: toRef(props, "trigger"),
          onOpen: (event) => {
            onOpen(event);
          },
          onClose: (event) => {
            onClose(event);
          },
          onToggle: (event) => {
            if (unref(open)) {
              onClose(event);
            } else {
              onOpen(event);
            }
          },
          onShow: () => {
            emit2("show", toggleReason.value);
          },
          onHide: () => {
            emit2("hide", toggleReason.value);
          },
          onBeforeShow: () => {
            emit2("before-show", toggleReason.value);
          },
          onBeforeHide: () => {
            emit2("before-hide", toggleReason.value);
          },
          updatePopper
        });
        watch(() => props.disabled, (disabled) => {
          if (disabled && open.value) {
            open.value = false;
          }
        });
        const isFocusInsideContent = (event) => {
          var _a2, _b;
          const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
          const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
          return popperContent && popperContent.contains(activeElement);
        };
        onDeactivated(() => open.value && hide());
        expose({
          popperRef,
          contentRef,
          isFocusInsideContent,
          updatePopper,
          onOpen,
          onClose,
          hide
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElPopper), {
            ref_key: "popperRef",
            ref: popperRef,
            role: _ctx.role
          }, {
            default: withCtx(() => [
              createVNode(ElTooltipTrigger, {
                disabled: _ctx.disabled,
                trigger: _ctx.trigger,
                "trigger-keys": _ctx.triggerKeys,
                "virtual-ref": _ctx.virtualRef,
                "virtual-triggering": _ctx.virtualTriggering
              }, {
                default: withCtx(() => [
                  _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
              createVNode(ElTooltipContent, {
                ref_key: "contentRef",
                ref: contentRef,
                "aria-label": _ctx.ariaLabel,
                "boundaries-padding": _ctx.boundariesPadding,
                content: _ctx.content,
                disabled: _ctx.disabled,
                effect: _ctx.effect,
                enterable: _ctx.enterable,
                "fallback-placements": _ctx.fallbackPlacements,
                "hide-after": _ctx.hideAfter,
                "gpu-acceleration": _ctx.gpuAcceleration,
                offset: _ctx.offset,
                persistent: _ctx.persistent,
                "popper-class": _ctx.popperClass,
                "popper-style": _ctx.popperStyle,
                placement: _ctx.placement,
                "popper-options": _ctx.popperOptions,
                pure: _ctx.pure,
                "raw-content": _ctx.rawContent,
                "reference-el": _ctx.referenceEl,
                "trigger-target-el": _ctx.triggerTargetEl,
                "show-after": _ctx.showAfter,
                strategy: _ctx.strategy,
                teleported: _ctx.teleported,
                transition: _ctx.transition,
                "virtual-triggering": _ctx.virtualTriggering,
                "z-index": _ctx.zIndex,
                "append-to": _ctx.appendTo
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "content", {}, () => [
                    _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      innerHTML: _ctx.content
                    }, null, 8, _hoisted_1$i)) : (openBlock(), createElementBlock("span", _hoisted_2$e, toDisplayString(_ctx.content), 1))
                  ]),
                  _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), {
                    key: 0,
                    "arrow-offset": _ctx.arrowOffset
                  }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
            ]),
            _: 3
          }, 8, ["role"]);
        };
      }
    });
    var Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__file", "tooltip.vue"]]);
    const ElTooltip = withInstall(Tooltip);
    const buttonGroupContextKey = Symbol("buttonGroupContextKey");
    const useButton = (props, emit2) => {
      useDeprecated({
        from: "type.text",
        replacement: "link",
        version: "3.0.0",
        scope: "props",
        ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
      }, computed(() => props.type === "text"));
      const buttonGroupContext = inject(buttonGroupContextKey, void 0);
      const globalConfig2 = useGlobalConfig("button");
      const { form } = useFormItem();
      const _size = useFormSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
      const _disabled = useFormDisabled();
      const _ref = ref();
      const slots = useSlots();
      const _type = computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
      const autoInsertSpace = computed(() => {
        var _a2, _b, _c;
        return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
      });
      const _props = computed(() => {
        if (props.tag === "button") {
          return {
            ariaDisabled: _disabled.value || props.loading,
            disabled: _disabled.value || props.loading,
            autofocus: props.autofocus,
            type: props.nativeType
          };
        }
        return {};
      });
      const shouldAddSpace = computed(() => {
        var _a2;
        const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
        if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
          const slot = defaultSlot[0];
          if ((slot == null ? void 0 : slot.type) === Text) {
            const text = slot.children;
            return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(text.trim());
          }
        }
        return false;
      });
      const handleClick = (evt) => {
        if (props.nativeType === "reset") {
          form == null ? void 0 : form.resetFields();
        }
        emit2("click", evt);
      };
      return {
        _disabled,
        _size,
        _type,
        _ref,
        _props,
        shouldAddSpace,
        handleClick
      };
    };
    const buttonTypes = [
      "default",
      "primary",
      "success",
      "warning",
      "info",
      "danger",
      "text",
      ""
    ];
    const buttonNativeTypes = ["button", "submit", "reset"];
    const buttonProps = buildProps({
      size: useSizeProp,
      disabled: Boolean,
      type: {
        type: String,
        values: buttonTypes,
        default: ""
      },
      icon: {
        type: iconPropType
      },
      nativeType: {
        type: String,
        values: buttonNativeTypes,
        default: "button"
      },
      loading: Boolean,
      loadingIcon: {
        type: iconPropType,
        default: () => loading_default
      },
      plain: Boolean,
      text: Boolean,
      link: Boolean,
      bg: Boolean,
      autofocus: Boolean,
      round: Boolean,
      circle: Boolean,
      color: String,
      dark: Boolean,
      autoInsertSpace: {
        type: Boolean,
        default: void 0
      },
      tag: {
        type: definePropType([String, Object]),
        default: "button"
      }
    });
    const buttonEmits = {
      click: (evt) => evt instanceof MouseEvent
    };
    function bound01$1(n, max) {
      if (isOnePointZero$1(n)) {
        n = "100%";
      }
      var isPercent = isPercentage$1(n);
      n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
      if (isPercent) {
        n = parseInt(String(n * max), 10) / 100;
      }
      if (Math.abs(n - max) < 1e-6) {
        return 1;
      }
      if (max === 360) {
        n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
      } else {
        n = n % max / parseFloat(String(max));
      }
      return n;
    }
    function clamp01(val) {
      return Math.min(1, Math.max(0, val));
    }
    function isOnePointZero$1(n) {
      return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
    }
    function isPercentage$1(n) {
      return typeof n === "string" && n.indexOf("%") !== -1;
    }
    function boundAlpha(a) {
      a = parseFloat(a);
      if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
      }
      return a;
    }
    function convertToPercentage(n) {
      if (n <= 1) {
        return "".concat(Number(n) * 100, "%");
      }
      return n;
    }
    function pad2(c) {
      return c.length === 1 ? "0" + c : String(c);
    }
    function rgbToRgb(r, g, b) {
      return {
        r: bound01$1(r, 255) * 255,
        g: bound01$1(g, 255) * 255,
        b: bound01$1(b, 255) * 255
      };
    }
    function rgbToHsl(r, g, b) {
      r = bound01$1(r, 255);
      g = bound01$1(g, 255);
      b = bound01$1(b, 255);
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var h2 = 0;
      var s = 0;
      var l = (max + min) / 2;
      if (max === min) {
        s = 0;
        h2 = 0;
      } else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h2 = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h2 = (b - r) / d + 2;
            break;
          case b:
            h2 = (r - g) / d + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s, l };
    }
    function hue2rgb(p2, q2, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p2 + (q2 - p2) * (6 * t);
      }
      if (t < 1 / 2) {
        return q2;
      }
      if (t < 2 / 3) {
        return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      }
      return p2;
    }
    function hslToRgb(h2, s, l) {
      var r;
      var g;
      var b;
      h2 = bound01$1(h2, 360);
      s = bound01$1(s, 100);
      l = bound01$1(l, 100);
      if (s === 0) {
        g = l;
        b = l;
        r = l;
      } else {
        var q2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p2 = 2 * l - q2;
        r = hue2rgb(p2, q2, h2 + 1 / 3);
        g = hue2rgb(p2, q2, h2);
        b = hue2rgb(p2, q2, h2 - 1 / 3);
      }
      return { r: r * 255, g: g * 255, b: b * 255 };
    }
    function rgbToHsv(r, g, b) {
      r = bound01$1(r, 255);
      g = bound01$1(g, 255);
      b = bound01$1(b, 255);
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var h2 = 0;
      var v = max;
      var d = max - min;
      var s = max === 0 ? 0 : d / max;
      if (max === min) {
        h2 = 0;
      } else {
        switch (max) {
          case r:
            h2 = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h2 = (b - r) / d + 2;
            break;
          case b:
            h2 = (r - g) / d + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s, v };
    }
    function hsvToRgb(h2, s, v) {
      h2 = bound01$1(h2, 360) * 6;
      s = bound01$1(s, 100);
      v = bound01$1(v, 100);
      var i = Math.floor(h2);
      var f = h2 - i;
      var p2 = v * (1 - s);
      var q2 = v * (1 - f * s);
      var t = v * (1 - (1 - f) * s);
      var mod = i % 6;
      var r = [v, q2, p2, p2, t, v][mod];
      var g = [t, v, v, q2, p2, p2][mod];
      var b = [p2, p2, t, v, v, q2][mod];
      return { r: r * 255, g: g * 255, b: b * 255 };
    }
    function rgbToHex(r, g, b, allow3Char) {
      var hex = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b).toString(16))
      ];
      if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r, g, b, a, allow4Char) {
      var hex = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b).toString(16)),
        pad2(convertDecimalToHex(a))
      ];
      if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function convertDecimalToHex(d) {
      return Math.round(parseFloat(d) * 255).toString(16);
    }
    function convertHexToDecimal(h2) {
      return parseIntFromHex(h2) / 255;
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function numberInputToObject(color) {
      return {
        r: color >> 16,
        g: (color & 65280) >> 8,
        b: color & 255
      };
    }
    var names = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      goldenrod: "#daa520",
      gold: "#ffd700",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavenderblush: "#fff0f5",
      lavender: "#e6e6fa",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    function inputToRGB(color) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a = 1;
      var s = null;
      var v = null;
      var l = null;
      var ok = false;
      var format = false;
      if (typeof color === "string") {
        color = stringInputToObject(color);
      }
      if (typeof color === "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok = true;
          format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s = convertToPercentage(color.s);
          v = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s, v);
          ok = true;
          format = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s = convertToPercentage(color.s);
          l = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s, l);
          ok = true;
          format = "hsl";
        }
        if (Object.prototype.hasOwnProperty.call(color, "a")) {
          a = color.a;
        }
      }
      a = boundAlpha(a);
      return {
        ok,
        format: color.format || format,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a
      };
    }
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var matchers = {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
    function stringInputToObject(color) {
      color = color.trim().toLowerCase();
      if (color.length === 0) {
        return false;
      }
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color === "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match = matchers.rgb.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3] };
      }
      match = matchers.rgba.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
      }
      match = matchers.hsl.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3] };
      }
      match = matchers.hsla.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
      }
      match = matchers.hsv.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3] };
      }
      match = matchers.hsva.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
      }
      match = matchers.hex8.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          a: convertHexToDecimal(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers.hex6.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named ? "name" : "hex"
        };
      }
      match = matchers.hex4.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          a: convertHexToDecimal(match[4] + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers.hex3.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function isValidCSSUnit(color) {
      return Boolean(matchers.CSS_UNIT.exec(String(color)));
    }
    var TinyColor = (
      /** @class */
      function() {
        function TinyColor2(color, opts) {
          if (color === void 0) {
            color = "";
          }
          if (opts === void 0) {
            opts = {};
          }
          var _a2;
          if (color instanceof TinyColor2) {
            return color;
          }
          if (typeof color === "number") {
            color = numberInputToObject(color);
          }
          this.originalInput = color;
          var rgb = inputToRGB(color);
          this.originalInput = color;
          this.r = rgb.r;
          this.g = rgb.g;
          this.b = rgb.b;
          this.a = rgb.a;
          this.roundA = Math.round(100 * this.a) / 100;
          this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
          this.gradientType = opts.gradientType;
          if (this.r < 1) {
            this.r = Math.round(this.r);
          }
          if (this.g < 1) {
            this.g = Math.round(this.g);
          }
          if (this.b < 1) {
            this.b = Math.round(this.b);
          }
          this.isValid = rgb.ok;
        }
        TinyColor2.prototype.isDark = function() {
          return this.getBrightness() < 128;
        };
        TinyColor2.prototype.isLight = function() {
          return !this.isDark();
        };
        TinyColor2.prototype.getBrightness = function() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
        };
        TinyColor2.prototype.getLuminance = function() {
          var rgb = this.toRgb();
          var R2;
          var G2;
          var B2;
          var RsRGB = rgb.r / 255;
          var GsRGB = rgb.g / 255;
          var BsRGB = rgb.b / 255;
          if (RsRGB <= 0.03928) {
            R2 = RsRGB / 12.92;
          } else {
            R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G2 = GsRGB / 12.92;
          } else {
            G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B2 = BsRGB / 12.92;
          } else {
            B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
        };
        TinyColor2.prototype.getAlpha = function() {
          return this.a;
        };
        TinyColor2.prototype.setAlpha = function(alpha) {
          this.a = boundAlpha(alpha);
          this.roundA = Math.round(100 * this.a) / 100;
          return this;
        };
        TinyColor2.prototype.isMonochrome = function() {
          var s = this.toHsl().s;
          return s === 0;
        };
        TinyColor2.prototype.toHsv = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
        };
        TinyColor2.prototype.toHsvString = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          var h2 = Math.round(hsv.h * 360);
          var s = Math.round(hsv.s * 100);
          var v = Math.round(hsv.v * 100);
          return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHsl = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
        };
        TinyColor2.prototype.toHslString = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          var h2 = Math.round(hsl.h * 360);
          var s = Math.round(hsl.s * 100);
          var l = Math.round(hsl.l * 100);
          return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHex = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return rgbToHex(this.r, this.g, this.b, allow3Char);
        };
        TinyColor2.prototype.toHexString = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return "#" + this.toHex(allow3Char);
        };
        TinyColor2.prototype.toHex8 = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
        };
        TinyColor2.prototype.toHex8String = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return "#" + this.toHex8(allow4Char);
        };
        TinyColor2.prototype.toHexShortString = function(allowShortChar) {
          if (allowShortChar === void 0) {
            allowShortChar = false;
          }
          return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
        };
        TinyColor2.prototype.toRgb = function() {
          return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toRgbString = function() {
          var r = Math.round(this.r);
          var g = Math.round(this.g);
          var b = Math.round(this.b);
          return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toPercentageRgb = function() {
          var fmt = function(x) {
            return "".concat(Math.round(bound01$1(x, 255) * 100), "%");
          };
          return {
            r: fmt(this.r),
            g: fmt(this.g),
            b: fmt(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toPercentageRgbString = function() {
          var rnd = function(x) {
            return Math.round(bound01$1(x, 255) * 100);
          };
          return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toName = function() {
          if (this.a === 0) {
            return "transparent";
          }
          if (this.a < 1) {
            return false;
          }
          var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
          for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
            var _b = _a2[_i], key = _b[0], value = _b[1];
            if (hex === value) {
              return key;
            }
          }
          return false;
        };
        TinyColor2.prototype.toString = function(format) {
          var formatSet = Boolean(format);
          format = format !== null && format !== void 0 ? format : this.format;
          var formattedString = false;
          var hasAlpha = this.a < 1 && this.a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
          if (needsAlphaFormat) {
            if (format === "name" && this.a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
          }
          if (format === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format === "name") {
            formattedString = this.toName();
          }
          if (format === "hsl") {
            formattedString = this.toHslString();
          }
          if (format === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        };
        TinyColor2.prototype.toNumber = function() {
          return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
        };
        TinyColor2.prototype.clone = function() {
          return new TinyColor2(this.toString());
        };
        TinyColor2.prototype.lighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.brighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var rgb = this.toRgb();
          rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
          rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
          rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
          return new TinyColor2(rgb);
        };
        TinyColor2.prototype.darken = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.tint = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("white", amount);
        };
        TinyColor2.prototype.shade = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("black", amount);
        };
        TinyColor2.prototype.desaturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.saturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.greyscale = function() {
          return this.desaturate(100);
        };
        TinyColor2.prototype.spin = function(amount) {
          var hsl = this.toHsl();
          var hue = (hsl.h + amount) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.mix = function(color, amount) {
          if (amount === void 0) {
            amount = 50;
          }
          var rgb1 = this.toRgb();
          var rgb2 = new TinyColor2(color).toRgb();
          var p2 = amount / 100;
          var rgba = {
            r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
            g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
            b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
            a: (rgb2.a - rgb1.a) * p2 + rgb1.a
          };
          return new TinyColor2(rgba);
        };
        TinyColor2.prototype.analogous = function(results, slices) {
          if (results === void 0) {
            results = 6;
          }
          if (slices === void 0) {
            slices = 30;
          }
          var hsl = this.toHsl();
          var part = 360 / slices;
          var ret = [this];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(new TinyColor2(hsl));
          }
          return ret;
        };
        TinyColor2.prototype.complement = function() {
          var hsl = this.toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.monochromatic = function(results) {
          if (results === void 0) {
            results = 6;
          }
          var hsv = this.toHsv();
          var h2 = hsv.h;
          var s = hsv.s;
          var v = hsv.v;
          var res = [];
          var modification = 1 / results;
          while (results--) {
            res.push(new TinyColor2({ h: h2, s, v }));
            v = (v + modification) % 1;
          }
          return res;
        };
        TinyColor2.prototype.splitcomplement = function() {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          return [
            this,
            new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
            new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
          ];
        };
        TinyColor2.prototype.onBackground = function(background) {
          var fg = this.toRgb();
          var bg = new TinyColor2(background).toRgb();
          var alpha = fg.a + bg.a * (1 - fg.a);
          return new TinyColor2({
            r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
            g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
            b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
            a: alpha
          });
        };
        TinyColor2.prototype.triad = function() {
          return this.polyad(3);
        };
        TinyColor2.prototype.tetrad = function() {
          return this.polyad(4);
        };
        TinyColor2.prototype.polyad = function(n) {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          var result = [this];
          var increment = 360 / n;
          for (var i = 1; i < n; i++) {
            result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
          }
          return result;
        };
        TinyColor2.prototype.equals = function(color) {
          return this.toRgbString() === new TinyColor2(color).toRgbString();
        };
        return TinyColor2;
      }()
    );
    function darken(color, amount = 20) {
      return color.mix("#141414", amount).toString();
    }
    function useButtonCustomStyle(props) {
      const _disabled = useFormDisabled();
      const ns = useNamespace("button");
      return computed(() => {
        let styles = {};
        const buttonColor = props.color;
        if (buttonColor) {
          const color = new TinyColor(buttonColor);
          const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
          if (props.plain) {
            styles = ns.cssVarBlock({
              "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
              "text-color": buttonColor,
              "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
              "hover-text-color": `var(${ns.cssVarName("color-white")})`,
              "hover-bg-color": buttonColor,
              "hover-border-color": buttonColor,
              "active-bg-color": activeBgColor,
              "active-text-color": `var(${ns.cssVarName("color-white")})`,
              "active-border-color": activeBgColor
            });
            if (_disabled.value) {
              styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
              styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
              styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
            }
          } else {
            const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
            const textColor = color.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
            styles = ns.cssVarBlock({
              "bg-color": buttonColor,
              "text-color": textColor,
              "border-color": buttonColor,
              "hover-bg-color": hoverBgColor,
              "hover-text-color": textColor,
              "hover-border-color": hoverBgColor,
              "active-bg-color": activeBgColor,
              "active-border-color": activeBgColor
            });
            if (_disabled.value) {
              const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
              styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
              styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
              styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
            }
          }
        }
        return styles;
      });
    }
    const __default__$a = /* @__PURE__ */ defineComponent({
      name: "ElButton"
    });
    const _sfc_main$r = /* @__PURE__ */ defineComponent({
      ...__default__$a,
      props: buttonProps,
      emits: buttonEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const buttonStyle = useButtonCustomStyle(props);
        const ns = useNamespace("button");
        const { _ref, _size, _type, _disabled, _props, shouldAddSpace, handleClick } = useButton(props, emit2);
        expose({
          ref: _ref,
          size: _size,
          type: _type,
          disabled: _disabled,
          shouldAddSpace
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
            ref_key: "_ref",
            ref: _ref
          }, unref(_props), {
            class: [
              unref(ns).b(),
              unref(ns).m(unref(_type)),
              unref(ns).m(unref(_size)),
              unref(ns).is("disabled", unref(_disabled)),
              unref(ns).is("loading", _ctx.loading),
              unref(ns).is("plain", _ctx.plain),
              unref(ns).is("round", _ctx.round),
              unref(ns).is("circle", _ctx.circle),
              unref(ns).is("text", _ctx.text),
              unref(ns).is("link", _ctx.link),
              unref(ns).is("has-bg", _ctx.bg)
            ],
            style: unref(buttonStyle),
            onClick: unref(handleClick)
          }), {
            default: withCtx(() => [
              _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                  key: 1,
                  class: normalizeClass(unref(ns).is("loading"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                  ]),
                  _: 1
                }, 8, ["class"]))
              ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                default: withCtx(() => [
                  _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
                ]),
                _: 3
              })) : createCommentVNode("v-if", true),
              _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                key: 2,
                class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 16, ["class", "style", "onClick"]);
        };
      }
    });
    var Button = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["__file", "button.vue"]]);
    const buttonGroupProps = {
      size: buttonProps.size,
      type: buttonProps.type
    };
    const __default__$9 = /* @__PURE__ */ defineComponent({
      name: "ElButtonGroup"
    });
    const _sfc_main$q = /* @__PURE__ */ defineComponent({
      ...__default__$9,
      props: buttonGroupProps,
      setup(__props) {
        const props = __props;
        provide(buttonGroupContextKey, reactive({
          size: toRef(props, "size"),
          type: toRef(props, "type")
        }));
        const ns = useNamespace("button");
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(`${unref(ns).b("group")}`)
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    });
    var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["__file", "button-group.vue"]]);
    const ElButton = withInstall(Button, {
      ButtonGroup
    });
    withNoopInstall(ButtonGroup);
    const nodeList = /* @__PURE__ */ new Map();
    let startClick;
    if (isClient) {
      document.addEventListener("mousedown", (e) => startClick = e);
      document.addEventListener("mouseup", (e) => {
        for (const handlers of nodeList.values()) {
          for (const { documentHandler } of handlers) {
            documentHandler(e, startClick);
          }
        }
      });
    }
    function createDocumentHandler(el, binding) {
      let excludes = [];
      if (Array.isArray(binding.arg)) {
        excludes = binding.arg;
      } else if (isElement(binding.arg)) {
        excludes.push(binding.arg);
      }
      return function(mouseup, mousedown) {
        const popperRef = binding.instance.popperRef;
        const mouseUpTarget = mouseup.target;
        const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
        const isBound = !binding || !binding.instance;
        const isTargetExists = !mouseUpTarget || !mouseDownTarget;
        const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
        const isSelf = el === mouseUpTarget;
        const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
        const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
        if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
          return;
        }
        binding.value(mouseup, mousedown);
      };
    }
    const ClickOutside = {
      beforeMount(el, binding) {
        if (!nodeList.has(el)) {
          nodeList.set(el, []);
        }
        nodeList.get(el).push({
          documentHandler: createDocumentHandler(el, binding),
          bindingFn: binding.value
        });
      },
      updated(el, binding) {
        if (!nodeList.has(el)) {
          nodeList.set(el, []);
        }
        const handlers = nodeList.get(el);
        const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
        const newHandler = {
          documentHandler: createDocumentHandler(el, binding),
          bindingFn: binding.value
        };
        if (oldHandlerIndex >= 0) {
          handlers.splice(oldHandlerIndex, 1, newHandler);
        } else {
          handlers.push(newHandler);
        }
      },
      unmounted(el) {
        nodeList.delete(el);
      }
    };
    const tagProps = buildProps({
      type: {
        type: String,
        values: ["success", "info", "warning", "danger", ""],
        default: ""
      },
      closable: Boolean,
      disableTransitions: Boolean,
      hit: Boolean,
      color: {
        type: String,
        default: ""
      },
      size: {
        type: String,
        values: componentSizes,
        default: ""
      },
      effect: {
        type: String,
        values: ["dark", "light", "plain"],
        default: "light"
      },
      round: Boolean
    });
    const tagEmits = {
      close: (evt) => evt instanceof MouseEvent,
      click: (evt) => evt instanceof MouseEvent
    };
    const __default__$8 = /* @__PURE__ */ defineComponent({
      name: "ElTag"
    });
    const _sfc_main$p = /* @__PURE__ */ defineComponent({
      ...__default__$8,
      props: tagProps,
      emits: tagEmits,
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const tagSize = useFormSize();
        const ns = useNamespace("tag");
        const containerKls = computed(() => {
          const { type, hit, effect, closable, round: round2 } = props;
          return [
            ns.b(),
            ns.is("closable", closable),
            ns.m(type),
            ns.m(tagSize.value),
            ns.m(effect),
            ns.is("hit", hit),
            ns.is("round", round2)
          ];
        });
        const handleClose = (event) => {
          emit2("close", event);
        };
        const handleClick = (event) => {
          emit2("click", event);
        };
        return (_ctx, _cache) => {
          return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: normalizeClass(unref(containerKls)),
            style: normalizeStyle({ backgroundColor: _ctx.color }),
            onClick: handleClick
          }, [
            createBaseVNode("span", {
              class: normalizeClass(unref(ns).e("content"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2),
            _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
              key: 0,
              class: normalizeClass(unref(ns).e("close")),
              onClick: withModifiers(handleClose, ["stop"])
            }, {
              default: withCtx(() => [
                createVNode(unref(close_default))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
          ], 6)) : (openBlock(), createBlock(Transition, {
            key: 1,
            name: `${unref(ns).namespace.value}-zoom-in-center`,
            appear: ""
          }, {
            default: withCtx(() => [
              createBaseVNode("span", {
                class: normalizeClass(unref(containerKls)),
                style: normalizeStyle({ backgroundColor: _ctx.color }),
                onClick: handleClick
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(unref(ns).e("content"))
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2),
                _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(ns).e("close")),
                  onClick: withModifiers(handleClose, ["stop"])
                }, {
                  default: withCtx(() => [
                    createVNode(unref(close_default))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
              ], 6)
            ]),
            _: 3
          }, 8, ["name"]));
        };
      }
    });
    var Tag = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__file", "tag.vue"]]);
    const ElTag = withInstall(Tag);
    const alphaSliderProps = buildProps({
      color: {
        type: definePropType(Object),
        required: true
      },
      vertical: {
        type: Boolean,
        default: false
      }
    });
    let isDragging = false;
    function draggable(element, options) {
      if (!isClient)
        return;
      const moveFn = function(event) {
        var _a2;
        (_a2 = options.drag) == null ? void 0 : _a2.call(options, event);
      };
      const upFn = function(event) {
        var _a2;
        document.removeEventListener("mousemove", moveFn);
        document.removeEventListener("mouseup", upFn);
        document.removeEventListener("touchmove", moveFn);
        document.removeEventListener("touchend", upFn);
        document.onselectstart = null;
        document.ondragstart = null;
        isDragging = false;
        (_a2 = options.end) == null ? void 0 : _a2.call(options, event);
      };
      const downFn = function(event) {
        var _a2;
        if (isDragging)
          return;
        event.preventDefault();
        document.onselectstart = () => false;
        document.ondragstart = () => false;
        document.addEventListener("mousemove", moveFn);
        document.addEventListener("mouseup", upFn);
        document.addEventListener("touchmove", moveFn);
        document.addEventListener("touchend", upFn);
        isDragging = true;
        (_a2 = options.start) == null ? void 0 : _a2.call(options, event);
      };
      element.addEventListener("mousedown", downFn);
      element.addEventListener("touchstart", downFn);
    }
    const useAlphaSlider = (props) => {
      const instance = getCurrentInstance();
      const thumb = shallowRef();
      const bar = shallowRef();
      function handleClick(event) {
        const target = event.target;
        if (target !== thumb.value) {
          handleDrag(event);
        }
      }
      function handleDrag(event) {
        if (!bar.value || !thumb.value)
          return;
        const el = instance.vnode.el;
        const rect = el.getBoundingClientRect();
        const { clientX, clientY } = getClientXY(event);
        if (!props.vertical) {
          let left = clientX - rect.left;
          left = Math.max(thumb.value.offsetWidth / 2, left);
          left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);
          props.color.set("alpha", Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 100));
        } else {
          let top = clientY - rect.top;
          top = Math.max(thumb.value.offsetHeight / 2, top);
          top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
          props.color.set("alpha", Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 100));
        }
      }
      return {
        thumb,
        bar,
        handleDrag,
        handleClick
      };
    };
    const useAlphaSliderDOM = (props, {
      bar,
      thumb,
      handleDrag
    }) => {
      const instance = getCurrentInstance();
      const ns = useNamespace("color-alpha-slider");
      const thumbLeft = ref(0);
      const thumbTop = ref(0);
      const background = ref();
      function getThumbLeft() {
        if (!thumb.value)
          return 0;
        if (props.vertical)
          return 0;
        const el = instance.vnode.el;
        const alpha = props.color.get("alpha");
        if (!el)
          return 0;
        return Math.round(alpha * (el.offsetWidth - thumb.value.offsetWidth / 2) / 100);
      }
      function getThumbTop() {
        if (!thumb.value)
          return 0;
        const el = instance.vnode.el;
        if (!props.vertical)
          return 0;
        const alpha = props.color.get("alpha");
        if (!el)
          return 0;
        return Math.round(alpha * (el.offsetHeight - thumb.value.offsetHeight / 2) / 100);
      }
      function getBackground() {
        if (props.color && props.color.value) {
          const { r, g, b } = props.color.toRgb();
          return `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgba(${r}, ${g}, ${b}, 1) 100%)`;
        }
        return "";
      }
      function update() {
        thumbLeft.value = getThumbLeft();
        thumbTop.value = getThumbTop();
        background.value = getBackground();
      }
      onMounted(() => {
        if (!bar.value || !thumb.value)
          return;
        const dragConfig = {
          drag: (event) => {
            handleDrag(event);
          },
          end: (event) => {
            handleDrag(event);
          }
        };
        draggable(bar.value, dragConfig);
        draggable(thumb.value, dragConfig);
        update();
      });
      watch(() => props.color.get("alpha"), () => update());
      watch(() => props.color.value, () => update());
      const rootKls = computed(() => [ns.b(), ns.is("vertical", props.vertical)]);
      const barKls = computed(() => ns.e("bar"));
      const thumbKls = computed(() => ns.e("thumb"));
      const barStyle = computed(() => ({ background: background.value }));
      const thumbStyle = computed(() => ({
        left: addUnit(thumbLeft.value),
        top: addUnit(thumbTop.value)
      }));
      return { rootKls, barKls, barStyle, thumbKls, thumbStyle, update };
    };
    const COMPONENT_NAME$1 = "ElColorAlphaSlider";
    const __default__$7 = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME$1
    });
    const _sfc_main$o = /* @__PURE__ */ defineComponent({
      ...__default__$7,
      props: alphaSliderProps,
      setup(__props, { expose }) {
        const props = __props;
        const { bar, thumb, handleDrag, handleClick } = useAlphaSlider(props);
        const { rootKls, barKls, barStyle, thumbKls, thumbStyle, update } = useAlphaSliderDOM(props, {
          bar,
          thumb,
          handleDrag
        });
        expose({
          update,
          bar,
          thumb
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(rootKls))
          }, [
            createBaseVNode("div", {
              ref_key: "bar",
              ref: bar,
              class: normalizeClass(unref(barKls)),
              style: normalizeStyle(unref(barStyle)),
              onClick: _cache[0] || (_cache[0] = (...args) => unref(handleClick) && unref(handleClick)(...args))
            }, null, 6),
            createBaseVNode("div", {
              ref_key: "thumb",
              ref: thumb,
              class: normalizeClass(unref(thumbKls)),
              style: normalizeStyle(unref(thumbStyle))
            }, null, 6)
          ], 2);
        };
      }
    });
    var AlphaSlider = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__file", "alpha-slider.vue"]]);
    const _sfc_main$n = /* @__PURE__ */ defineComponent({
      name: "ElColorHueSlider",
      props: {
        color: {
          type: Object,
          required: true
        },
        vertical: Boolean
      },
      setup(props) {
        const ns = useNamespace("color-hue-slider");
        const instance = getCurrentInstance();
        const thumb = ref();
        const bar = ref();
        const thumbLeft = ref(0);
        const thumbTop = ref(0);
        const hueValue = computed(() => {
          return props.color.get("hue");
        });
        watch(() => hueValue.value, () => {
          update();
        });
        function handleClick(event) {
          const target = event.target;
          if (target !== thumb.value) {
            handleDrag(event);
          }
        }
        function handleDrag(event) {
          if (!bar.value || !thumb.value)
            return;
          const el = instance.vnode.el;
          const rect = el.getBoundingClientRect();
          const { clientX, clientY } = getClientXY(event);
          let hue;
          if (!props.vertical) {
            let left = clientX - rect.left;
            left = Math.min(left, rect.width - thumb.value.offsetWidth / 2);
            left = Math.max(thumb.value.offsetWidth / 2, left);
            hue = Math.round((left - thumb.value.offsetWidth / 2) / (rect.width - thumb.value.offsetWidth) * 360);
          } else {
            let top = clientY - rect.top;
            top = Math.min(top, rect.height - thumb.value.offsetHeight / 2);
            top = Math.max(thumb.value.offsetHeight / 2, top);
            hue = Math.round((top - thumb.value.offsetHeight / 2) / (rect.height - thumb.value.offsetHeight) * 360);
          }
          props.color.set("hue", hue);
        }
        function getThumbLeft() {
          if (!thumb.value)
            return 0;
          const el = instance.vnode.el;
          if (props.vertical)
            return 0;
          const hue = props.color.get("hue");
          if (!el)
            return 0;
          return Math.round(hue * (el.offsetWidth - thumb.value.offsetWidth / 2) / 360);
        }
        function getThumbTop() {
          if (!thumb.value)
            return 0;
          const el = instance.vnode.el;
          if (!props.vertical)
            return 0;
          const hue = props.color.get("hue");
          if (!el)
            return 0;
          return Math.round(hue * (el.offsetHeight - thumb.value.offsetHeight / 2) / 360);
        }
        function update() {
          thumbLeft.value = getThumbLeft();
          thumbTop.value = getThumbTop();
        }
        onMounted(() => {
          if (!bar.value || !thumb.value)
            return;
          const dragConfig = {
            drag: (event) => {
              handleDrag(event);
            },
            end: (event) => {
              handleDrag(event);
            }
          };
          draggable(bar.value, dragConfig);
          draggable(thumb.value, dragConfig);
          update();
        });
        return {
          bar,
          thumb,
          thumbLeft,
          thumbTop,
          hueValue,
          handleClick,
          update,
          ns
        };
      }
    });
    function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.ns.b(), _ctx.ns.is("vertical", _ctx.vertical)])
      }, [
        createBaseVNode("div", {
          ref: "bar",
          class: normalizeClass(_ctx.ns.e("bar")),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
        }, null, 2),
        createBaseVNode("div", {
          ref: "thumb",
          class: normalizeClass(_ctx.ns.e("thumb")),
          style: normalizeStyle({
            left: _ctx.thumbLeft + "px",
            top: _ctx.thumbTop + "px"
          })
        }, null, 6)
      ], 2);
    }
    var HueSlider = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$6], ["__file", "hue-slider.vue"]]);
    const colorPickerProps = buildProps({
      modelValue: String,
      id: String,
      showAlpha: Boolean,
      colorFormat: String,
      disabled: Boolean,
      size: useSizeProp,
      popperClass: {
        type: String,
        default: ""
      },
      label: {
        type: String,
        default: void 0
      },
      tabindex: {
        type: [String, Number],
        default: 0
      },
      predefine: {
        type: definePropType(Array)
      },
      validateEvent: {
        type: Boolean,
        default: true
      }
    });
    const colorPickerEmits = {
      [UPDATE_MODEL_EVENT]: (val) => isString$2(val) || isNil(val),
      [CHANGE_EVENT]: (val) => isString$2(val) || isNil(val),
      activeChange: (val) => isString$2(val) || isNil(val),
      focus: (event) => event instanceof FocusEvent,
      blur: (event) => event instanceof FocusEvent
    };
    const colorPickerContextKey = Symbol("colorPickerContextKey");
    const hsv2hsl = function(hue, sat, val) {
      return [
        hue,
        sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0,
        hue / 2
      ];
    };
    const isOnePointZero = function(n) {
      return typeof n === "string" && n.includes(".") && Number.parseFloat(n) === 1;
    };
    const isPercentage = function(n) {
      return typeof n === "string" && n.includes("%");
    };
    const bound01 = function(value, max) {
      if (isOnePointZero(value))
        value = "100%";
      const processPercent = isPercentage(value);
      value = Math.min(max, Math.max(0, Number.parseFloat(`${value}`)));
      if (processPercent) {
        value = Number.parseInt(`${value * max}`, 10) / 100;
      }
      if (Math.abs(value - max) < 1e-6) {
        return 1;
      }
      return value % max / Number.parseFloat(max);
    };
    const INT_HEX_MAP = {
      10: "A",
      11: "B",
      12: "C",
      13: "D",
      14: "E",
      15: "F"
    };
    const hexOne = (value) => {
      value = Math.min(Math.round(value), 255);
      const high = Math.floor(value / 16);
      const low = value % 16;
      return `${INT_HEX_MAP[high] || high}${INT_HEX_MAP[low] || low}`;
    };
    const toHex = function({ r, g, b }) {
      if (Number.isNaN(+r) || Number.isNaN(+g) || Number.isNaN(+b))
        return "";
      return `#${hexOne(r)}${hexOne(g)}${hexOne(b)}`;
    };
    const HEX_INT_MAP = {
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15
    };
    const parseHexChannel = function(hex) {
      if (hex.length === 2) {
        return (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 + (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]);
      }
      return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1];
    };
    const hsl2hsv = function(hue, sat, light) {
      sat = sat / 100;
      light = light / 100;
      let smin = sat;
      const lmin = Math.max(light, 0.01);
      light *= 2;
      sat *= light <= 1 ? light : 2 - light;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (light + sat) / 2;
      const sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);
      return {
        h: hue,
        s: sv * 100,
        v: v * 100
      };
    };
    const rgb2hsv = (r, g, b) => {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h2;
      const v = max;
      const d = max - min;
      const s = max === 0 ? 0 : d / max;
      if (max === min) {
        h2 = 0;
      } else {
        switch (max) {
          case r: {
            h2 = (g - b) / d + (g < b ? 6 : 0);
            break;
          }
          case g: {
            h2 = (b - r) / d + 2;
            break;
          }
          case b: {
            h2 = (r - g) / d + 4;
            break;
          }
        }
        h2 /= 6;
      }
      return { h: h2 * 360, s: s * 100, v: v * 100 };
    };
    const hsv2rgb = function(h2, s, v) {
      h2 = bound01(h2, 360) * 6;
      s = bound01(s, 100);
      v = bound01(v, 100);
      const i = Math.floor(h2);
      const f = h2 - i;
      const p2 = v * (1 - s);
      const q2 = v * (1 - f * s);
      const t = v * (1 - (1 - f) * s);
      const mod = i % 6;
      const r = [v, q2, p2, p2, t, v][mod];
      const g = [t, v, v, q2, p2, p2][mod];
      const b = [p2, p2, t, v, v, q2][mod];
      return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
      };
    };
    class Color {
      constructor(options = {}) {
        this._hue = 0;
        this._saturation = 100;
        this._value = 100;
        this._alpha = 100;
        this.enableAlpha = false;
        this.format = "hex";
        this.value = "";
        for (const option in options) {
          if (hasOwn(options, option)) {
            this[option] = options[option];
          }
        }
        if (options.value) {
          this.fromString(options.value);
        } else {
          this.doOnChange();
        }
      }
      set(prop, value) {
        if (arguments.length === 1 && typeof prop === "object") {
          for (const p2 in prop) {
            if (hasOwn(prop, p2)) {
              this.set(p2, prop[p2]);
            }
          }
          return;
        }
        this[`_${prop}`] = value;
        this.doOnChange();
      }
      get(prop) {
        if (prop === "alpha") {
          return Math.floor(this[`_${prop}`]);
        }
        return this[`_${prop}`];
      }
      toRgb() {
        return hsv2rgb(this._hue, this._saturation, this._value);
      }
      fromString(value) {
        if (!value) {
          this._hue = 0;
          this._saturation = 100;
          this._value = 100;
          this.doOnChange();
          return;
        }
        const fromHSV = (h2, s, v) => {
          this._hue = Math.max(0, Math.min(360, h2));
          this._saturation = Math.max(0, Math.min(100, s));
          this._value = Math.max(0, Math.min(100, v));
          this.doOnChange();
        };
        if (value.includes("hsl")) {
          const parts = value.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
          if (parts.length === 4) {
            this._alpha = Number.parseFloat(parts[3]) * 100;
          } else if (parts.length === 3) {
            this._alpha = 100;
          }
          if (parts.length >= 3) {
            const { h: h2, s, v } = hsl2hsv(parts[0], parts[1], parts[2]);
            fromHSV(h2, s, v);
          }
        } else if (value.includes("hsv")) {
          const parts = value.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
          if (parts.length === 4) {
            this._alpha = Number.parseFloat(parts[3]) * 100;
          } else if (parts.length === 3) {
            this._alpha = 100;
          }
          if (parts.length >= 3) {
            fromHSV(parts[0], parts[1], parts[2]);
          }
        } else if (value.includes("rgb")) {
          const parts = value.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter((val) => val !== "").map((val, index2) => index2 > 2 ? Number.parseFloat(val) : Number.parseInt(val, 10));
          if (parts.length === 4) {
            this._alpha = Number.parseFloat(parts[3]) * 100;
          } else if (parts.length === 3) {
            this._alpha = 100;
          }
          if (parts.length >= 3) {
            const { h: h2, s, v } = rgb2hsv(parts[0], parts[1], parts[2]);
            fromHSV(h2, s, v);
          }
        } else if (value.includes("#")) {
          const hex = value.replace("#", "").trim();
          if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(hex))
            return;
          let r, g, b;
          if (hex.length === 3) {
            r = parseHexChannel(hex[0] + hex[0]);
            g = parseHexChannel(hex[1] + hex[1]);
            b = parseHexChannel(hex[2] + hex[2]);
          } else if (hex.length === 6 || hex.length === 8) {
            r = parseHexChannel(hex.slice(0, 2));
            g = parseHexChannel(hex.slice(2, 4));
            b = parseHexChannel(hex.slice(4, 6));
          }
          if (hex.length === 8) {
            this._alpha = parseHexChannel(hex.slice(6)) / 255 * 100;
          } else if (hex.length === 3 || hex.length === 6) {
            this._alpha = 100;
          }
          const { h: h2, s, v } = rgb2hsv(r, g, b);
          fromHSV(h2, s, v);
        }
      }
      compare(color) {
        return Math.abs(color._hue - this._hue) < 2 && Math.abs(color._saturation - this._saturation) < 1 && Math.abs(color._value - this._value) < 1 && Math.abs(color._alpha - this._alpha) < 1;
      }
      doOnChange() {
        const { _hue, _saturation, _value, _alpha, format } = this;
        if (this.enableAlpha) {
          switch (format) {
            case "hsl": {
              const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
              this.value = `hsla(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%, ${this.get("alpha") / 100})`;
              break;
            }
            case "hsv": {
              this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%, ${this.get("alpha") / 100})`;
              break;
            }
            case "hex": {
              this.value = `${toHex(hsv2rgb(_hue, _saturation, _value))}${hexOne(_alpha * 255 / 100)}`;
              break;
            }
            default: {
              const { r, g, b } = hsv2rgb(_hue, _saturation, _value);
              this.value = `rgba(${r}, ${g}, ${b}, ${this.get("alpha") / 100})`;
            }
          }
        } else {
          switch (format) {
            case "hsl": {
              const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
              this.value = `hsl(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%)`;
              break;
            }
            case "hsv": {
              this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%)`;
              break;
            }
            case "rgb": {
              const { r, g, b } = hsv2rgb(_hue, _saturation, _value);
              this.value = `rgb(${r}, ${g}, ${b})`;
              break;
            }
            default: {
              this.value = toHex(hsv2rgb(_hue, _saturation, _value));
            }
          }
        }
      }
    }
    const _sfc_main$m = /* @__PURE__ */ defineComponent({
      props: {
        colors: {
          type: Array,
          required: true
        },
        color: {
          type: Object,
          required: true
        }
      },
      setup(props) {
        const ns = useNamespace("color-predefine");
        const { currentColor } = inject(colorPickerContextKey);
        const rgbaColors = ref(parseColors(props.colors, props.color));
        watch(() => currentColor.value, (val) => {
          const color = new Color();
          color.fromString(val);
          rgbaColors.value.forEach((item) => {
            item.selected = color.compare(item);
          });
        });
        watchEffect(() => {
          rgbaColors.value = parseColors(props.colors, props.color);
        });
        function handleSelect(index2) {
          props.color.fromString(props.colors[index2]);
        }
        function parseColors(colors, color) {
          return colors.map((value) => {
            const c = new Color();
            c.enableAlpha = true;
            c.format = "rgba";
            c.fromString(value);
            c.selected = c.value === color.value;
            return c;
          });
        }
        return {
          rgbaColors,
          handleSelect,
          ns
        };
      }
    });
    const _hoisted_1$h = ["onClick"];
    function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(_ctx.ns.b())
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.ns.e("colors"))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rgbaColors, (item, index2) => {
            return openBlock(), createElementBlock("div", {
              key: _ctx.colors[index2],
              class: normalizeClass([
                _ctx.ns.e("color-selector"),
                _ctx.ns.is("alpha", item._alpha < 100),
                { selected: item.selected }
              ]),
              onClick: ($event) => _ctx.handleSelect(index2)
            }, [
              createBaseVNode("div", {
                style: normalizeStyle({ backgroundColor: item.value })
              }, null, 4)
            ], 10, _hoisted_1$h);
          }), 128))
        ], 2)
      ], 2);
    }
    var Predefine = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$5], ["__file", "predefine.vue"]]);
    const _sfc_main$l = /* @__PURE__ */ defineComponent({
      name: "ElSlPanel",
      props: {
        color: {
          type: Object,
          required: true
        }
      },
      setup(props) {
        const ns = useNamespace("color-svpanel");
        const instance = getCurrentInstance();
        const cursorTop = ref(0);
        const cursorLeft = ref(0);
        const background = ref("hsl(0, 100%, 50%)");
        const colorValue = computed(() => {
          const hue = props.color.get("hue");
          const value = props.color.get("value");
          return { hue, value };
        });
        function update() {
          const saturation = props.color.get("saturation");
          const value = props.color.get("value");
          const el = instance.vnode.el;
          const { clientWidth: width, clientHeight: height } = el;
          cursorLeft.value = saturation * width / 100;
          cursorTop.value = (100 - value) * height / 100;
          background.value = `hsl(${props.color.get("hue")}, 100%, 50%)`;
        }
        function handleDrag(event) {
          const el = instance.vnode.el;
          const rect = el.getBoundingClientRect();
          const { clientX, clientY } = getClientXY(event);
          let left = clientX - rect.left;
          let top = clientY - rect.top;
          left = Math.max(0, left);
          left = Math.min(left, rect.width);
          top = Math.max(0, top);
          top = Math.min(top, rect.height);
          cursorLeft.value = left;
          cursorTop.value = top;
          props.color.set({
            saturation: left / rect.width * 100,
            value: 100 - top / rect.height * 100
          });
        }
        watch(() => colorValue.value, () => {
          update();
        });
        onMounted(() => {
          draggable(instance.vnode.el, {
            drag: (event) => {
              handleDrag(event);
            },
            end: (event) => {
              handleDrag(event);
            }
          });
          update();
        });
        return {
          cursorTop,
          cursorLeft,
          background,
          colorValue,
          handleDrag,
          update,
          ns
        };
      }
    });
    const _hoisted_1$g = /* @__PURE__ */ createBaseVNode("div", null, null, -1);
    const _hoisted_2$d = [
      _hoisted_1$g
    ];
    function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(_ctx.ns.b()),
        style: normalizeStyle({
          backgroundColor: _ctx.background
        })
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.ns.e("white"))
        }, null, 2),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.ns.e("black"))
        }, null, 2),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.ns.e("cursor")),
          style: normalizeStyle({
            top: _ctx.cursorTop + "px",
            left: _ctx.cursorLeft + "px"
          })
        }, _hoisted_2$d, 6)
      ], 6);
    }
    var SvPanel = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$4], ["__file", "sv-panel.vue"]]);
    const _hoisted_1$f = ["onKeydown"];
    const _hoisted_2$c = ["id", "aria-label", "aria-labelledby", "aria-description", "aria-disabled", "tabindex"];
    const __default__$6 = /* @__PURE__ */ defineComponent({
      name: "ElColorPicker"
    });
    const _sfc_main$k = /* @__PURE__ */ defineComponent({
      ...__default__$6,
      props: colorPickerProps,
      emits: colorPickerEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const { t } = useLocale();
        const ns = useNamespace("color");
        const { formItem } = useFormItem();
        const colorSize = useFormSize();
        const colorDisabled = useFormDisabled();
        const { inputId: buttonId, isLabeledByFormItem } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const hue = ref();
        const sv = ref();
        const alpha = ref();
        const popper = ref();
        const triggerRef = ref();
        const inputRef = ref();
        const {
          isFocused,
          handleFocus: _handleFocus,
          handleBlur
        } = useFocusController(triggerRef, {
          beforeBlur(event) {
            var _a2;
            return (_a2 = popper.value) == null ? void 0 : _a2.isFocusInsideContent(event);
          },
          afterBlur() {
            setShowPicker(false);
            resetColor();
          }
        });
        const handleFocus = (event) => {
          if (colorDisabled.value)
            return blur();
          _handleFocus(event);
        };
        let shouldActiveChange = true;
        const color = reactive(new Color({
          enableAlpha: props.showAlpha,
          format: props.colorFormat || "",
          value: props.modelValue
        }));
        const showPicker = ref(false);
        const showPanelColor = ref(false);
        const customInput = ref("");
        const displayedColor = computed(() => {
          if (!props.modelValue && !showPanelColor.value) {
            return "transparent";
          }
          return displayedRgb(color, props.showAlpha);
        });
        const currentColor = computed(() => {
          return !props.modelValue && !showPanelColor.value ? "" : color.value;
        });
        const buttonAriaLabel = computed(() => {
          return !isLabeledByFormItem.value ? props.label || t("el.colorpicker.defaultLabel") : void 0;
        });
        const buttonAriaLabelledby = computed(() => {
          return isLabeledByFormItem.value ? formItem == null ? void 0 : formItem.labelId : void 0;
        });
        const btnKls = computed(() => {
          return [
            ns.b("picker"),
            ns.is("disabled", colorDisabled.value),
            ns.bm("picker", colorSize.value),
            ns.is("focused", isFocused.value)
          ];
        });
        function displayedRgb(color2, showAlpha) {
          if (!(color2 instanceof Color)) {
            throw new TypeError("color should be instance of _color Class");
          }
          const { r, g, b } = color2.toRgb();
          return showAlpha ? `rgba(${r}, ${g}, ${b}, ${color2.get("alpha") / 100})` : `rgb(${r}, ${g}, ${b})`;
        }
        function setShowPicker(value) {
          showPicker.value = value;
        }
        const debounceSetShowPicker = debounce(setShowPicker, 100, { leading: true });
        function show() {
          if (colorDisabled.value)
            return;
          setShowPicker(true);
        }
        function hide() {
          debounceSetShowPicker(false);
          resetColor();
        }
        function resetColor() {
          nextTick(() => {
            if (props.modelValue) {
              color.fromString(props.modelValue);
            } else {
              color.value = "";
              nextTick(() => {
                showPanelColor.value = false;
              });
            }
          });
        }
        function handleTrigger() {
          if (colorDisabled.value)
            return;
          debounceSetShowPicker(!showPicker.value);
        }
        function handleConfirm() {
          color.fromString(customInput.value);
        }
        function confirmValue() {
          const value = color.value;
          emit2(UPDATE_MODEL_EVENT, value);
          emit2("change", value);
          if (props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
          }
          debounceSetShowPicker(false);
          nextTick(() => {
            const newColor = new Color({
              enableAlpha: props.showAlpha,
              format: props.colorFormat || "",
              value: props.modelValue
            });
            if (!color.compare(newColor)) {
              resetColor();
            }
          });
        }
        function clear2() {
          debounceSetShowPicker(false);
          emit2(UPDATE_MODEL_EVENT, null);
          emit2("change", null);
          if (props.modelValue !== null && props.validateEvent) {
            formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
          }
          resetColor();
        }
        function handleClickOutside(event) {
          if (!showPicker.value)
            return;
          hide();
          if (isFocused.value) {
            const _event2 = new FocusEvent("focus", event);
            handleBlur(_event2);
          }
        }
        function handleEsc(event) {
          event.preventDefault();
          event.stopPropagation();
          setShowPicker(false);
          resetColor();
        }
        function handleKeyDown(event) {
          switch (event.code) {
            case EVENT_CODE.enter:
            case EVENT_CODE.space:
              event.preventDefault();
              event.stopPropagation();
              show();
              inputRef.value.focus();
              break;
            case EVENT_CODE.esc:
              handleEsc(event);
              break;
          }
        }
        function focus() {
          triggerRef.value.focus();
        }
        function blur() {
          triggerRef.value.blur();
        }
        onMounted(() => {
          if (props.modelValue) {
            customInput.value = currentColor.value;
          }
        });
        watch(() => props.modelValue, (newVal) => {
          if (!newVal) {
            showPanelColor.value = false;
          } else if (newVal && newVal !== color.value) {
            shouldActiveChange = false;
            color.fromString(newVal);
          }
        });
        watch(() => currentColor.value, (val) => {
          customInput.value = val;
          shouldActiveChange && emit2("activeChange", val);
          shouldActiveChange = true;
        });
        watch(() => color.value, () => {
          if (!props.modelValue && !showPanelColor.value) {
            showPanelColor.value = true;
          }
        });
        watch(() => showPicker.value, () => {
          nextTick(() => {
            var _a2, _b, _c;
            (_a2 = hue.value) == null ? void 0 : _a2.update();
            (_b = sv.value) == null ? void 0 : _b.update();
            (_c = alpha.value) == null ? void 0 : _c.update();
          });
        });
        provide(colorPickerContextKey, {
          currentColor
        });
        expose({
          color,
          show,
          hide,
          focus,
          blur
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElTooltip), {
            ref_key: "popper",
            ref: popper,
            visible: showPicker.value,
            "show-arrow": false,
            "fallback-placements": ["bottom", "top", "right", "left"],
            offset: 0,
            "gpu-acceleration": false,
            "popper-class": [unref(ns).be("picker", "panel"), unref(ns).b("dropdown"), _ctx.popperClass],
            "stop-popper-mouse-event": false,
            effect: "light",
            trigger: "click",
            transition: `${unref(ns).namespace.value}-zoom-in-top`,
            persistent: "",
            onHide: _cache[2] || (_cache[2] = ($event) => setShowPicker(false))
          }, {
            content: withCtx(() => [
              withDirectives((openBlock(), createElementBlock("div", {
                onKeydown: withKeys(handleEsc, ["esc"])
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).be("dropdown", "main-wrapper"))
                }, [
                  createVNode(HueSlider, {
                    ref_key: "hue",
                    ref: hue,
                    class: "hue-slider",
                    color: unref(color),
                    vertical: ""
                  }, null, 8, ["color"]),
                  createVNode(SvPanel, {
                    ref_key: "sv",
                    ref: sv,
                    color: unref(color)
                  }, null, 8, ["color"])
                ], 2),
                _ctx.showAlpha ? (openBlock(), createBlock(AlphaSlider, {
                  key: 0,
                  ref_key: "alpha",
                  ref: alpha,
                  color: unref(color)
                }, null, 8, ["color"])) : createCommentVNode("v-if", true),
                _ctx.predefine ? (openBlock(), createBlock(Predefine, {
                  key: 1,
                  ref: "predefine",
                  color: unref(color),
                  colors: _ctx.predefine
                }, null, 8, ["color", "colors"])) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).be("dropdown", "btns"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(ns).be("dropdown", "value"))
                  }, [
                    createVNode(unref(ElInput), {
                      ref_key: "inputRef",
                      ref: inputRef,
                      modelValue: customInput.value,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => customInput.value = $event),
                      "validate-event": false,
                      size: "small",
                      onKeyup: withKeys(handleConfirm, ["enter"]),
                      onBlur: handleConfirm
                    }, null, 8, ["modelValue", "onKeyup"])
                  ], 2),
                  createVNode(unref(ElButton), {
                    class: normalizeClass(unref(ns).be("dropdown", "link-btn")),
                    text: "",
                    size: "small",
                    onClick: clear2
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(unref(t)("el.colorpicker.clear")), 1)
                    ]),
                    _: 1
                  }, 8, ["class"]),
                  createVNode(unref(ElButton), {
                    plain: "",
                    size: "small",
                    class: normalizeClass(unref(ns).be("dropdown", "btn")),
                    onClick: confirmValue
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(unref(t)("el.colorpicker.confirm")), 1)
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 2)
              ], 40, _hoisted_1$f)), [
                [unref(ClickOutside), handleClickOutside]
              ])
            ]),
            default: withCtx(() => [
              createBaseVNode("div", {
                id: unref(buttonId),
                ref_key: "triggerRef",
                ref: triggerRef,
                class: normalizeClass(unref(btnKls)),
                role: "button",
                "aria-label": unref(buttonAriaLabel),
                "aria-labelledby": unref(buttonAriaLabelledby),
                "aria-description": unref(t)("el.colorpicker.description", { color: _ctx.modelValue || "" }),
                "aria-disabled": unref(colorDisabled),
                tabindex: unref(colorDisabled) ? -1 : _ctx.tabindex,
                onKeydown: handleKeyDown,
                onFocus: handleFocus,
                onBlur: _cache[1] || (_cache[1] = (...args) => unref(handleBlur) && unref(handleBlur)(...args))
              }, [
                unref(colorDisabled) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(ns).be("picker", "mask"))
                }, null, 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  class: normalizeClass(unref(ns).be("picker", "trigger")),
                  onClick: handleTrigger
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass([unref(ns).be("picker", "color"), unref(ns).is("alpha", _ctx.showAlpha)])
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(unref(ns).be("picker", "color-inner")),
                      style: normalizeStyle({
                        backgroundColor: unref(displayedColor)
                      })
                    }, [
                      withDirectives(createVNode(unref(ElIcon), {
                        class: normalizeClass([unref(ns).be("picker", "icon"), unref(ns).is("icon-arrow-down")])
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(arrow_down_default))
                        ]),
                        _: 1
                      }, 8, ["class"]), [
                        [vShow, _ctx.modelValue || showPanelColor.value]
                      ]),
                      withDirectives(createVNode(unref(ElIcon), {
                        class: normalizeClass([unref(ns).be("picker", "empty"), unref(ns).is("icon-close")])
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(close_default))
                        ]),
                        _: 1
                      }, 8, ["class"]), [
                        [vShow, !_ctx.modelValue && !showPanelColor.value]
                      ])
                    ], 6)
                  ], 2)
                ], 2)
              ], 42, _hoisted_2$c)
            ]),
            _: 1
          }, 8, ["visible", "popper-class", "transition"]);
        };
      }
    });
    var ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__file", "color-picker.vue"]]);
    const ElColorPicker = withInstall(ColorPicker);
    const elPaginationKey = Symbol("elPaginationKey");
    const paginationPrevProps = buildProps({
      disabled: Boolean,
      currentPage: {
        type: Number,
        default: 1
      },
      prevText: {
        type: String
      },
      prevIcon: {
        type: iconPropType
      }
    });
    const paginationPrevEmits = {
      click: (evt) => evt instanceof MouseEvent
    };
    const _hoisted_1$e = ["disabled", "aria-label", "aria-disabled"];
    const _hoisted_2$b = { key: 0 };
    const __default__$5 = /* @__PURE__ */ defineComponent({
      name: "ElPaginationPrev"
    });
    const _sfc_main$j = /* @__PURE__ */ defineComponent({
      ...__default__$5,
      props: paginationPrevProps,
      emits: paginationPrevEmits,
      setup(__props) {
        const props = __props;
        const { t } = useLocale();
        const internalDisabled = computed(() => props.disabled || props.currentPage <= 1);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("button", {
            type: "button",
            class: "btn-prev",
            disabled: unref(internalDisabled),
            "aria-label": _ctx.prevText || unref(t)("el.pagination.prev"),
            "aria-disabled": unref(internalDisabled),
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
          }, [
            _ctx.prevText ? (openBlock(), createElementBlock("span", _hoisted_2$b, toDisplayString(_ctx.prevText), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.prevIcon)))
              ]),
              _: 1
            }))
          ], 8, _hoisted_1$e);
        };
      }
    });
    var Prev = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__file", "prev.vue"]]);
    const paginationNextProps = buildProps({
      disabled: Boolean,
      currentPage: {
        type: Number,
        default: 1
      },
      pageCount: {
        type: Number,
        default: 50
      },
      nextText: {
        type: String
      },
      nextIcon: {
        type: iconPropType
      }
    });
    const _hoisted_1$d = ["disabled", "aria-label", "aria-disabled"];
    const _hoisted_2$a = { key: 0 };
    const __default__$4 = /* @__PURE__ */ defineComponent({
      name: "ElPaginationNext"
    });
    const _sfc_main$i = /* @__PURE__ */ defineComponent({
      ...__default__$4,
      props: paginationNextProps,
      emits: ["click"],
      setup(__props) {
        const props = __props;
        const { t } = useLocale();
        const internalDisabled = computed(() => props.disabled || props.currentPage === props.pageCount || props.pageCount === 0);
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("button", {
            type: "button",
            class: "btn-next",
            disabled: unref(internalDisabled),
            "aria-label": _ctx.nextText || unref(t)("el.pagination.next"),
            "aria-disabled": unref(internalDisabled),
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
          }, [
            _ctx.nextText ? (openBlock(), createElementBlock("span", _hoisted_2$a, toDisplayString(_ctx.nextText), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.nextIcon)))
              ]),
              _: 1
            }))
          ], 8, _hoisted_1$d);
        };
      }
    });
    var Next = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__file", "next.vue"]]);
    const selectGroupKey = Symbol("ElSelectGroup");
    const selectKey = Symbol("ElSelect");
    function useOption(props, states) {
      const select = inject(selectKey);
      const selectGroup = inject(selectGroupKey, { disabled: false });
      const itemSelected = computed(() => {
        if (!select.props.multiple) {
          return isEqual(props.value, select.props.modelValue);
        } else {
          return contains(select.props.modelValue, props.value);
        }
      });
      const limitReached = computed(() => {
        if (select.props.multiple) {
          const modelValue = select.props.modelValue || [];
          return !itemSelected.value && modelValue.length >= select.props.multipleLimit && select.props.multipleLimit > 0;
        } else {
          return false;
        }
      });
      const currentLabel = computed(() => {
        return props.label || (isObject$1(props.value) ? "" : props.value);
      });
      const currentValue = computed(() => {
        return props.value || props.label || "";
      });
      const isDisabled = computed(() => {
        return props.disabled || states.groupDisabled || limitReached.value;
      });
      const instance = getCurrentInstance();
      const contains = (arr = [], target) => {
        if (!isObject$1(props.value)) {
          return arr && arr.includes(target);
        } else {
          const valueKey = select.props.valueKey;
          return arr && arr.some((item) => {
            return toRaw(get(item, valueKey)) === get(target, valueKey);
          });
        }
      };
      const hoverItem = () => {
        if (!props.disabled && !selectGroup.disabled) {
          select.states.hoveringIndex = select.optionsArray.indexOf(instance.proxy);
        }
      };
      const updateOption = (query) => {
        const regexp = new RegExp(escapeStringRegexp(query), "i");
        states.visible = regexp.test(currentLabel.value) || props.created;
      };
      watch(() => currentLabel.value, () => {
        if (!props.created && !select.props.remote)
          select.setSelected();
      });
      watch(() => props.value, (val, oldVal) => {
        const { remote, valueKey } = select.props;
        if (!isEqual(val, oldVal)) {
          select.onOptionDestroy(oldVal, instance.proxy);
          select.onOptionCreate(instance.proxy);
        }
        if (!props.created && !remote) {
          if (valueKey && isObject$1(val) && isObject$1(oldVal) && val[valueKey] === oldVal[valueKey]) {
            return;
          }
          select.setSelected();
        }
      });
      watch(() => selectGroup.disabled, () => {
        states.groupDisabled = selectGroup.disabled;
      }, { immediate: true });
      return {
        select,
        currentLabel,
        currentValue,
        itemSelected,
        isDisabled,
        hoverItem,
        updateOption
      };
    }
    const _sfc_main$h = /* @__PURE__ */ defineComponent({
      name: "ElOption",
      componentName: "ElOption",
      props: {
        value: {
          required: true,
          type: [String, Number, Boolean, Object]
        },
        label: [String, Number],
        created: Boolean,
        disabled: Boolean
      },
      setup(props) {
        const ns = useNamespace("select");
        const id = useId();
        const containerKls = computed(() => [
          ns.be("dropdown", "item"),
          ns.is("disabled", unref(isDisabled)),
          ns.is("selected", unref(itemSelected)),
          ns.is("hovering", unref(hover))
        ]);
        const states = reactive({
          index: -1,
          groupDisabled: false,
          visible: true,
          hover: false
        });
        const {
          currentLabel,
          itemSelected,
          isDisabled,
          select,
          hoverItem,
          updateOption
        } = useOption(props, states);
        const { visible, hover } = toRefs(states);
        const vm = getCurrentInstance().proxy;
        select.onOptionCreate(vm);
        onBeforeUnmount(() => {
          const key = vm.value;
          const { selected } = select.states;
          const selectedOptions = select.props.multiple ? selected : [selected];
          const doesSelected = selectedOptions.some((item) => {
            return item.value === vm.value;
          });
          nextTick(() => {
            if (select.states.cachedOptions.get(key) === vm && !doesSelected) {
              select.states.cachedOptions.delete(key);
            }
          });
          select.onOptionDestroy(key, vm);
        });
        function selectOptionClick() {
          if (props.disabled !== true && states.groupDisabled !== true) {
            select.handleOptionSelect(vm);
          }
        }
        return {
          ns,
          id,
          containerKls,
          currentLabel,
          itemSelected,
          isDisabled,
          select,
          hoverItem,
          updateOption,
          visible,
          hover,
          selectOptionClick,
          states
        };
      }
    });
    const _hoisted_1$c = ["id", "aria-disabled", "aria-selected"];
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("li", {
        id: _ctx.id,
        class: normalizeClass(_ctx.containerKls),
        role: "option",
        "aria-disabled": _ctx.isDisabled || void 0,
        "aria-selected": _ctx.itemSelected,
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
        onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createBaseVNode("span", null, toDisplayString(_ctx.currentLabel), 1)
        ])
      ], 42, _hoisted_1$c)), [
        [vShow, _ctx.visible]
      ]);
    }
    var Option = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$3], ["__file", "option.vue"]]);
    const _sfc_main$g = /* @__PURE__ */ defineComponent({
      name: "ElSelectDropdown",
      componentName: "ElSelectDropdown",
      setup() {
        const select = inject(selectKey);
        const ns = useNamespace("select");
        const popperClass = computed(() => select.props.popperClass);
        const isMultiple = computed(() => select.props.multiple);
        const isFitInputWidth = computed(() => select.props.fitInputWidth);
        const minWidth = ref("");
        function updateMinWidth() {
          var _a2;
          minWidth.value = `${(_a2 = select.selectRef) == null ? void 0 : _a2.offsetWidth}px`;
        }
        onMounted(() => {
          updateMinWidth();
          useResizeObserver(select.selectRef, updateMinWidth);
        });
        return {
          ns,
          minWidth,
          popperClass,
          isMultiple,
          isFitInputWidth
        };
      }
    });
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
        style: normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
      }, [
        _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.ns.be("dropdown", "header"))
        }, [
          renderSlot(_ctx.$slots, "header")
        ], 2)) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "default"),
        _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.ns.be("dropdown", "footer"))
        }, [
          renderSlot(_ctx.$slots, "footer")
        ], 2)) : createCommentVNode("v-if", true)
      ], 6);
    }
    var ElSelectMenu = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$2], ["__file", "select-dropdown.vue"]]);
    function useInput(handleInput) {
      const isComposing = ref(false);
      const handleCompositionStart = () => {
        isComposing.value = true;
      };
      const handleCompositionUpdate = (event) => {
        const text = event.target.value;
        const lastCharacter = text[text.length - 1] || "";
        isComposing.value = !isKorean(lastCharacter);
      };
      const handleCompositionEnd = (event) => {
        if (isComposing.value) {
          isComposing.value = false;
          if (isFunction$1(handleInput)) {
            handleInput(event);
          }
        }
      };
      return {
        handleCompositionStart,
        handleCompositionUpdate,
        handleCompositionEnd
      };
    }
    const MINIMUM_INPUT_WIDTH = 11;
    const useSelect = (props, emit2) => {
      const { t } = useLocale();
      const contentId = useId();
      const nsSelect = useNamespace("select");
      const nsInput = useNamespace("input");
      const states = reactive({
        inputValue: "",
        options: /* @__PURE__ */ new Map(),
        cachedOptions: /* @__PURE__ */ new Map(),
        disabledOptions: /* @__PURE__ */ new Map(),
        optionValues: [],
        selected: props.multiple ? [] : {},
        selectionWidth: 0,
        calculatorWidth: 0,
        collapseItemWidth: 0,
        selectedLabel: "",
        hoveringIndex: -1,
        previousQuery: null,
        inputHovering: false,
        menuVisibleOnFocus: false,
        isBeforeHide: false
      });
      useDeprecated({
        from: "suffixTransition",
        replacement: "override style scheme",
        version: "2.3.0",
        scope: "props",
        ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
      }, computed(() => props.suffixTransition === false));
      const selectRef = ref(null);
      const selectionRef = ref(null);
      const tooltipRef = ref(null);
      const tagTooltipRef = ref(null);
      const inputRef = ref(null);
      const calculatorRef = ref(null);
      const prefixRef = ref(null);
      const suffixRef = ref(null);
      const menuRef = ref(null);
      const tagMenuRef = ref(null);
      const collapseItemRef = ref(null);
      const scrollbarRef = ref(null);
      const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(inputRef, {
        afterFocus() {
          if (props.automaticDropdown && !expanded.value) {
            expanded.value = true;
            states.menuVisibleOnFocus = true;
          }
        },
        beforeBlur(event) {
          var _a2, _b;
          return ((_a2 = tooltipRef.value) == null ? void 0 : _a2.isFocusInsideContent(event)) || ((_b = tagTooltipRef.value) == null ? void 0 : _b.isFocusInsideContent(event));
        },
        afterBlur() {
          expanded.value = false;
          states.menuVisibleOnFocus = false;
        }
      });
      const expanded = ref(false);
      const hoverOption = ref();
      const { form, formItem } = useFormItem();
      const { inputId } = useFormItemInputId(props, {
        formItemContext: formItem
      });
      const selectDisabled = computed(() => props.disabled || (form == null ? void 0 : form.disabled));
      const hasModelValue = computed(() => {
        return props.multiple ? isArray$1(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
      });
      const showClose = computed(() => {
        const criteria = props.clearable && !selectDisabled.value && states.inputHovering && hasModelValue.value;
        return criteria;
      });
      const iconComponent = computed(() => props.remote && props.filterable && !props.remoteShowSuffix ? "" : props.suffixIcon);
      const iconReverse = computed(() => nsSelect.is("reverse", iconComponent.value && expanded.value && props.suffixTransition));
      const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
      const validateIcon = computed(() => ValidateComponentsMap[validateState.value]);
      const debounce$1 = computed(() => props.remote ? 300 : 0);
      const emptyText = computed(() => {
        if (props.loading) {
          return props.loadingText || t("el.select.loading");
        } else {
          if (props.remote && !states.inputValue && states.options.size === 0)
            return false;
          if (props.filterable && states.inputValue && states.options.size > 0 && filteredOptionsCount.value === 0) {
            return props.noMatchText || t("el.select.noMatch");
          }
          if (states.options.size === 0) {
            return props.noDataText || t("el.select.noData");
          }
        }
        return null;
      });
      const filteredOptionsCount = computed(() => optionsArray.value.filter((option) => option.visible).length);
      const optionsArray = computed(() => {
        const list = Array.from(states.options.values());
        const newList = [];
        states.optionValues.forEach((item) => {
          const index2 = list.findIndex((i) => i.value === item);
          if (index2 > -1) {
            newList.push(list[index2]);
          }
        });
        return newList.length >= list.length ? newList : list;
      });
      const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
      const showNewOption = computed(() => {
        const hasExistingOption = optionsArray.value.filter((option) => {
          return !option.created;
        }).some((option) => {
          return option.currentLabel === states.inputValue;
        });
        return props.filterable && props.allowCreate && states.inputValue !== "" && !hasExistingOption;
      });
      const updateOptions = () => {
        if (props.filterable && isFunction$1(props.filterMethod))
          return;
        if (props.filterable && props.remote && isFunction$1(props.remoteMethod))
          return;
        optionsArray.value.forEach((option) => {
          option.updateOption(states.inputValue);
        });
      };
      const selectSize = useFormSize();
      const collapseTagSize = computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
      const dropdownMenuVisible = computed({
        get() {
          return expanded.value && emptyText.value !== false;
        },
        set(val) {
          expanded.value = val;
        }
      });
      const shouldShowPlaceholder = computed(() => {
        if (isArray$1(props.modelValue)) {
          return props.modelValue.length === 0 && !states.inputValue;
        }
        return props.filterable ? !states.inputValue : true;
      });
      const currentPlaceholder = computed(() => {
        var _a2;
        const _placeholder = (_a2 = props.placeholder) != null ? _a2 : t("el.select.placeholder");
        return props.multiple || !hasModelValue.value ? _placeholder : states.selectedLabel;
      });
      watch(() => props.modelValue, (val, oldVal) => {
        if (props.multiple) {
          if (props.filterable && !props.reserveKeyword) {
            states.inputValue = "";
            handleQueryChange("");
          }
        }
        setSelected();
        if (!isEqual(val, oldVal) && props.validateEvent) {
          formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn(err));
        }
      }, {
        flush: "post",
        deep: true
      });
      watch(() => expanded.value, (val) => {
        if (val) {
          handleQueryChange(states.inputValue);
        } else {
          states.inputValue = "";
          states.previousQuery = null;
          states.isBeforeHide = true;
        }
        emit2("visible-change", val);
      });
      watch(() => states.options.entries(), () => {
        var _a2;
        if (!isClient)
          return;
        const inputs = ((_a2 = selectRef.value) == null ? void 0 : _a2.querySelectorAll("input")) || [];
        if (!props.filterable && !props.defaultFirstOption && !isUndefined(props.modelValue) || !Array.from(inputs).includes(document.activeElement)) {
          setSelected();
        }
        if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
          checkDefaultFirstOption();
        }
      }, {
        flush: "post"
      });
      watch(() => states.hoveringIndex, (val) => {
        if (isNumber(val) && val > -1) {
          hoverOption.value = optionsArray.value[val] || {};
        } else {
          hoverOption.value = {};
        }
        optionsArray.value.forEach((option) => {
          option.hover = hoverOption.value === option;
        });
      });
      watchEffect(() => {
        if (states.isBeforeHide)
          return;
        updateOptions();
      });
      const handleQueryChange = (val) => {
        if (states.previousQuery === val) {
          return;
        }
        states.previousQuery = val;
        if (props.filterable && isFunction$1(props.filterMethod)) {
          props.filterMethod(val);
        } else if (props.filterable && props.remote && isFunction$1(props.remoteMethod)) {
          props.remoteMethod(val);
        }
        if (props.defaultFirstOption && (props.filterable || props.remote) && filteredOptionsCount.value) {
          nextTick(checkDefaultFirstOption);
        } else {
          nextTick(updateHoveringIndex);
        }
      };
      const checkDefaultFirstOption = () => {
        const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
        const userCreatedOption = optionsInDropdown.find((n) => n.created);
        const firstOriginOption = optionsInDropdown[0];
        states.hoveringIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
      };
      const setSelected = () => {
        if (!props.multiple) {
          const option = getOption(props.modelValue);
          states.selectedLabel = option.currentLabel;
          states.selected = option;
          return;
        } else {
          states.selectedLabel = "";
        }
        const result = [];
        if (isArray$1(props.modelValue)) {
          props.modelValue.forEach((value) => {
            result.push(getOption(value));
          });
        }
        states.selected = result;
      };
      const getOption = (value) => {
        let option;
        const isObjectValue = toRawType(value).toLowerCase() === "object";
        const isNull = toRawType(value).toLowerCase() === "null";
        const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
        for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
          const cachedOption = cachedOptionsArray.value[i];
          const isEqualValue = isObjectValue ? get(cachedOption.value, props.valueKey) === get(value, props.valueKey) : cachedOption.value === value;
          if (isEqualValue) {
            option = {
              value,
              currentLabel: cachedOption.currentLabel,
              isDisabled: cachedOption.isDisabled
            };
            break;
          }
        }
        if (option)
          return option;
        const label = isObjectValue ? value.label : !isNull && !isUndefined2 ? value : "";
        const newOption = {
          value,
          currentLabel: label
        };
        return newOption;
      };
      const updateHoveringIndex = () => {
        if (!props.multiple) {
          states.hoveringIndex = optionsArray.value.findIndex((item) => {
            return getValueKey(item) === getValueKey(states.selected);
          });
        } else {
          if (states.selected.length > 0) {
            states.hoveringIndex = Math.min(...states.selected.map((selected) => {
              return optionsArray.value.findIndex((item) => {
                return getValueKey(item) === getValueKey(selected);
              });
            }));
          } else {
            states.hoveringIndex = -1;
          }
        }
      };
      const resetSelectionWidth = () => {
        states.selectionWidth = selectionRef.value.getBoundingClientRect().width;
      };
      const resetCalculatorWidth = () => {
        states.calculatorWidth = calculatorRef.value.getBoundingClientRect().width;
      };
      const resetCollapseItemWidth = () => {
        states.collapseItemWidth = collapseItemRef.value.getBoundingClientRect().width;
      };
      const updateTooltip = () => {
        var _a2, _b;
        (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
      };
      const updateTagTooltip = () => {
        var _a2, _b;
        (_b = (_a2 = tagTooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
      };
      const onInputChange = () => {
        if (states.inputValue.length > 0 && !expanded.value) {
          expanded.value = true;
        }
        handleQueryChange(states.inputValue);
      };
      const onInput = (event) => {
        states.inputValue = event.target.value;
        if (props.remote) {
          debouncedOnInputChange();
        } else {
          return onInputChange();
        }
      };
      const debouncedOnInputChange = debounce(() => {
        onInputChange();
      }, debounce$1.value);
      const emitChange = (val) => {
        if (!isEqual(props.modelValue, val)) {
          emit2(CHANGE_EVENT, val);
        }
      };
      const getLastNotDisabledIndex = (value) => findLastIndex(value, (it2) => !states.disabledOptions.has(it2));
      const deletePrevTag = (e) => {
        if (!props.multiple)
          return;
        if (e.code === EVENT_CODE.delete)
          return;
        if (e.target.value.length <= 0) {
          const value = props.modelValue.slice();
          const lastNotDisabledIndex = getLastNotDisabledIndex(value);
          if (lastNotDisabledIndex < 0)
            return;
          value.splice(lastNotDisabledIndex, 1);
          emit2(UPDATE_MODEL_EVENT, value);
          emitChange(value);
        }
      };
      const deleteTag = (event, tag) => {
        const index2 = states.selected.indexOf(tag);
        if (index2 > -1 && !selectDisabled.value) {
          const value = props.modelValue.slice();
          value.splice(index2, 1);
          emit2(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          emit2("remove-tag", tag.value);
        }
        event.stopPropagation();
        focus();
      };
      const deleteSelected = (event) => {
        event.stopPropagation();
        const value = props.multiple ? [] : "";
        if (!isString$2(value)) {
          for (const item of states.selected) {
            if (item.isDisabled)
              value.push(item.value);
          }
        }
        emit2(UPDATE_MODEL_EVENT, value);
        emitChange(value);
        states.hoveringIndex = -1;
        expanded.value = false;
        emit2("clear");
        focus();
      };
      const handleOptionSelect = (option) => {
        if (props.multiple) {
          const value = (props.modelValue || []).slice();
          const optionIndex = getValueIndex(value, option.value);
          if (optionIndex > -1) {
            value.splice(optionIndex, 1);
          } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
            value.push(option.value);
          }
          emit2(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          if (option.created) {
            handleQueryChange("");
          }
          if (props.filterable && !props.reserveKeyword) {
            states.inputValue = "";
          }
        } else {
          emit2(UPDATE_MODEL_EVENT, option.value);
          emitChange(option.value);
          expanded.value = false;
        }
        focus();
        if (expanded.value)
          return;
        nextTick(() => {
          scrollToOption(option);
        });
      };
      const getValueIndex = (arr = [], value) => {
        if (!isObject$1(value))
          return arr.indexOf(value);
        const valueKey = props.valueKey;
        let index2 = -1;
        arr.some((item, i) => {
          if (toRaw(get(item, valueKey)) === get(value, valueKey)) {
            index2 = i;
            return true;
          }
          return false;
        });
        return index2;
      };
      const scrollToOption = (option) => {
        var _a2, _b, _c, _d, _e;
        const targetOption = isArray$1(option) ? option[0] : option;
        let target = null;
        if (targetOption == null ? void 0 : targetOption.value) {
          const options = optionsArray.value.filter((item) => item.value === targetOption.value);
          if (options.length > 0) {
            target = options[0].$el;
          }
        }
        if (tooltipRef.value && target) {
          const menu = (_d = (_c = (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${nsSelect.be("dropdown", "wrap")}`);
          if (menu) {
            scrollIntoView(menu, target);
          }
        }
        (_e = scrollbarRef.value) == null ? void 0 : _e.handleScroll();
      };
      const onOptionCreate = (vm) => {
        states.options.set(vm.value, vm);
        states.cachedOptions.set(vm.value, vm);
        vm.disabled && states.disabledOptions.set(vm.value, vm);
      };
      const onOptionDestroy = (key, vm) => {
        if (states.options.get(key) === vm) {
          states.options.delete(key);
        }
      };
      const {
        handleCompositionStart,
        handleCompositionUpdate,
        handleCompositionEnd
      } = useInput((e) => onInput(e));
      const popperRef = computed(() => {
        var _a2, _b;
        return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
      });
      const handleMenuEnter = () => {
        nextTick(() => scrollToOption(states.selected));
      };
      const focus = () => {
        var _a2;
        (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
      };
      const blur = () => {
        handleClickOutside();
      };
      const handleClearClick = (event) => {
        deleteSelected(event);
      };
      const handleClickOutside = (event) => {
        expanded.value = false;
        if (isFocused.value) {
          const _event2 = new FocusEvent("focus", event);
          nextTick(() => handleBlur(_event2));
        }
      };
      const handleEsc = () => {
        if (states.inputValue.length > 0) {
          states.inputValue = "";
        } else {
          expanded.value = false;
        }
      };
      const toggleMenu = () => {
        if (selectDisabled.value)
          return;
        if (props.filterable && props.remote && isFunction$1(props.remoteMethod))
          return;
        if (states.menuVisibleOnFocus) {
          states.menuVisibleOnFocus = false;
        } else {
          expanded.value = !expanded.value;
        }
      };
      const selectOption = () => {
        if (!expanded.value) {
          toggleMenu();
        } else {
          if (optionsArray.value[states.hoveringIndex]) {
            handleOptionSelect(optionsArray.value[states.hoveringIndex]);
          }
        }
      };
      const getValueKey = (item) => {
        return isObject$1(item.value) ? get(item.value, props.valueKey) : item.value;
      };
      const optionsAllDisabled = computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
      const showTagList = computed(() => {
        if (!props.multiple) {
          return [];
        }
        return props.collapseTags ? states.selected.slice(0, props.maxCollapseTags) : states.selected;
      });
      const collapseTagList = computed(() => {
        if (!props.multiple) {
          return [];
        }
        return props.collapseTags ? states.selected.slice(props.maxCollapseTags) : [];
      });
      const navigateOptions = (direction) => {
        if (!expanded.value) {
          expanded.value = true;
          return;
        }
        if (states.options.size === 0 || filteredOptionsCount.value === 0)
          return;
        if (!optionsAllDisabled.value) {
          if (direction === "next") {
            states.hoveringIndex++;
            if (states.hoveringIndex === states.options.size) {
              states.hoveringIndex = 0;
            }
          } else if (direction === "prev") {
            states.hoveringIndex--;
            if (states.hoveringIndex < 0) {
              states.hoveringIndex = states.options.size - 1;
            }
          }
          const option = optionsArray.value[states.hoveringIndex];
          if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
            navigateOptions(direction);
          }
          nextTick(() => scrollToOption(hoverOption.value));
        }
      };
      const getGapWidth = () => {
        if (!selectionRef.value)
          return 0;
        const style = window.getComputedStyle(selectionRef.value);
        return Number.parseFloat(style.gap || "6px");
      };
      const tagStyle = computed(() => {
        const gapWidth = getGapWidth();
        const maxWidth = collapseItemRef.value && props.maxCollapseTags === 1 ? states.selectionWidth - states.collapseItemWidth - gapWidth : states.selectionWidth;
        return { maxWidth: `${maxWidth}px` };
      });
      const collapseTagStyle = computed(() => {
        return { maxWidth: `${states.selectionWidth}px` };
      });
      const inputStyle = computed(() => ({
        width: `${Math.max(states.calculatorWidth, MINIMUM_INPUT_WIDTH)}px`
      }));
      if (props.multiple && !isArray$1(props.modelValue)) {
        emit2(UPDATE_MODEL_EVENT, []);
      }
      if (!props.multiple && isArray$1(props.modelValue)) {
        emit2(UPDATE_MODEL_EVENT, "");
      }
      useResizeObserver(selectionRef, resetSelectionWidth);
      useResizeObserver(calculatorRef, resetCalculatorWidth);
      useResizeObserver(menuRef, updateTooltip);
      useResizeObserver(wrapperRef, updateTooltip);
      useResizeObserver(tagMenuRef, updateTagTooltip);
      useResizeObserver(collapseItemRef, resetCollapseItemWidth);
      onMounted(() => {
        setSelected();
      });
      return {
        inputId,
        contentId,
        nsSelect,
        nsInput,
        states,
        isFocused,
        expanded,
        optionsArray,
        hoverOption,
        selectSize,
        filteredOptionsCount,
        resetCalculatorWidth,
        updateTooltip,
        updateTagTooltip,
        debouncedOnInputChange,
        onInput,
        deletePrevTag,
        deleteTag,
        deleteSelected,
        handleOptionSelect,
        scrollToOption,
        hasModelValue,
        shouldShowPlaceholder,
        currentPlaceholder,
        showClose,
        iconComponent,
        iconReverse,
        validateState,
        validateIcon,
        showNewOption,
        updateOptions,
        collapseTagSize,
        setSelected,
        selectDisabled,
        emptyText,
        handleCompositionStart,
        handleCompositionUpdate,
        handleCompositionEnd,
        onOptionCreate,
        onOptionDestroy,
        handleMenuEnter,
        handleFocus,
        focus,
        blur,
        handleBlur,
        handleClearClick,
        handleClickOutside,
        handleEsc,
        toggleMenu,
        selectOption,
        getValueKey,
        navigateOptions,
        dropdownMenuVisible,
        showTagList,
        collapseTagList,
        tagStyle,
        collapseTagStyle,
        inputStyle,
        popperRef,
        inputRef,
        tooltipRef,
        tagTooltipRef,
        calculatorRef,
        prefixRef,
        suffixRef,
        selectRef,
        wrapperRef,
        selectionRef,
        scrollbarRef,
        menuRef,
        tagMenuRef,
        collapseItemRef
      };
    };
    var ElOptions = /* @__PURE__ */ defineComponent({
      name: "ElOptions",
      setup(_, { slots }) {
        const select = inject(selectKey);
        let cachedValueList = [];
        return () => {
          var _a2, _b;
          const children = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          const valueList = [];
          function filterOptions(children2) {
            if (!isArray$1(children2))
              return;
            children2.forEach((item) => {
              var _a22, _b2, _c, _d;
              const name = (_a22 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a22.name;
              if (name === "ElOptionGroup") {
                filterOptions(!isString$2(item.children) && !isArray$1(item.children) && isFunction$1((_b2 = item.children) == null ? void 0 : _b2.default) ? (_c = item.children) == null ? void 0 : _c.default() : item.children);
              } else if (name === "ElOption") {
                valueList.push((_d = item.props) == null ? void 0 : _d.value);
              } else if (isArray$1(item.children)) {
                filterOptions(item.children);
              }
            });
          }
          if (children.length) {
            filterOptions((_b = children[0]) == null ? void 0 : _b.children);
          }
          if (!isEqual(valueList, cachedValueList)) {
            cachedValueList = valueList;
            if (select) {
              select.states.optionValues = valueList;
            }
          }
          return children;
        };
      }
    });
    const SelectProps = buildProps({
      name: String,
      id: String,
      modelValue: {
        type: [Array, String, Number, Boolean, Object],
        default: void 0
      },
      autocomplete: {
        type: String,
        default: "off"
      },
      automaticDropdown: Boolean,
      size: useSizeProp,
      effect: {
        type: definePropType(String),
        default: "light"
      },
      disabled: Boolean,
      clearable: Boolean,
      filterable: Boolean,
      allowCreate: Boolean,
      loading: Boolean,
      popperClass: {
        type: String,
        default: ""
      },
      popperOptions: {
        type: definePropType(Object),
        default: () => ({})
      },
      remote: Boolean,
      loadingText: String,
      noMatchText: String,
      noDataText: String,
      remoteMethod: Function,
      filterMethod: Function,
      multiple: Boolean,
      multipleLimit: {
        type: Number,
        default: 0
      },
      placeholder: {
        type: String
      },
      defaultFirstOption: Boolean,
      reserveKeyword: {
        type: Boolean,
        default: true
      },
      valueKey: {
        type: String,
        default: "value"
      },
      collapseTags: Boolean,
      collapseTagsTooltip: Boolean,
      maxCollapseTags: {
        type: Number,
        default: 1
      },
      teleported: useTooltipContentProps.teleported,
      persistent: {
        type: Boolean,
        default: true
      },
      clearIcon: {
        type: iconPropType,
        default: circle_close_default
      },
      fitInputWidth: Boolean,
      suffixIcon: {
        type: iconPropType,
        default: arrow_down_default
      },
      tagType: { ...tagProps.type, default: "info" },
      validateEvent: {
        type: Boolean,
        default: true
      },
      remoteShowSuffix: Boolean,
      suffixTransition: {
        type: Boolean,
        default: true
      },
      placement: {
        type: definePropType(String),
        values: Ee,
        default: "bottom-start"
      },
      ariaLabel: {
        type: String,
        default: void 0
      }
    });
    const COMPONENT_NAME = "ElSelect";
    const _sfc_main$f = /* @__PURE__ */ defineComponent({
      name: COMPONENT_NAME,
      componentName: COMPONENT_NAME,
      components: {
        ElInput,
        ElSelectMenu,
        ElOption: Option,
        ElOptions,
        ElTag,
        ElScrollbar,
        ElTooltip,
        ElIcon
      },
      directives: { ClickOutside },
      props: SelectProps,
      emits: [
        UPDATE_MODEL_EVENT,
        CHANGE_EVENT,
        "remove-tag",
        "clear",
        "visible-change",
        "focus",
        "blur"
      ],
      setup(props, { emit: emit2 }) {
        const API = useSelect(props, emit2);
        provide(selectKey, reactive({
          props,
          states: API.states,
          optionsArray: API.optionsArray,
          handleOptionSelect: API.handleOptionSelect,
          onOptionCreate: API.onOptionCreate,
          onOptionDestroy: API.onOptionDestroy,
          selectRef: API.selectRef,
          setSelected: API.setSelected
        }));
        return {
          ...API
        };
      }
    });
    const _hoisted_1$b = ["id", "disabled", "autocomplete", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"];
    const _hoisted_2$9 = ["textContent"];
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_tag = resolveComponent("el-tag");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_el_option = resolveComponent("el-option");
      const _component_el_options = resolveComponent("el-options");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _component_el_select_menu = resolveComponent("el-select-menu");
      const _directive_click_outside = resolveDirective("click-outside");
      return withDirectives((openBlock(), createElementBlock("div", {
        ref: "selectRef",
        class: normalizeClass([_ctx.nsSelect.b(), _ctx.nsSelect.m(_ctx.selectSize)]),
        onMouseenter: _cache[14] || (_cache[14] = ($event) => _ctx.states.inputHovering = true),
        onMouseleave: _cache[15] || (_cache[15] = ($event) => _ctx.states.inputHovering = false),
        onClick: _cache[16] || (_cache[16] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
      }, [
        createVNode(_component_el_tooltip, {
          ref: "tooltipRef",
          visible: _ctx.dropdownMenuVisible,
          placement: _ctx.placement,
          teleported: _ctx.teleported,
          "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
          "popper-options": _ctx.popperOptions,
          "fallback-placements": ["bottom-start", "top-start", "right", "left"],
          effect: _ctx.effect,
          pure: "",
          trigger: "click",
          transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
          "stop-popper-mouse-event": false,
          "gpu-acceleration": false,
          persistent: _ctx.persistent,
          onBeforeShow: _ctx.handleMenuEnter,
          onHide: _cache[13] || (_cache[13] = ($event) => _ctx.states.isBeforeHide = false)
        }, {
          default: withCtx(() => {
            var _a2;
            return [
              createBaseVNode("div", {
                ref: "wrapperRef",
                class: normalizeClass([
                  _ctx.nsSelect.e("wrapper"),
                  _ctx.nsSelect.is("focused", _ctx.isFocused),
                  _ctx.nsSelect.is("hovering", _ctx.states.inputHovering),
                  _ctx.nsSelect.is("filterable", _ctx.filterable),
                  _ctx.nsSelect.is("disabled", _ctx.selectDisabled)
                ])
              }, [
                _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref: "prefixRef",
                  class: normalizeClass(_ctx.nsSelect.e("prefix"))
                }, [
                  renderSlot(_ctx.$slots, "prefix")
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("div", {
                  ref: "selectionRef",
                  class: normalizeClass([
                    _ctx.nsSelect.e("selection"),
                    _ctx.nsSelect.is("near", _ctx.multiple && !_ctx.$slots.prefix && !!_ctx.states.selected.length)
                  ])
                }, [
                  _ctx.multiple ? renderSlot(_ctx.$slots, "tag", { key: 0 }, () => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                      return openBlock(), createElementBlock("div", {
                        key: _ctx.getValueKey(item),
                        class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                      }, [
                        createVNode(_component_el_tag, {
                          closable: !_ctx.selectDisabled && !item.isDisabled,
                          size: _ctx.collapseTagSize,
                          type: _ctx.tagType,
                          "disable-transitions": "",
                          style: normalizeStyle(_ctx.tagStyle),
                          onClose: ($event) => _ctx.deleteTag($event, item)
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("span", {
                              class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                            }, toDisplayString(item.currentLabel), 3)
                          ]),
                          _: 2
                        }, 1032, ["closable", "size", "type", "style", "onClose"])
                      ], 2);
                    }), 128)),
                    _ctx.collapseTags && _ctx.states.selected.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tooltip, {
                      key: 0,
                      ref: "tagTooltipRef",
                      disabled: _ctx.dropdownMenuVisible || !_ctx.collapseTagsTooltip,
                      "fallback-placements": ["bottom", "top", "right", "left"],
                      effect: _ctx.effect,
                      placement: "bottom",
                      teleported: _ctx.teleported
                    }, {
                      default: withCtx(() => [
                        createBaseVNode("div", {
                          ref: "collapseItemRef",
                          class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                        }, [
                          createVNode(_component_el_tag, {
                            closable: false,
                            size: _ctx.collapseTagSize,
                            type: _ctx.tagType,
                            "disable-transitions": "",
                            style: normalizeStyle(_ctx.collapseTagStyle)
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                              }, " + " + toDisplayString(_ctx.states.selected.length - _ctx.maxCollapseTags), 3)
                            ]),
                            _: 1
                          }, 8, ["size", "type", "style"])
                        ], 2)
                      ]),
                      content: withCtx(() => [
                        createBaseVNode("div", {
                          ref: "tagMenuRef",
                          class: normalizeClass(_ctx.nsSelect.e("selection"))
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (item) => {
                            return openBlock(), createElementBlock("div", {
                              key: _ctx.getValueKey(item),
                              class: normalizeClass(_ctx.nsSelect.e("selected-item"))
                            }, [
                              createVNode(_component_el_tag, {
                                class: "in-tooltip",
                                closable: !_ctx.selectDisabled && !item.isDisabled,
                                size: _ctx.collapseTagSize,
                                type: _ctx.tagType,
                                "disable-transitions": "",
                                onClose: ($event) => _ctx.deleteTag($event, item)
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("span", {
                                    class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                                  }, toDisplayString(item.currentLabel), 3)
                                ]),
                                _: 2
                              }, 1032, ["closable", "size", "type", "onClose"])
                            ], 2);
                          }), 128))
                        ], 2)
                      ]),
                      _: 1
                    }, 8, ["disabled", "effect", "teleported"])) : createCommentVNode("v-if", true)
                  ]) : createCommentVNode("v-if", true),
                  !_ctx.selectDisabled ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass([
                      _ctx.nsSelect.e("selected-item"),
                      _ctx.nsSelect.e("input-wrapper"),
                      _ctx.nsSelect.is("hidden", !_ctx.filterable)
                    ])
                  }, [
                    withDirectives(createBaseVNode("input", {
                      id: _ctx.inputId,
                      ref: "inputRef",
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.states.inputValue = $event),
                      type: "text",
                      class: normalizeClass([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
                      disabled: _ctx.selectDisabled,
                      autocomplete: _ctx.autocomplete,
                      style: normalizeStyle(_ctx.inputStyle),
                      role: "combobox",
                      readonly: !_ctx.filterable,
                      spellcheck: "false",
                      "aria-activedescendant": ((_a2 = _ctx.hoverOption) == null ? void 0 : _a2.id) || "",
                      "aria-controls": _ctx.contentId,
                      "aria-expanded": _ctx.dropdownMenuVisible,
                      "aria-label": _ctx.ariaLabel,
                      "aria-autocomplete": "none",
                      "aria-haspopup": "listbox",
                      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                      onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                      onKeydown: [
                        _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                        _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                        _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => _ctx.handleEsc && _ctx.handleEsc(...args), ["stop", "prevent"]), ["esc"])),
                        _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                        _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["stop"]), ["delete"]))
                      ],
                      onCompositionstart: _cache[8] || (_cache[8] = (...args) => _ctx.handleCompositionStart && _ctx.handleCompositionStart(...args)),
                      onCompositionupdate: _cache[9] || (_cache[9] = (...args) => _ctx.handleCompositionUpdate && _ctx.handleCompositionUpdate(...args)),
                      onCompositionend: _cache[10] || (_cache[10] = (...args) => _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...args)),
                      onInput: _cache[11] || (_cache[11] = (...args) => _ctx.onInput && _ctx.onInput(...args)),
                      onClick: _cache[12] || (_cache[12] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
                    }, null, 46, _hoisted_1$b), [
                      [vModelText, _ctx.states.inputValue]
                    ]),
                    _ctx.filterable ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      ref: "calculatorRef",
                      "aria-hidden": "true",
                      class: normalizeClass(_ctx.nsSelect.e("input-calculator")),
                      textContent: toDisplayString(_ctx.states.inputValue)
                    }, null, 10, _hoisted_2$9)) : createCommentVNode("v-if", true)
                  ], 2)) : createCommentVNode("v-if", true),
                  _ctx.shouldShowPlaceholder ? (openBlock(), createElementBlock("div", {
                    key: 2,
                    class: normalizeClass([
                      _ctx.nsSelect.e("selected-item"),
                      _ctx.nsSelect.e("placeholder"),
                      _ctx.nsSelect.is("transparent", !_ctx.hasModelValue || _ctx.expanded && !_ctx.states.inputValue)
                    ])
                  }, [
                    createBaseVNode("span", null, toDisplayString(_ctx.currentPlaceholder), 1)
                  ], 2)) : createCommentVNode("v-if", true)
                ], 2),
                createBaseVNode("div", {
                  ref: "suffixRef",
                  class: normalizeClass(_ctx.nsSelect.e("suffix"))
                }, [
                  _ctx.iconComponent && !_ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
                    key: 0,
                    class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 1,
                    class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                    onClick: _ctx.handleClearClick
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
                  _ctx.validateState && _ctx.validateIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 2,
                    class: normalizeClass([_ctx.nsInput.e("icon"), _ctx.nsInput.e("validateIcon")])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.validateIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 2)
              ], 2)
            ];
          }),
          content: withCtx(() => [
            createVNode(_component_el_select_menu, { ref: "menuRef" }, {
              default: withCtx(() => [
                _ctx.$slots.header ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(_ctx.nsSelect.be("dropdown", "header"))
                }, [
                  renderSlot(_ctx.$slots, "header")
                ], 2)) : createCommentVNode("v-if", true),
                withDirectives(createVNode(_component_el_scrollbar, {
                  id: _ctx.contentId,
                  ref: "scrollbarRef",
                  tag: "ul",
                  "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                  "view-class": _ctx.nsSelect.be("dropdown", "list"),
                  class: normalizeClass([_ctx.nsSelect.is("empty", _ctx.filteredOptionsCount === 0)]),
                  role: "listbox",
                  "aria-label": _ctx.ariaLabel,
                  "aria-orientation": "vertical"
                }, {
                  default: withCtx(() => [
                    _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                      key: 0,
                      value: _ctx.states.inputValue,
                      created: true
                    }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                    createVNode(_component_el_options, null, {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "default")
                      ]),
                      _: 3
                    })
                  ]),
                  _: 3
                }, 8, ["id", "wrap-class", "view-class", "class", "aria-label"]), [
                  [vShow, _ctx.states.options.size > 0 && !_ctx.loading]
                ]),
                _ctx.$slots.loading && _ctx.loading ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(_ctx.nsSelect.be("dropdown", "loading"))
                }, [
                  renderSlot(_ctx.$slots, "loading")
                ], 2)) : _ctx.loading || _ctx.filteredOptionsCount === 0 ? (openBlock(), createElementBlock("div", {
                  key: 2,
                  class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                }, [
                  renderSlot(_ctx.$slots, "empty", {}, () => [
                    createBaseVNode("span", null, toDisplayString(_ctx.emptyText), 1)
                  ])
                ], 2)) : createCommentVNode("v-if", true),
                _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
                  key: 3,
                  class: normalizeClass(_ctx.nsSelect.be("dropdown", "footer"))
                }, [
                  renderSlot(_ctx.$slots, "footer")
                ], 2)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 512)
          ]),
          _: 3
        }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onBeforeShow"])
      ], 34)), [
        [_directive_click_outside, _ctx.handleClickOutside, _ctx.popperRef]
      ]);
    }
    var Select = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$1], ["__file", "select.vue"]]);
    const _sfc_main$e = /* @__PURE__ */ defineComponent({
      name: "ElOptionGroup",
      componentName: "ElOptionGroup",
      props: {
        label: String,
        disabled: Boolean
      },
      setup(props) {
        const ns = useNamespace("select");
        const groupRef = ref(null);
        const instance = getCurrentInstance();
        const children = ref([]);
        provide(selectGroupKey, reactive({
          ...toRefs(props)
        }));
        const visible = computed(() => children.value.some((option) => option.visible === true));
        const flattedChildren = (node) => {
          const children2 = [];
          if (isArray$1(node.children)) {
            node.children.forEach((child) => {
              var _a2;
              if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
                children2.push(child.component.proxy);
              } else if ((_a2 = child.children) == null ? void 0 : _a2.length) {
                children2.push(...flattedChildren(child));
              }
            });
          }
          return children2;
        };
        const updateChildren = () => {
          children.value = flattedChildren(instance.subTree);
        };
        onMounted(() => {
          updateChildren();
        });
        useMutationObserver(groupRef, updateChildren, {
          attributes: true,
          subtree: true,
          childList: true
        });
        return {
          groupRef,
          visible,
          ns
        };
      }
    });
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("ul", {
        ref: "groupRef",
        class: normalizeClass(_ctx.ns.be("group", "wrap"))
      }, [
        createBaseVNode("li", {
          class: normalizeClass(_ctx.ns.be("group", "title"))
        }, toDisplayString(_ctx.label), 3),
        createBaseVNode("li", null, [
          createBaseVNode("ul", {
            class: normalizeClass(_ctx.ns.b("group"))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2)
        ])
      ], 2)), [
        [vShow, _ctx.visible]
      ]);
    }
    var OptionGroup = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render], ["__file", "option-group.vue"]]);
    const ElSelect = withInstall(Select, {
      Option,
      OptionGroup
    });
    const ElOption = withNoopInstall(Option);
    withNoopInstall(OptionGroup);
    const usePagination = () => inject(elPaginationKey, {});
    const paginationSizesProps = buildProps({
      pageSize: {
        type: Number,
        required: true
      },
      pageSizes: {
        type: definePropType(Array),
        default: () => mutable([10, 20, 30, 40, 50, 100])
      },
      popperClass: {
        type: String
      },
      disabled: Boolean,
      teleported: Boolean,
      size: {
        type: String,
        values: componentSizes
      }
    });
    const __default__$3 = /* @__PURE__ */ defineComponent({
      name: "ElPaginationSizes"
    });
    const _sfc_main$d = /* @__PURE__ */ defineComponent({
      ...__default__$3,
      props: paginationSizesProps,
      emits: ["page-size-change"],
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const { t } = useLocale();
        const ns = useNamespace("pagination");
        const pagination = usePagination();
        const innerPageSize = ref(props.pageSize);
        watch(() => props.pageSizes, (newVal, oldVal) => {
          if (isEqual(newVal, oldVal))
            return;
          if (Array.isArray(newVal)) {
            const pageSize = newVal.includes(props.pageSize) ? props.pageSize : props.pageSizes[0];
            emit2("page-size-change", pageSize);
          }
        });
        watch(() => props.pageSize, (newVal) => {
          innerPageSize.value = newVal;
        });
        const innerPageSizes = computed(() => props.pageSizes);
        function handleChange(val) {
          var _a2;
          if (val !== innerPageSize.value) {
            innerPageSize.value = val;
            (_a2 = pagination.handleSizeChange) == null ? void 0 : _a2.call(pagination, Number(val));
          }
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            class: normalizeClass(unref(ns).e("sizes"))
          }, [
            createVNode(unref(ElSelect), {
              "model-value": innerPageSize.value,
              disabled: _ctx.disabled,
              "popper-class": _ctx.popperClass,
              size: _ctx.size,
              teleported: _ctx.teleported,
              "validate-event": false,
              onChange: handleChange
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(innerPageSizes), (item) => {
                  return openBlock(), createBlock(unref(ElOption), {
                    key: item,
                    value: item,
                    label: item + unref(t)("el.pagination.pagesize")
                  }, null, 8, ["value", "label"]);
                }), 128))
              ]),
              _: 1
            }, 8, ["model-value", "disabled", "popper-class", "size", "teleported"])
          ], 2);
        };
      }
    });
    var Sizes = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__file", "sizes.vue"]]);
    const paginationJumperProps = buildProps({
      size: {
        type: String,
        values: componentSizes
      }
    });
    const _hoisted_1$a = ["disabled"];
    const __default__$2 = /* @__PURE__ */ defineComponent({
      name: "ElPaginationJumper"
    });
    const _sfc_main$c = /* @__PURE__ */ defineComponent({
      ...__default__$2,
      props: paginationJumperProps,
      setup(__props) {
        const { t } = useLocale();
        const ns = useNamespace("pagination");
        const { pageCount, disabled, currentPage, changeEvent } = usePagination();
        const userInput = ref();
        const innerValue = computed(() => {
          var _a2;
          return (_a2 = userInput.value) != null ? _a2 : currentPage == null ? void 0 : currentPage.value;
        });
        function handleInput(val) {
          userInput.value = val ? +val : "";
        }
        function handleChange(val) {
          val = Math.trunc(+val);
          changeEvent == null ? void 0 : changeEvent(val);
          userInput.value = void 0;
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            class: normalizeClass(unref(ns).e("jump")),
            disabled: unref(disabled)
          }, [
            createBaseVNode("span", {
              class: normalizeClass([unref(ns).e("goto")])
            }, toDisplayString(unref(t)("el.pagination.goto")), 3),
            createVNode(unref(ElInput), {
              size: _ctx.size,
              class: normalizeClass([unref(ns).e("editor"), unref(ns).is("in-pagination")]),
              min: 1,
              max: unref(pageCount),
              disabled: unref(disabled),
              "model-value": unref(innerValue),
              "validate-event": false,
              label: unref(t)("el.pagination.page"),
              type: "number",
              "onUpdate:modelValue": handleInput,
              onChange: handleChange
            }, null, 8, ["size", "class", "max", "disabled", "model-value", "label"]),
            createBaseVNode("span", {
              class: normalizeClass([unref(ns).e("classifier")])
            }, toDisplayString(unref(t)("el.pagination.pageClassifier")), 3)
          ], 10, _hoisted_1$a);
        };
      }
    });
    var Jumper = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__file", "jumper.vue"]]);
    const paginationTotalProps = buildProps({
      total: {
        type: Number,
        default: 1e3
      }
    });
    const _hoisted_1$9 = ["disabled"];
    const __default__$1 = /* @__PURE__ */ defineComponent({
      name: "ElPaginationTotal"
    });
    const _sfc_main$b = /* @__PURE__ */ defineComponent({
      ...__default__$1,
      props: paginationTotalProps,
      setup(__props) {
        const { t } = useLocale();
        const ns = useNamespace("pagination");
        const { disabled } = usePagination();
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            class: normalizeClass(unref(ns).e("total")),
            disabled: unref(disabled)
          }, toDisplayString(unref(t)("el.pagination.total", {
            total: _ctx.total
          })), 11, _hoisted_1$9);
        };
      }
    });
    var Total = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__file", "total.vue"]]);
    const paginationPagerProps = buildProps({
      currentPage: {
        type: Number,
        default: 1
      },
      pageCount: {
        type: Number,
        required: true
      },
      pagerCount: {
        type: Number,
        default: 7
      },
      disabled: Boolean
    });
    const _hoisted_1$8 = ["onKeyup"];
    const _hoisted_2$8 = ["aria-current", "aria-label", "tabindex"];
    const _hoisted_3$7 = ["tabindex", "aria-label"];
    const _hoisted_4$7 = ["aria-current", "aria-label", "tabindex"];
    const _hoisted_5$6 = ["tabindex", "aria-label"];
    const _hoisted_6$4 = ["aria-current", "aria-label", "tabindex"];
    const __default__ = /* @__PURE__ */ defineComponent({
      name: "ElPaginationPager"
    });
    const _sfc_main$a = /* @__PURE__ */ defineComponent({
      ...__default__,
      props: paginationPagerProps,
      emits: ["change"],
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const nsPager = useNamespace("pager");
        const nsIcon = useNamespace("icon");
        const { t } = useLocale();
        const showPrevMore = ref(false);
        const showNextMore = ref(false);
        const quickPrevHover = ref(false);
        const quickNextHover = ref(false);
        const quickPrevFocus = ref(false);
        const quickNextFocus = ref(false);
        const pagers = computed(() => {
          const pagerCount = props.pagerCount;
          const halfPagerCount = (pagerCount - 1) / 2;
          const currentPage = Number(props.currentPage);
          const pageCount = Number(props.pageCount);
          let showPrevMore2 = false;
          let showNextMore2 = false;
          if (pageCount > pagerCount) {
            if (currentPage > pagerCount - halfPagerCount) {
              showPrevMore2 = true;
            }
            if (currentPage < pageCount - halfPagerCount) {
              showNextMore2 = true;
            }
          }
          const array = [];
          if (showPrevMore2 && !showNextMore2) {
            const startPage = pageCount - (pagerCount - 2);
            for (let i = startPage; i < pageCount; i++) {
              array.push(i);
            }
          } else if (!showPrevMore2 && showNextMore2) {
            for (let i = 2; i < pagerCount; i++) {
              array.push(i);
            }
          } else if (showPrevMore2 && showNextMore2) {
            const offset = Math.floor(pagerCount / 2) - 1;
            for (let i = currentPage - offset; i <= currentPage + offset; i++) {
              array.push(i);
            }
          } else {
            for (let i = 2; i < pageCount; i++) {
              array.push(i);
            }
          }
          return array;
        });
        const prevMoreKls = computed(() => [
          "more",
          "btn-quickprev",
          nsIcon.b(),
          nsPager.is("disabled", props.disabled)
        ]);
        const nextMoreKls = computed(() => [
          "more",
          "btn-quicknext",
          nsIcon.b(),
          nsPager.is("disabled", props.disabled)
        ]);
        const tabindex = computed(() => props.disabled ? -1 : 0);
        watchEffect(() => {
          const halfPagerCount = (props.pagerCount - 1) / 2;
          showPrevMore.value = false;
          showNextMore.value = false;
          if (props.pageCount > props.pagerCount) {
            if (props.currentPage > props.pagerCount - halfPagerCount) {
              showPrevMore.value = true;
            }
            if (props.currentPage < props.pageCount - halfPagerCount) {
              showNextMore.value = true;
            }
          }
        });
        function onMouseEnter(forward = false) {
          if (props.disabled)
            return;
          if (forward) {
            quickPrevHover.value = true;
          } else {
            quickNextHover.value = true;
          }
        }
        function onFocus(forward = false) {
          if (forward) {
            quickPrevFocus.value = true;
          } else {
            quickNextFocus.value = true;
          }
        }
        function onEnter(e) {
          const target = e.target;
          if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("number")) {
            const newPage = Number(target.textContent);
            if (newPage !== props.currentPage) {
              emit2("change", newPage);
            }
          } else if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("more")) {
            onPagerClick(e);
          }
        }
        function onPagerClick(event) {
          const target = event.target;
          if (target.tagName.toLowerCase() === "ul" || props.disabled) {
            return;
          }
          let newPage = Number(target.textContent);
          const pageCount = props.pageCount;
          const currentPage = props.currentPage;
          const pagerCountOffset = props.pagerCount - 2;
          if (target.className.includes("more")) {
            if (target.className.includes("quickprev")) {
              newPage = currentPage - pagerCountOffset;
            } else if (target.className.includes("quicknext")) {
              newPage = currentPage + pagerCountOffset;
            }
          }
          if (!Number.isNaN(+newPage)) {
            if (newPage < 1) {
              newPage = 1;
            }
            if (newPage > pageCount) {
              newPage = pageCount;
            }
          }
          if (newPage !== currentPage) {
            emit2("change", newPage);
          }
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("ul", {
            class: normalizeClass(unref(nsPager).b()),
            onClick: onPagerClick,
            onKeyup: withKeys(onEnter, ["enter"])
          }, [
            _ctx.pageCount > 0 ? (openBlock(), createElementBlock("li", {
              key: 0,
              class: normalizeClass([[
                unref(nsPager).is("active", _ctx.currentPage === 1),
                unref(nsPager).is("disabled", _ctx.disabled)
              ], "number"]),
              "aria-current": _ctx.currentPage === 1,
              "aria-label": unref(t)("el.pagination.currentPage", { pager: 1 }),
              tabindex: unref(tabindex)
            }, " 1 ", 10, _hoisted_2$8)) : createCommentVNode("v-if", true),
            showPrevMore.value ? (openBlock(), createElementBlock("li", {
              key: 1,
              class: normalizeClass(unref(prevMoreKls)),
              tabindex: unref(tabindex),
              "aria-label": unref(t)("el.pagination.prevPages", { pager: _ctx.pagerCount - 2 }),
              onMouseenter: _cache[0] || (_cache[0] = ($event) => onMouseEnter(true)),
              onMouseleave: _cache[1] || (_cache[1] = ($event) => quickPrevHover.value = false),
              onFocus: _cache[2] || (_cache[2] = ($event) => onFocus(true)),
              onBlur: _cache[3] || (_cache[3] = ($event) => quickPrevFocus.value = false)
            }, [
              (quickPrevHover.value || quickPrevFocus.value) && !_ctx.disabled ? (openBlock(), createBlock(unref(d_arrow_left_default), { key: 0 })) : (openBlock(), createBlock(unref(more_filled_default), { key: 1 }))
            ], 42, _hoisted_3$7)) : createCommentVNode("v-if", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(pagers), (pager) => {
              return openBlock(), createElementBlock("li", {
                key: pager,
                class: normalizeClass([[
                  unref(nsPager).is("active", _ctx.currentPage === pager),
                  unref(nsPager).is("disabled", _ctx.disabled)
                ], "number"]),
                "aria-current": _ctx.currentPage === pager,
                "aria-label": unref(t)("el.pagination.currentPage", { pager }),
                tabindex: unref(tabindex)
              }, toDisplayString(pager), 11, _hoisted_4$7);
            }), 128)),
            showNextMore.value ? (openBlock(), createElementBlock("li", {
              key: 2,
              class: normalizeClass(unref(nextMoreKls)),
              tabindex: unref(tabindex),
              "aria-label": unref(t)("el.pagination.nextPages", { pager: _ctx.pagerCount - 2 }),
              onMouseenter: _cache[4] || (_cache[4] = ($event) => onMouseEnter()),
              onMouseleave: _cache[5] || (_cache[5] = ($event) => quickNextHover.value = false),
              onFocus: _cache[6] || (_cache[6] = ($event) => onFocus()),
              onBlur: _cache[7] || (_cache[7] = ($event) => quickNextFocus.value = false)
            }, [
              (quickNextHover.value || quickNextFocus.value) && !_ctx.disabled ? (openBlock(), createBlock(unref(d_arrow_right_default), { key: 0 })) : (openBlock(), createBlock(unref(more_filled_default), { key: 1 }))
            ], 42, _hoisted_5$6)) : createCommentVNode("v-if", true),
            _ctx.pageCount > 1 ? (openBlock(), createElementBlock("li", {
              key: 3,
              class: normalizeClass([[
                unref(nsPager).is("active", _ctx.currentPage === _ctx.pageCount),
                unref(nsPager).is("disabled", _ctx.disabled)
              ], "number"]),
              "aria-current": _ctx.currentPage === _ctx.pageCount,
              "aria-label": unref(t)("el.pagination.currentPage", { pager: _ctx.pageCount }),
              tabindex: unref(tabindex)
            }, toDisplayString(_ctx.pageCount), 11, _hoisted_6$4)) : createCommentVNode("v-if", true)
          ], 42, _hoisted_1$8);
        };
      }
    });
    var Pager = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__file", "pager.vue"]]);
    const isAbsent = (v) => typeof v !== "number";
    const paginationProps = buildProps({
      pageSize: Number,
      defaultPageSize: Number,
      total: Number,
      pageCount: Number,
      pagerCount: {
        type: Number,
        validator: (value) => {
          return isNumber(value) && Math.trunc(value) === value && value > 4 && value < 22 && value % 2 === 1;
        },
        default: 7
      },
      currentPage: Number,
      defaultCurrentPage: Number,
      layout: {
        type: String,
        default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
      },
      pageSizes: {
        type: definePropType(Array),
        default: () => mutable([10, 20, 30, 40, 50, 100])
      },
      popperClass: {
        type: String,
        default: ""
      },
      prevText: {
        type: String,
        default: ""
      },
      prevIcon: {
        type: iconPropType,
        default: () => arrow_left_default
      },
      nextText: {
        type: String,
        default: ""
      },
      nextIcon: {
        type: iconPropType,
        default: () => arrow_right_default
      },
      teleported: {
        type: Boolean,
        default: true
      },
      small: Boolean,
      background: Boolean,
      disabled: Boolean,
      hideOnSinglePage: Boolean
    });
    const paginationEmits = {
      "update:current-page": (val) => isNumber(val),
      "update:page-size": (val) => isNumber(val),
      "size-change": (val) => isNumber(val),
      change: (currentPage, pageSize) => isNumber(currentPage) && isNumber(pageSize),
      "current-change": (val) => isNumber(val),
      "prev-click": (val) => isNumber(val),
      "next-click": (val) => isNumber(val)
    };
    const componentName = "ElPagination";
    var Pagination = /* @__PURE__ */ defineComponent({
      name: componentName,
      props: paginationProps,
      emits: paginationEmits,
      setup(props, { emit: emit2, slots }) {
        const { t } = useLocale();
        const ns = useNamespace("pagination");
        const vnodeProps = getCurrentInstance().vnode.props || {};
        const hasCurrentPageListener = "onUpdate:currentPage" in vnodeProps || "onUpdate:current-page" in vnodeProps || "onCurrentChange" in vnodeProps;
        const hasPageSizeListener = "onUpdate:pageSize" in vnodeProps || "onUpdate:page-size" in vnodeProps || "onSizeChange" in vnodeProps;
        const assertValidUsage = computed(() => {
          if (isAbsent(props.total) && isAbsent(props.pageCount))
            return false;
          if (!isAbsent(props.currentPage) && !hasCurrentPageListener)
            return false;
          if (props.layout.includes("sizes")) {
            if (!isAbsent(props.pageCount)) {
              if (!hasPageSizeListener)
                return false;
            } else if (!isAbsent(props.total)) {
              if (!isAbsent(props.pageSize)) {
                if (!hasPageSizeListener) {
                  return false;
                }
              }
            }
          }
          return true;
        });
        const innerPageSize = ref(isAbsent(props.defaultPageSize) ? 10 : props.defaultPageSize);
        const innerCurrentPage = ref(isAbsent(props.defaultCurrentPage) ? 1 : props.defaultCurrentPage);
        const pageSizeBridge = computed({
          get() {
            return isAbsent(props.pageSize) ? innerPageSize.value : props.pageSize;
          },
          set(v) {
            if (isAbsent(props.pageSize)) {
              innerPageSize.value = v;
            }
            if (hasPageSizeListener) {
              emit2("update:page-size", v);
              emit2("size-change", v);
            }
          }
        });
        const pageCountBridge = computed(() => {
          let pageCount = 0;
          if (!isAbsent(props.pageCount)) {
            pageCount = props.pageCount;
          } else if (!isAbsent(props.total)) {
            pageCount = Math.max(1, Math.ceil(props.total / pageSizeBridge.value));
          }
          return pageCount;
        });
        const currentPageBridge = computed({
          get() {
            return isAbsent(props.currentPage) ? innerCurrentPage.value : props.currentPage;
          },
          set(v) {
            let newCurrentPage = v;
            if (v < 1) {
              newCurrentPage = 1;
            } else if (v > pageCountBridge.value) {
              newCurrentPage = pageCountBridge.value;
            }
            if (isAbsent(props.currentPage)) {
              innerCurrentPage.value = newCurrentPage;
            }
            if (hasCurrentPageListener) {
              emit2("update:current-page", newCurrentPage);
              emit2("current-change", newCurrentPage);
            }
          }
        });
        watch(pageCountBridge, (val) => {
          if (currentPageBridge.value > val)
            currentPageBridge.value = val;
        });
        watch([currentPageBridge, pageSizeBridge], (value) => {
          emit2("change", ...value);
        }, { flush: "post" });
        function handleCurrentChange(val) {
          currentPageBridge.value = val;
        }
        function handleSizeChange(val) {
          pageSizeBridge.value = val;
          const newPageCount = pageCountBridge.value;
          if (currentPageBridge.value > newPageCount) {
            currentPageBridge.value = newPageCount;
          }
        }
        function prev() {
          if (props.disabled)
            return;
          currentPageBridge.value -= 1;
          emit2("prev-click", currentPageBridge.value);
        }
        function next() {
          if (props.disabled)
            return;
          currentPageBridge.value += 1;
          emit2("next-click", currentPageBridge.value);
        }
        function addClass(element, cls) {
          if (element) {
            if (!element.props) {
              element.props = {};
            }
            element.props.class = [element.props.class, cls].join(" ");
          }
        }
        provide(elPaginationKey, {
          pageCount: pageCountBridge,
          disabled: computed(() => props.disabled),
          currentPage: currentPageBridge,
          changeEvent: handleCurrentChange,
          handleSizeChange
        });
        return () => {
          var _a2, _b;
          if (!assertValidUsage.value) {
            debugWarn(componentName, t("el.pagination.deprecationWarning"));
            return null;
          }
          if (!props.layout)
            return null;
          if (props.hideOnSinglePage && pageCountBridge.value <= 1)
            return null;
          const rootChildren = [];
          const rightWrapperChildren = [];
          const rightWrapperRoot = h("div", { class: ns.e("rightwrapper") }, rightWrapperChildren);
          const TEMPLATE_MAP = {
            prev: h(Prev, {
              disabled: props.disabled,
              currentPage: currentPageBridge.value,
              prevText: props.prevText,
              prevIcon: props.prevIcon,
              onClick: prev
            }),
            jumper: h(Jumper, {
              size: props.small ? "small" : "default"
            }),
            pager: h(Pager, {
              currentPage: currentPageBridge.value,
              pageCount: pageCountBridge.value,
              pagerCount: props.pagerCount,
              onChange: handleCurrentChange,
              disabled: props.disabled
            }),
            next: h(Next, {
              disabled: props.disabled,
              currentPage: currentPageBridge.value,
              pageCount: pageCountBridge.value,
              nextText: props.nextText,
              nextIcon: props.nextIcon,
              onClick: next
            }),
            sizes: h(Sizes, {
              pageSize: pageSizeBridge.value,
              pageSizes: props.pageSizes,
              popperClass: props.popperClass,
              disabled: props.disabled,
              teleported: props.teleported,
              size: props.small ? "small" : "default"
            }),
            slot: (_b = (_a2 = slots == null ? void 0 : slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : null,
            total: h(Total, { total: isAbsent(props.total) ? 0 : props.total })
          };
          const components = props.layout.split(",").map((item) => item.trim());
          let haveRightWrapper = false;
          components.forEach((c) => {
            if (c === "->") {
              haveRightWrapper = true;
              return;
            }
            if (!haveRightWrapper) {
              rootChildren.push(TEMPLATE_MAP[c]);
            } else {
              rightWrapperChildren.push(TEMPLATE_MAP[c]);
            }
          });
          addClass(rootChildren[0], ns.is("first"));
          addClass(rootChildren[rootChildren.length - 1], ns.is("last"));
          if (haveRightWrapper && rightWrapperChildren.length > 0) {
            addClass(rightWrapperChildren[0], ns.is("first"));
            addClass(rightWrapperChildren[rightWrapperChildren.length - 1], ns.is("last"));
            rootChildren.push(rightWrapperRoot);
          }
          return h("div", {
            class: [
              ns.b(),
              ns.is("background", props.background),
              {
                [ns.m("small")]: props.small
              }
            ]
          }, rootChildren);
        };
      }
    });
    const ElPagination = withInstall(Pagination);
    const _withScopeId$5 = (n) => (pushScopeId("data-v-8c2d6ae3"), n = n(), popScopeId(), n);
    const _hoisted_1$7 = { class: "theme-color-component" };
    const _hoisted_2$7 = { class: "picker" };
    const _hoisted_3$6 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("label", { for: "light-theme" }, "浅色主题", -1));
    const _hoisted_4$6 = { class: "picker" };
    const _hoisted_5$5 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("label", { for: "dark-theme" }, "深色主题", -1));
    const _sfc_main$9 = /* @__PURE__ */ defineComponent({
      __name: "theme.color",
      setup(__props) {
        const lightTheme = ref(themeColor.get().light);
        const darkTheme = ref(themeColor.get().dark);
        function changeThemeColor() {
          themeColor.set({
            dark: darkTheme.value,
            light: lightTheme.value
          });
        }
        function resetThemeColor() {
          themeColor.remove();
          lightTheme.value = themeColor.get().light;
          darkTheme.value = themeColor.get().dark;
        }
        return (_ctx, _cache) => {
          const _component_el_color_picker = ElColorPicker;
          return openBlock(), createElementBlock("div", _hoisted_1$7, [
            createBaseVNode("div", _hoisted_2$7, [
              createVNode(_component_el_color_picker, {
                modelValue: lightTheme.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => lightTheme.value = $event),
                id: "light-theme",
                "popper-class": "theme-picker",
                size: "small",
                onChange: changeThemeColor
              }, null, 8, ["modelValue"]),
              _hoisted_3$6
            ]),
            createBaseVNode("div", _hoisted_4$6, [
              createVNode(_component_el_color_picker, {
                modelValue: darkTheme.value,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => darkTheme.value = $event),
                id: "dark-theme",
                "popper-class": "theme-picker",
                size: "small",
                onChange: changeThemeColor
              }, null, 8, ["modelValue"]),
              _hoisted_5$5
            ]),
            createVNode(_sfc_main$Q, {
              class: "reset-button",
              onClick: resetThemeColor
            }, {
              default: withCtx(() => [
                createTextVNode("重置")
              ]),
              _: 1
            })
          ]);
        };
      }
    });
    const ThemeColor = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["__scopeId", "data-v-8c2d6ae3"]]);
    const _sfc_main$8 = /* @__PURE__ */ defineComponent({
      __name: "toggle-button",
      props: {
        defaultValue: { type: Boolean },
        iconType: { type: Boolean },
        event: { type: Function }
      },
      setup(__props) {
        const props = __props;
        const toggleButton = ref();
        const currentValue = ref(props.defaultValue);
        function toggleValue() {
          currentValue.value = !currentValue.value;
          props.event && props.event(currentValue.value);
        }
        return (_ctx, _cache) => {
          return openBlock(), createBlock(_sfc_main$Q, {
            ref_key: "toggleButton",
            ref: toggleButton,
            class: normalizeClass(["toggle-button", { "toggle-on": currentValue.value, "toggle-off": !currentValue.value, "filled-icon": _ctx.iconType && currentValue.value, "outline-icon": _ctx.iconType && !currentValue.value }]),
            onClick: toggleValue,
            value: currentValue.value
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default", {}, void 0, true)
            ]),
            _: 3
          }, 8, ["class", "value"]);
        };
      }
    });
    const ToggleButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["__scopeId", "data-v-83f67b5d"]]);
    const _sfc_main$7 = /* @__PURE__ */ defineComponent({
      __name: "user-textbox",
      props: {
        modelValue: { default: "" },
        mutiLines: { type: Boolean },
        lodashStyle: { type: Boolean, default: false }
      },
      emits: ["update:modelValue"],
      setup(__props) {
        const props = __props;
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(props.mutiLines ? "textarea" : "input"), {
            class: normalizeClass(["user-textbox", { "lodash-style": props.lodashStyle }]),
            type: "text",
            value: _ctx.modelValue,
            onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event.target.value)),
            autocomplete: "off"
          }, null, 40, ["class", "value"]);
        };
      }
    });
    const _withScopeId$4 = (n) => (pushScopeId("data-v-dae045ee"), n = n(), popScopeId(), n);
    const _hoisted_1$6 = {
      class: "settings-wrapper remove-default"
    };
    const _hoisted_2$6 = {
      class: "left-container"
    };
    const _hoisted_3$5 = {
      class: "search-controls"
    };
    const _hoisted_4$5 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("div", {
      class: "title"
    }, "设置", -1));
    const _hoisted_5$4 = {
      class: "left-panel"
    };
    const _hoisted_6$3 = {
      class: "icon"
    };
    const _hoisted_7$2 = {
      class: "key-info"
    };
    const _hoisted_8$2 = {
      class: "key-title"
    };
    const _hoisted_9$2 = {
      class: "key-desc"
    };
    const _hoisted_10$2 = {
      class: "middle-container"
    };
    const _hoisted_11$1 = {
      class: "key-title"
    };
    const _hoisted_12$1 = {
      key: 0,
      class: "right-container"
    };
    const _hoisted_13$1 = {
      class: "setting-content"
    };
    const _hoisted_14$1 = {
      key: 0,
      class: "content-title"
    };
    const _hoisted_15$1 = {
      key: 1,
      class: "content-desc"
    };
    const _hoisted_16$1 = {
      class: "line"
    };
    const _hoisted_17$1 = {
      class: "setting-control"
    };
    const _hoisted_18$1 = {
      key: 1,
      class: "icon-component icon"
    };
    const _hoisted_19$1 = ["onChange"];
    const _hoisted_20$1 = ["value", "selected"];
    const _hoisted_21$1 = {
      key: 4,
      class: "content-sub-title"
    };
    const _hoisted_22$1 = {
      key: 5,
      class: "content-desc"
    };
    const _hoisted_23$1 = {
      class: "line"
    };
    const _hoisted_24$1 = ["src", "alt", "title", "onLoad"];
    const _hoisted_25$1 = {
      key: 1,
      class: "empty-container icon"
    };
    const _sfc_main$6 = /* @__PURE__ */ defineComponent({
      __name: "settings",
      setup(__props) {
        const disabledModulesRef = ref(disabledModules.get());
        ref(experimental.get());
        const updateConfigRef = ref(updateConfig.get());
        const searchText = ref("");
        const settings = {
          "visibility": {
            name: "显示",
            icon: "visibility",
            description: "主题、显示设置",
            sub: {
              "theme": {
                name: "主题",
                content: {
                  "switch-theme": {
                    title: "主题偏好设置",
                    description: `在自动模式下，将根据当前系统设置自动选择合适的主题。你也可以手动应用某一种主题。`,
                    widgets: [{
                      type: "select",
                      content: {
                        "自动": "auto",
                        "深色": "dark",
                        "浅色": "light"
                      },
                      init() {
                        return themeType.get();
                      },
                      event(e) {
                        const newValue = e.target.value;
                        themeType.set(newValue);
                        setTheme(newValue);
                      }
                    }]
                  },
                  "color": {
                    title: "主题颜色",
                    description: `自定义主题色。由于存在深浅两种主题，需要设置两种主题色。`,
                    widgets: [{
                      type: "component",
                      component: markRaw(ThemeColor)
                    }]
                  }
                }
              },
              "layout": {
                name: "页面布局",
                content: {
                  "compact-layout": {
                    title: "紧凑布局",
                    description: `在尽量保证视觉观感的请款下，针对部分页面应用更加紧凑的布局，以提高信息密度。当前会受到影响的页面有：新版看贴页面。`,
                    widgets: [{
                      type: "toggle",
                      init() {
                        return compactLayout.get();
                      },
                      event() {
                        compactLayout.set(!compactLayout.get());
                        document.body.toggleAttribute("compact-layout");
                        return compactLayout.get();
                      }
                    }]
                  },
                  "custom-background": {
                    title: "自定义背景图",
                    description: `上传图片作为页面背景图`,
                    widgets: [{
                      type: "component",
                      component: markRaw(LayoutCustomBack)
                    }]
                  },
                  "wide-screen-title": {
                    title: "宽屏设置",
                    description: `针对宽屏设备进行配置`,
                    widgets: [{
                      type: "subTitle",
                      content: "强制拉伸画幅"
                    }, {
                      type: "desc",
                      content: `对于宽屏设备，不一定需要页面内容宽度始终等于屏幕宽度。如果你想应用强制宽屏，可以开启此项。`
                    }, {
                      type: "toggle",
                      init() {
                        return wideScreen.get().noLimit;
                      },
                      event() {
                        const value = wideScreen.get().noLimit;
                        wideScreen.merge({
                          noLimit: !value
                        });
                        return !value;
                      }
                    }, {
                      type: "subTitle",
                      content: "最大宽度"
                    }, {
                      type: "desc",
                      content: `配置页面元素跟随屏幕拉伸的最大宽度，若开启了 “强制拉伸画幅” 则此项失效`
                    }, {
                      type: "textbox",
                      placeHolder: "输入最大宽度像素值",
                      init() {
                        return String(wideScreen.get().maxPX);
                      },
                      event(e) {
                        const newValue = e.target.value;
                        if (!isNaN(+newValue)) {
                          wideScreen.merge({
                            maxPX: +newValue
                          });
                        }
                      }
                    }]
                  }
                }
              },
              "page-extensions": {
                name: "页面扩展",
                content: {
                  "index": {
                    title: "新版主页",
                    description: `新版主页旨在提供纯粹的浏览体验，它通过 Vue 构建。
                            在新版主页上我们目前会更激进地测试一些新功能，包括尚未被广泛使用的新 Web API，以及自构建的 JavaScript 库。`,
                    widgets: [{
                      type: "toggle",
                      init() {
                        return pageExtensions.get().index;
                      },
                      event() {
                        pageExtensions.merge({
                          index: !pageExtensions.get().index
                        });
                        return pageExtensions.get().index;
                      }
                    }]
                  },
                  "thread": {
                    title: "新版看帖页面",
                    description: `新版看帖页面使用了全新的 UI 界面，并试图改进屏幕空间利用率。`,
                    widgets: [{
                      type: "toggle",
                      init() {
                        return pageExtensions.get().thread;
                      },
                      event() {
                        pageExtensions.merge({
                          thread: !pageExtensions.get().thread
                        });
                        return pageExtensions.get().thread;
                      }
                    }]
                  }
                }
              }
            }
          },
          "modules": {
            name: "模块",
            icon: "deployed_code",
            description: "用户模块管理及部署",
            sub: AllModules().reduce((accu, curr, index2) => {
              function toSubSettingKey(module2) {
                return {
                  name: module2.name,
                  description: module2.brief,
                  content: {
                    "module-info": {
                      title: module2.name,
                      description: `${module2.id} ${module2.version}
                                ${module2.description}`,
                      widgets: [{
                        type: "toggle",
                        init() {
                          return includes(disabledModulesRef.value, module2.id) ? false : true;
                        },
                        event() {
                          if (includes(disabledModulesRef.value, module2.id)) {
                            pull$1(disabledModulesRef.value, module2.id);
                            disabledModules.set([...new Set(disabledModulesRef.value)]);
                            return true;
                          } else {
                            disabledModulesRef.value.push(module2.id);
                            disabledModules.set([...new Set(disabledModulesRef.value)]);
                            return false;
                          }
                        }
                      }]
                    },
                    ...module2.settings
                  }
                };
              }
              if (index2 === 1) {
                const accuObject = toSubSettingKey(accu);
                accu = {};
                accu[accuObject.name] = accuObject;
              }
              accu[curr.name] = toSubSettingKey(curr);
              return accu;
            })
          },
          "enhanced": {
            name: "高级",
            icon: "labs",
            description: "提前测试一些尚不稳定的新功能",
            sub: {
              "experimental": {
                name: "实验性功能",
                content: {
                  "title": {
                    title: "实验室",
                    description: `本版块列举了一些实验性功能，这些功能正处于开发阶段，它们当中的大部分都是默认关闭的。
                            这些功能可能会产生已知、未知的错误或性能问题，如果这些问题能被更及时全面地反馈，将有助于整个项目的发展。
                            需要注意的是，这些特性并不保证会保留到后续版本中。`,
                    widgets: [{
                      type: "icon",
                      content: "lab_research"
                    }]
                  }
                }
                /* as KeyMapped<ReturnType<typeof experimental.get>, SettingContent> */
              },
              "backup-recover": {
                name: "备份与恢复",
                content: {
                  "data-backup": {
                    title: "数据备份",
                    description: `备份脚本所有自定义配置`,
                    widgets: [{
                      type: "button",
                      content: "备份",
                      event() {
                        backupUserConfigs();
                      }
                    }]
                  },
                  "recover-backup": {
                    title: "数据恢复",
                    description: `从备份文件中恢复脚本所有自定义配置`,
                    widgets: [{
                      type: "button",
                      content: "恢复",
                      event() {
                        restoreUserConfigs();
                      }
                    }]
                  }
                }
              },
              "factory-reset": {
                name: "重置所有配置",
                content: {
                  "title": {
                    title: "重置所有配置",
                    description: `如果你需要将脚本的一切配置恢复默认，请使用此功能。`
                  },
                  "reset": {
                    widgets: [{
                      type: "button",
                      content: "重置",
                      event() {
                        if (confirm("该操作是不可逆的，请做最后一次确认")) {
                          forEach(_GM_listValues(), (key) => {
                            _GM_deleteValue(key);
                          });
                          location.reload();
                        }
                      }
                    }]
                  }
                }
              }
            }
          },
          "about": {
            name: "关于",
            icon: "person",
            description: "开发信息与检查更新",
            sub: {
              "update": {
                name: "检查更新",
                content: {
                  "update-time": {
                    title: "检查更新设置",
                    description: `发行信息追踪频率`,
                    widgets: [{
                      type: "select",
                      content: {
                        "1 小时": "1h",
                        "3 小时": "3h",
                        "6 小时": "6h",
                        "从不": "never"
                      },
                      init() {
                        return updateConfig.get().time;
                      },
                      event(e) {
                        const newValue = e.target.value;
                        updateConfig.merge({
                          time: newValue
                        });
                      }
                    }]
                  },
                  "update-notify": {
                    description: `启用一个对话框提示用户更新。该对话框可以立即安装更新，也可以推迟更新操作。`,
                    widgets: [{
                      type: "toggle",
                      init() {
                        return updateConfigRef.value.notify;
                      },
                      event() {
                        const newValue = !updateConfig.get().notify;
                        updateConfigRef.value.notify = newValue;
                        updateConfig.merge({
                          notify: newValue
                        });
                      }
                    }]
                  },
                  "update-component": {
                    widgets: [{
                      type: "component",
                      component: markRaw(AboutUpdate)
                    }]
                  }
                }
              },
              "about": {
                name: "关于项目",
                content: {
                  "about-component": {
                    widgets: [{
                      type: "component",
                      component: markRaw(AboutDetail)
                    }]
                  }
                }
              }
            }
          }
        };
        const selectedKey = ref();
        const selectedSubKey = ref();
        function selectMainKey(key) {
          selectedKey.value = key;
          selectedSubKey.value = void 0;
        }
        function selectSubKey(key) {
          selectedSubKey.value = key;
        }
        function changeView(key, sub) {
          selectedKey.value = settings[key];
          selectedSubKey.value = settings[key].sub[sub];
        }
        function clearSelections() {
          selectedKey.value = void 0;
          selectedSubKey.value = void 0;
        }
        function searchKey() {
          if (searchText.value.length <= 0) {
            clearSelections();
            return;
          }
          if (!find$1(settings, (mainKey) => {
            if (find$1(mainKey.sub, (subKey) => {
              if (subKey.name.toLowerCase().includes(searchText.value.toLowerCase())) {
                selectedKey.value = mainKey;
                selectedSubKey.value = subKey;
                return true;
              } else {
                return false;
              }
            }))
              return true;
            else
              return false;
          }))
            clearSelections();
        }
        const debSearchKey = debounce(searchKey, 500);
        return (_ctx, _cache) => {
          var _a2, _b, _c;
          return openBlock(), createElementBlock("div", _hoisted_1$6, [createBaseVNode("div", _hoisted_2$6, [createBaseVNode("div", _hoisted_3$5, [_hoisted_4$5, createVNode(_sfc_main$7, {
            modelValue: searchText.value,
            "onUpdate:modelValue": [_cache[0] || (_cache[0] = ($event) => searchText.value = $event), unref(debSearchKey)],
            class: "search-box",
            placeholder: "输入需要搜索的设置"
          }, null, 8, ["modelValue", "onUpdate:modelValue"])]), createBaseVNode("div", _hoisted_5$4, [(openBlock(), createElementBlock(Fragment, null, renderList(settings, (setting) => {
            var _a3;
            return createVNode(_sfc_main$Q, {
              class: normalizeClass(["key-button main-key", {
                "selected": ((_a3 = selectedKey.value) == null ? void 0 : _a3.name) === setting.name
              }]),
              onClick: ($event) => selectMainKey(setting),
              "no-border": ""
            }, {
              default: withCtx(() => [createBaseVNode("div", _hoisted_6$3, toDisplayString(setting.icon), 1), createBaseVNode("div", _hoisted_7$2, [createBaseVNode("div", _hoisted_8$2, toDisplayString(setting.name), 1), createBaseVNode("div", _hoisted_9$2, toDisplayString(setting.description), 1)])]),
              _: 2
            }, 1032, ["class", "onClick"]);
          }), 64))])]), createBaseVNode("div", _hoisted_10$2, [(openBlock(true), createElementBlock(Fragment, null, renderList((_a2 = selectedKey.value) == null ? void 0 : _a2.sub, (setting) => {
            var _a3;
            return openBlock(), createBlock(_sfc_main$Q, {
              class: normalizeClass(["key-button sub-key", {
                "selected": ((_a3 = selectedSubKey.value) == null ? void 0 : _a3.name) === setting.name
              }]),
              onClick: ($event) => selectSubKey(setting),
              "no-border": ""
            }, {
              default: withCtx(() => [createBaseVNode("div", _hoisted_11$1, toDisplayString(setting.name), 1)]),
              _: 2
            }, 1032, ["class", "onClick"]);
          }), 256))]), ((_b = selectedSubKey.value) == null ? void 0 : _b.name) ? (openBlock(), createElementBlock("div", _hoisted_12$1, [((_c = selectedSubKey.value) == null ? void 0 : _c.name) ? (openBlock(true), createElementBlock(Fragment, {
            key: 0
          }, renderList(selectedSubKey.value.content, (content) => {
            return openBlock(), createElementBlock("div", _hoisted_13$1, [(content == null ? void 0 : content.title) ? (openBlock(), createElementBlock("div", _hoisted_14$1, toDisplayString(content == null ? void 0 : content.title), 1)) : createCommentVNode("", true), (content == null ? void 0 : content.description) ? (openBlock(), createElementBlock("div", _hoisted_15$1, [(content == null ? void 0 : content.description) ? (openBlock(true), createElementBlock(Fragment, {
              key: 0
            }, renderList(content.description.split("\n"), (line) => {
              return openBlock(), createElementBlock("div", _hoisted_16$1, toDisplayString(line), 1);
            }), 256)) : createCommentVNode("", true)])) : createCommentVNode("", true), (content == null ? void 0 : content.widgets) ? (openBlock(true), createElementBlock(Fragment, {
              key: 2
            }, renderList(content.widgets, (widget) => {
              var _a3;
              return openBlock(), createElementBlock("div", _hoisted_17$1, [widget.type === "toggle" ? (openBlock(), createBlock(ToggleButton, {
                key: 0,
                class: "settings-toggle-button icon",
                "default-value": widget.init ? widget.init() : void 0,
                onClick: widget.event,
                "icon-type": "",
                "no-border": ""
              }, null, 8, ["default-value", "onClick"])) : createCommentVNode("", true), widget.type === "icon" ? (openBlock(), createElementBlock("div", _hoisted_18$1, toDisplayString(widget.content), 1)) : createCommentVNode("", true), widget.type === "button" ? (openBlock(), createBlock(_sfc_main$Q, {
                key: 2,
                onClick: widget.event,
                "shadow-border": ""
              }, {
                default: withCtx(() => [createTextVNode(toDisplayString(widget.content), 1)]),
                _: 2
              }, 1032, ["onClick"])) : createCommentVNode("", true), widget.type === "select" && unref(isRealObject)(widget.content) ? (openBlock(), createElementBlock("select", {
                key: 3,
                onChange: widget.event
              }, [(openBlock(true), createElementBlock(Fragment, null, renderList(widget.content, (value, key) => {
                return openBlock(), createElementBlock("option", {
                  value,
                  selected: widget.init && value === widget.init()
                }, toDisplayString(key), 9, _hoisted_20$1);
              }), 256))], 40, _hoisted_19$1)) : createCommentVNode("", true), widget.type === "subTitle" ? (openBlock(), createElementBlock("div", _hoisted_21$1, toDisplayString(widget.content), 1)) : createCommentVNode("", true), widget.type === "desc" ? (openBlock(), createElementBlock("div", _hoisted_22$1, [widget.content ? (openBlock(true), createElementBlock(Fragment, {
                key: 0
              }, renderList(widget.content.split("\n"), (line) => {
                return openBlock(), createElementBlock("div", _hoisted_23$1, toDisplayString(line), 1);
              }), 256)) : createCommentVNode("", true)])) : createCommentVNode("", true), widget.type === "textbox" ? (openBlock(), createBlock(_sfc_main$7, {
                key: 6,
                class: "content-textbox",
                value: widget.init ? widget.init() : "",
                placeholder: widget.placeHolder,
                onChange: widget.event
              }, null, 8, ["value", "placeholder", "onChange"])) : createCommentVNode("", true), widget.type === "image" ? (openBlock(), createElementBlock("img", {
                key: 7,
                class: "content-image",
                src: (_a3 = widget.content) == null ? void 0 : _a3.toString(),
                alt: widget.altContent,
                title: widget.altContent,
                onLoad: widget.init
              }, null, 40, _hoisted_24$1)) : createCommentVNode("", true), widget.component ? (openBlock(), createBlock(resolveDynamicComponent(widget == null ? void 0 : widget.component), {
                key: 8,
                onChangeView: changeView
              }, null, 32)) : createCommentVNode("", true)]);
            }), 256)) : createCommentVNode("", true)]);
          }), 256)) : createCommentVNode("", true)])) : (openBlock(), createElementBlock("div", _hoisted_25$1, "settings"))]);
        };
      }
    });
    const Settings = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["__scopeId", "data-v-dae045ee"]]);
    const _withScopeId$3 = (n) => (pushScopeId("data-v-f0bb93e8"), n = n(), popScopeId(), n);
    const _hoisted_1$5 = { class: "index-wrapper" };
    const _hoisted_2$5 = { class: "grid-container" };
    const _hoisted_3$4 = { class: "head-controls" };
    const _hoisted_4$4 = { class: "search-controls" };
    const _hoisted_5$3 = { class: "search-suggestions" };
    const _hoisted_6$2 = ["src"];
    const _hoisted_7$1 = { class: "sugg-content" };
    const _hoisted_8$1 = { class: "sugg-title" };
    const _hoisted_9$1 = { class: "sugg-desc" };
    const _hoisted_10$1 = {
      key: 0,
      class: "block-wrapper followed-container"
    };
    const _hoisted_11 = { class: "block-controls followed" };
    const _hoisted_12 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("p", { class: "block-title" }, "关注的吧", -1));
    const _hoisted_13 = { class: "block-container followed-list" };
    const _hoisted_14 = {
      key: 0,
      class: "icon signed"
    };
    const _hoisted_15 = { class: "forum-title" };
    const _hoisted_16 = {
      key: 1,
      class: "block-wrapper topic-container"
    };
    const _hoisted_17 = { class: "block-controls topics" };
    const _hoisted_18 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("p", { class: "block-title" }, "贴吧热议", -1));
    const _hoisted_19 = { class: "block-container topic-list" };
    const _hoisted_20 = ["src"];
    const _hoisted_21 = { class: "topic-content" };
    const _hoisted_22 = { class: "topic-title" };
    const _hoisted_23 = { class: "topic-name" };
    const _hoisted_24 = { class: "topic-desc" };
    const _hoisted_25 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { id: "carousel_wrap" }, null, -1));
    const _hoisted_26 = {
      key: 0,
      class: "empty-container"
    };
    const _hoisted_27 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("p", { class: "no-feed-content" }, "没有更多了", -1));
    const _hoisted_28 = [
      _hoisted_27
    ];
    const _sfc_main$5 = /* @__PURE__ */ defineComponent({
      __name: "index",
      setup(__props) {
        const initFeeds = ref([]);
        const userInfo = ref();
        const followed = ref();
        const masonryContainer = ref();
        const feedsContainer = ref();
        const searchText = ref("");
        const suggToggle = ref(false);
        const suggestions = ref([]);
        ref(false);
        const configMenu = ref();
        ref(false);
        const profileMenu = ref();
        const topicList = ref([]);
        const feedsIntersecting = ref(false);
        let signedForums = 0;
        initFeeds.value = unreadFeeds.get();
        console.log("🚀 ~ file: index.vue:197 ~ initFeeds.value:", initFeeds.value);
        onMounted(async () => {
          init().then(() => {
            if (masonryContainer.value) {
              const iObs = new IntersectionObserver((entries) => {
                if (entries[0].isIntersecting) {
                  feedsIntersecting.value = true;
                } else {
                  feedsIntersecting.value = false;
                }
              });
              iObs.observe(masonryContainer.value);
            }
          });
        });
        window.addEventListener("focusin", (ev) => toggleSuggControls(ev));
        window.addEventListener("mousedown", (ev) => toggleSuggControls(ev));
        async function init() {
          userInfo.value = await (async () => {
            try {
              const userInfoResp = await (await tiebaAPI.userInfo()).json();
              if (userInfoResp) {
                return userInfoResp.data;
              }
            } catch (error) {
              toast({
                message: errorMessage(error),
                type: "error",
                duration: 6e3
              });
            }
          })();
          console.log("user info", userInfo.value);
          configMenu.value = [
            {
              title: "设置",
              click() {
                renderDialog(Settings);
              }
            },
            "separator",
            {
              title: "源代码 (GitHub)",
              href: GithubRepo
            },
            {
              title: "源代码 (Gitee)",
              href: GiteeRepo
            }
          ];
          profileMenu.value = [
            {
              title: "登录",
              icon: "login",
              href: BaiduPassport
            }
          ];
          if (userInfo.value) {
            profileMenu.value = [
              {
                title: "我的收藏",
                icon: "star"
              },
              "separator",
              {
                title: "主页",
                icon: "home",
                href: tiebaAPI.URL_userHome(userInfo.value.user_portrait)
              },
              {
                title: "修改",
                icon: "settings"
              },
              "separator",
              {
                title: "退出登录",
                icon: "logout"
              }
            ];
          }
          if (userInfo.value) {
            getFollowedInstance();
          }
          requestInstance(tiebaAPI.topicList()).then((response) => {
            if (response) {
              topicList.value.push(...response.data.bang_topic.topic_list);
            }
          });
          if (!feedsContainer.value)
            return;
        }
        function toggleSuggControls(e) {
          const el = e.target;
          const pt2 = findParentByClass(el, "search-controls");
          if (pt2) {
            suggToggle.value = true;
          } else {
            suggToggle.value = false;
          }
        }
        async function loadSuggestions(query) {
          const response = await tiebaAPI.suggestions(query);
          if (response.ok) {
            response.json().then((value) => {
              if (!query || query === "") {
                const topicList2 = value.hottopic_list.search_data;
                if (topicList2)
                  suggestions.value = map(topicList2, (topic) => ({
                    image: topic.topic_pic,
                    title: topic.topic_name,
                    desc: topic.topic_desc,
                    href: topic.topic_url
                  }));
              } else {
                const matchList = value.query_match.search_data;
                if (matchList)
                  suggestions.value = map(matchList, (match) => ({
                    image: match.fpic,
                    title: match.fname,
                    desc: match.forum_desc,
                    href: tiebaAPI.URL_forum(match.fname)
                  }));
              }
            });
          }
        }
        function searchBoxFocus() {
          if (suggestions.value.length <= 0) {
            loadSuggestions().then(() => {
              suggToggle.value = true;
            });
          } else {
            suggToggle.value = true;
          }
        }
        function searchTextChange() {
          loadSuggestions(searchText.value);
        }
        const searchMatch = debounce(searchTextChange, 500);
        function getFollowedInstance() {
          requestInstance(tiebaAPI.followedForums()).then((response) => {
            if (response) {
              signedForums = 0;
              followed.value = response.data;
              forEach(followed.value.like_forum, (forum) => {
                if (forum.is_sign === 1)
                  signedForums++;
              });
              followed.value.like_forum.sort((a, b) => parseInt(b.user_exp) - parseInt(a.user_exp));
            }
          });
        }
        async function oneKeySignInstance() {
          messageBox({
            title: "一键签到",
            message: "需要注意，Web端签到获取到的经验远少于移动端，建议使用其他设备进行签到。",
            type: "OkCancel"
          }).then((tag) => {
            if (tag === "positive") {
              requestInstance(tiebaAPI.oneKeySign()).then((response) => {
                toast({
                  message: `本次共签到成功 ${response.data.signedForumAmount} 个吧，未签到 ${response.data.unsignedForumAmount} 个吧，签到失败 ${response.data.signedForumAmountFail} 个吧，共获得 ${response.data.gradeNoVip} 经验。`,
                  type: "check",
                  blurEffect: true
                });
                getFollowedInstance();
              });
            }
          });
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$5, [
            createBaseVNode("div", _hoisted_2$5, [
              createBaseVNode("div", _hoisted_3$4, [
                createBaseVNode("div", _hoisted_4$4, [
                  createVNode(_sfc_main$7, {
                    modelValue: searchText.value,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchText.value = $event),
                    class: "search-box",
                    placeholder: "搜索 贴吧",
                    autocomplete: "none",
                    onFocus: searchBoxFocus,
                    onInput: unref(searchMatch)
                  }, null, 8, ["modelValue", "onInput"]),
                  createVNode(_sfc_main$Q, {
                    class: "search-button",
                    "theme-style": true,
                    "no-border": ""
                  }, {
                    default: withCtx(() => [
                      createTextVNode("搜索")
                    ]),
                    _: 1
                  }),
                  withDirectives(createBaseVNode("div", _hoisted_5$3, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(suggestions.value, (sugg) => {
                      return openBlock(), createBlock(_sfc_main$Q, {
                        "is-anchor": true,
                        class: "search-elem",
                        href: sugg.href,
                        target: "_blank",
                        "no-border": ""
                      }, {
                        default: withCtx(() => [
                          createBaseVNode("img", {
                            class: "sugg-img",
                            src: sugg.image,
                            alt: ""
                          }, null, 8, _hoisted_6$2),
                          createBaseVNode("div", _hoisted_7$1, [
                            createBaseVNode("p", _hoisted_8$1, toDisplayString(sugg.title), 1),
                            createBaseVNode("p", _hoisted_9$1, toDisplayString(sugg.desc), 1)
                          ])
                        ]),
                        _: 2
                      }, 1032, ["href"]);
                    }), 256))
                  ], 512), [
                    [vShow, suggToggle.value && suggestions.value.length > 0]
                  ])
                ])
              ]),
              followed.value ? (openBlock(), createElementBlock("div", _hoisted_10$1, [
                createBaseVNode("div", _hoisted_11, [
                  _hoisted_12,
                  createVNode(BlockPanel, { class: "signed-count left-align" }, {
                    default: withCtx(() => {
                      var _a2;
                      return [
                        createTextVNode(toDisplayString(unref(signedForums)) + " / " + toDisplayString((_a2 = followed.value) == null ? void 0 : _a2.like_forum.length), 1)
                      ];
                    }),
                    _: 1
                  }),
                  createVNode(BlockPanel, { class: "followed" }, {
                    default: withCtx(() => [
                      createVNode(_sfc_main$Q, {
                        class: "panel-btn icon sign-btn",
                        onClick: oneKeySignInstance,
                        "unset-background": "",
                        "no-border": ""
                      }, {
                        default: withCtx(() => [
                          createTextVNode(" task_alt")
                        ]),
                        _: 1
                      }),
                      createVNode(_sfc_main$Q, {
                        class: "panel-btn icon settings",
                        "unset-background": "",
                        "no-border": ""
                      }, {
                        default: withCtx(() => [
                          createTextVNode("settings")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                createBaseVNode("div", _hoisted_13, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(followed.value.like_forum, (forum) => {
                    return openBlock(), createBlock(_sfc_main$Q, {
                      "is-anchor": true,
                      class: "followed-btn",
                      "shadow-border": true,
                      href: unref(tiebaAPI).URL_forum(forum.forum_name),
                      target: "_blank",
                      "no-border": ""
                    }, {
                      default: withCtx(() => [
                        forum.is_sign === 1 ? (openBlock(), createElementBlock("div", _hoisted_14, "check")) : createCommentVNode("", true),
                        createBaseVNode("div", _hoisted_15, toDisplayString(forum.forum_name), 1),
                        createBaseVNode("div", {
                          class: normalizeClass(["forum-level", "level-" + unref(levelToClass)(forum.user_level)])
                        }, toDisplayString(forum.user_level), 3)
                      ]),
                      _: 2
                    }, 1032, ["href"]);
                  }), 256))
                ])
              ])) : createCommentVNode("", true),
              topicList.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_16, [
                createBaseVNode("div", _hoisted_17, [
                  _hoisted_18,
                  createVNode(BlockPanel, { class: "topics" }, {
                    default: withCtx(() => [
                      createVNode(_sfc_main$Q, {
                        class: "panel-btn icon switch",
                        "unset-background": true,
                        "no-border": ""
                      }, {
                        default: withCtx(() => [
                          createTextVNode("tune")
                        ]),
                        _: 1
                      }),
                      createVNode(_sfc_main$Q, {
                        class: "panel-btn icon more",
                        "unset-background": true,
                        "no-border": ""
                      }, {
                        default: withCtx(() => [
                          createTextVNode("more_horiz")
                        ]),
                        _: 1
                      }),
                      createVNode(_sfc_main$Q, {
                        class: "panel-btn icon settings",
                        "unset-background": true,
                        "no-border": ""
                      }, {
                        default: withCtx(() => [
                          createTextVNode("settings")
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                createBaseVNode("div", _hoisted_19, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(take)(topicList.value, 10), (topic) => {
                    return openBlock(), createBlock(_sfc_main$Q, {
                      "is-anchor": true,
                      class: "topic-btn",
                      "shadow-border": true,
                      href: topic.topic_url,
                      target: "_blank"
                    }, {
                      default: withCtx(() => [
                        createBaseVNode("img", {
                          class: "topic-img",
                          src: topic.topic_pic
                        }, null, 8, _hoisted_20),
                        createBaseVNode("div", _hoisted_21, [
                          createBaseVNode("div", _hoisted_22, [
                            createBaseVNode("div", {
                              class: normalizeClass("topic-rank-" + topic.idx_num)
                            }, toDisplayString(topic.idx_num), 3),
                            createBaseVNode("div", _hoisted_23, toDisplayString(topic.topic_name), 1)
                          ]),
                          createBaseVNode("div", _hoisted_24, toDisplayString(topic.topic_desc), 1)
                        ])
                      ]),
                      _: 2
                    }, 1032, ["href"]);
                  }), 256))
                ])
              ])) : createCommentVNode("", true),
              _hoisted_25
            ]),
            createBaseVNode("div", {
              ref_key: "masonryContainer",
              ref: masonryContainer,
              class: "masonry-container"
            }, [
              createVNode(FeedsMasonry, {
                "init-feeds": initFeeds.value,
                "show-progress": ""
              }, null, 8, ["init-feeds"]),
              initFeeds.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_26, _hoisted_28)) : createCommentVNode("", true)
            ], 512)
          ]);
        };
      }
    });
    const indexVue = /* @__PURE__ */ _export_sfc$1(_sfc_main$5, [["__scopeId", "data-v-f0bb93e8"]]);
    class TbObserver {
      constructor(selector, options, initEvent) {
        __publicField(this, "selector");
        __publicField(this, "options");
        __publicField(this, "initEvent");
        __publicField(this, "events", []);
        this.selector = selector;
        this.options = options;
        this.initEvent = initEvent;
      }
      observe() {
        const eventFuncs = () => {
          this.events.forEach((func) => {
            func();
          });
        };
        if (typeof this.initEvent === "undefined") {
          eventFuncs();
        } else {
          window.addEventListener(this.initEvent, eventFuncs);
        }
        const observer = new MutationObserver(eventFuncs);
        const obsElem = DOMS(this.selector)[0];
        if (obsElem !== void 0)
          observer.observe(obsElem, this.options);
      }
      addEvent(...events) {
        forEach(events, (event) => {
          if (this.events.includes(event))
            return;
          if (typeof this.initEvent === "undefined") {
            event();
          } else {
            window.addEventListener(this.initEvent, event);
          }
          this.events.push(event);
        });
      }
    }
    const remixedObservers = Object.freeze({
      /** 楼层监控 */
      postsObserver: new TbObserver("#j_p_postlist", { childList: true }),
      /** 楼中楼监控 */
      commentsObserver: new TbObserver("#j_p_postlist", { childList: true, subtree: true }),
      /** 首页动态监控 */
      newListObserver: new TbObserver("#new_list", { childList: true }),
      /** 进吧页面贴子监控 */
      threadListObserver: new TbObserver("#pagelet_frs-list\\/pagelet\\/thread", { attributes: true }, "load")
    });
    function parseUserModules(glob, callbackfn) {
      const modules2 = [];
      const moduleList = glob;
      const info = {
        length: Object.keys(moduleList).length,
        current: {
          runnable: false,
          url: ""
        }
      };
      for (const key in moduleList) {
        moduleList[key]().then(
          (value) => {
            const m = value.default;
            info.current.url = key;
            const runnable = (() => {
              if (m.switch === true || m.switch === void 0) {
                if (indexOf(disabledModules.get(), m.id) !== -1) {
                  return false;
                }
                if (m.scope === true) {
                  return true;
                }
                if (Array.isArray(m.scope)) {
                  for (let i = 0; i < m.scope.length; i++) {
                    const scope = m.scope[i];
                    if (currentPageType() === scope) {
                      return true;
                    }
                  }
                }
                if ({}.toString.call(m.scope) === "[object RegExp]") {
                  if (m.scope.test(location.href)) {
                    return true;
                  }
                }
              }
              return false;
            })();
            info.current.runnable = runnable;
            const runModule = {
              "immediately": () => {
                m.entry();
              },
              "afterHead": () => {
                afterHead(() => {
                  m.entry();
                });
              },
              "DOMLoaded": () => {
                document.addEventListener("DOMContentLoaded", () => {
                  m.entry();
                });
              },
              "loaded": () => {
                window.addEventListener("load", () => {
                  m.entry();
                });
              }
            };
            m.runnable = runnable;
            if (runnable) {
              runModule[m.runAt]();
            }
            modules2.push(m);
            if (callbackfn)
              callbackfn(info, m);
          }
        );
      }
      return modules2;
    }
    function hexToRGBA(hex) {
      const hexValue = startsWith(hex, "#") ? trimStart(hex, "#") : hex;
      const tokenConverter = hexValue.length <= 4 ? (chunk2) => parseInt(repeat(chunk2[0], 2), 16) : (chunk2) => parseInt(join(chunk2, ""), 16);
      const chunkSize = hexValue.length <= 4 ? 1 : 2;
      const chunks = chunk(hexValue, chunkSize);
      return {
        r: tokenConverter(chunks[0]),
        g: tokenConverter(chunks[1]),
        b: tokenConverter(chunks[2]),
        a: chunks.length === 4 ? tokenConverter(chunks[3]) : 1
      };
    }
    function rgbaToHSLA(rgba) {
      const normalizedR = rgba.r / 255;
      const normalizedG = rgba.g / 255;
      const normalizedB = rgba.b / 255;
      const minValue = Math.min(normalizedR, normalizedG, normalizedB);
      const maxValue = Math.max(normalizedR, normalizedG, normalizedB);
      const lightness = (maxValue + minValue) / 2;
      let saturation;
      if (lightness <= 0.5) {
        saturation = (maxValue - minValue) / (maxValue + minValue);
      } else {
        saturation = (maxValue - minValue) / (2 - maxValue - minValue);
      }
      let hue;
      if (maxValue === minValue) {
        hue = 0;
      } else if (maxValue === normalizedR) {
        hue = (normalizedG - normalizedB) / (maxValue - minValue);
      } else if (maxValue === normalizedG) {
        hue = 2 + (normalizedB - normalizedR) / (maxValue - minValue);
      } else {
        hue = 4 + (normalizedR - normalizedG) / (maxValue - minValue);
      }
      hue *= 60;
      if (hue < 0) {
        hue += 360;
      }
      return {
        h: round(hue, 2),
        s: `${round(saturation * 100)}%`,
        l: `${round(lightness * 100)}%`,
        a: rgba.a
      };
    }
    const favicon = "data:image/x-icon;base64,AAABAAMAEBAAAAEAIABoBAAANgAAABgYAAABACAAiAkAAJ4EAAAgIAAAAQAgAKgQAAAmDgAAKAAAABAAAAAgAAAAAQAgAAAAAAAABAAAvzIAAL8yAAAAAAAAAAAAAAAAAAAAAAAA/7grAP+4KwD/uCsA/7grAP+4K1D/uCub/7grKP+4KwD/uCsA/7grAP+4KwD/uCsA/7grAP+4KwAAAAAA/7grAP+4KwD/uSsA/7krGv+6K2f/uyu0/7or/v+6K9b/uSuU/7grjP+4K43/uCuB/7grPv+4KwP/uCsAAAAAALRviwD9ty8A/8IpIv63K8H1qS7/6pow/+eVMf/uny//+rAs//+5K///uCv//7gq//+4K+7/uCtn/7svAIJZ/wCgab0ApF+fAOOPNInLazn/skhE/6k7Rv+lNEL/qz1E/75cSf/agjX/+rIw//+8NP//uCv//7gr3P+4KyeCWf8AilTaAIZY70mhQGjloi5B/7RZaf/QlqD/s1Vl/82Qm//hvMT/2Kes//DQtv//24///7gq//+4K/b/uCtOgln/AIJZ/zCDWPncmjx3/6MwQf+nOkz/2Kiw/+fIzf/Yp6//48DG/75ue//NkqD/88+l//yzK///uCv3/7grUoJZ/wWCWf+fg1j6/5o8dv+jLj//sE9f/+PAxf/kwsj/4b3D/+bGy/+4YW//zI2Y/9usrP/lkjH//7or9/+4K1GCWf8sgln/44NY+v+aPHb/oi4//7RWZv/kw8j/5MLH/+XFyv/csLf/79ve/9+4vv/CeIf/x2Y5//+4K/f/uCtRgln/V4JZ//iDWPr/mjx2/6IuP/+0Vmb/5MHH/+XFyv/ds7r/rEVW/+C6wP+8aXf/q0VY/7hRQP/6sSz3/7krUYJZ/2SCWf/7g1j5/5o8dv+iLj//tFdm/+PBx//etbv/3ra9/6tEVf/lxcr/5cTJ/8+Vof+3UEX/+K4s9/+6K1KCWf9Pgln/9oNY+/+ZPXv/oy4//7BOX//iv8T/47/F/9mqsv+qQlP/3rW8/7RWZv+kNUr/ulM+//uzLPX/uStMgln/IoJZ/9mCWf//kkal/6MwQv+kM0b/qT5Q/6pBUv+oPE7/pTVH/7Vaaf+nOkz/oS5E/85wOP//uSvV/7grIYJY/gCCWf+Hgln//4VV7v+YPoH/ojJH/6MwQf+jMEH/ozBB/6MwQv+iLkD/oy9C/6w+Qv/qmTHj/7wqV/+4KwCCWf8Agln/HIJZ/8OCWf//hFf0/4xNxP+RR6v/kUep/5FHqf+RR6n/kUeq/5FGp/qqVXSR/7UkLP//AAD/uCsAgln/AIJZ/wCCWf8qgln/t4JZ//yCWv//gVr//4Fa//+BWv//gVr//4Fa/+yBWv97YV3/B96aWwD/xigA/7grAIJZ/wCCWf8Agln/AIJZ/xSCWf91gln/z4JZ//eCWf/+gln/64JZ/6+CWf9Hgln/AoJZ/wCCWf8Ak2XgAAAAAADAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAKAAAABgAAAAwAAAAAQAgAAAAAAAACQAAvzIAAL8yAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAYBAP+4KwD/uCsA/7grAP+4Kx3/uCun/7grS/+4KwT/uCsA/7grAP+4KwD/uCsA/7grAP+4KwD/uCsA/7grAP+4KwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD+uCsA/7grAP+4KwD/uCsA/7grAv+4Kyn/uCvi/7gr7/+4K5f/uCsu/7grDf+4Kw3/uCsN/7grDf+4Kwv+tysA/7grAP+4KwD/uCsAjGYXAAAAAAAAAAAAAAAAAP+4KwD/uCsA/7grAP+4Kwr/uCtZ/7grqf+4K83/uCv4/7gr//+4K///uCvl/7gryP+4K8j/uCvI/7gryP+4K8L/uCuW/7grO/64KgH/uCsA/7grAAAAAAAAAAAAAAAAAP+4KwD/uCsA/7grD/+5K5j/uiv6/7kr//22K//7siz/+7Ms//62K///uiv//7or//+4K///uCv//7gr//+4K///uCv//7gr6v+4K2X/uCsB/7grAAAAAAAAAAAAgln+AP/VIQDllTkA/7wqd/uyLP/mlDL/z3E4/79aPP+5UT7/uVI+/8FdPP/RdTf/6Zgw//y0LP//uiv//7gr//+4Kv//uCv//7gr//+4K+v/uCs8/7grAAAAAACCWP8Agln/AMqJdQD6rSMW4Is0071XPf+nNkP/ozFG/6MxR/+hLkP/oS9E/6AsQv+mOEz/rUNM/8BaOf/ply3//rgu//+8Nv//uCz//7gr//+4K///uCuY/rcrAQEBAgCCWf8Agln/AG9i/weUUbWBpjlL+qIvRP+iLkL/wHF+/9iosP+qQVP/qDtN/8J2g//RmaL/4r/G/8eEkf/Sk4z/9tOk///ntP7/vDb//7gq//+4K///uCvD/7grDoJZ/wCCWf8Agln/A4Fa/36JUNX6oTNO/6MxQ/+iMEP/slJi/+rP1P/YqLD/yYaR/+7a3f/ft73/+fLz/+zU2P/r0tf/8uPp///y2P//vTn//7gq//+4K///uCvJ/7grEYJZ/wCCWf8Agln/U4Ja//OJUNb/oTNN/6MxQ/+jMUT/ozFE/8Bxfv/16Or/7tnc/86Qmv/VoKn/4bzC/6g9T/+mOEv/x4KO//Th2P/wpj3//7kq//+4K///uCvJ/7grEYJZ/wCCWf8Ugln/yIJa//+JUNX/oTNN/6MxQ/+iL0L/s1Vk/+PBx//u2d3/2Kiw/9+4v//nys7/37e+/6U2SP+jMUT/xX6K/+zV2v/Ha0j//LMr//+4K///uCvJ/7grEYJZ/wCCWf9Zgln/+4Ja//+JUNX/oTNN/6MxQ/+iLkL/t11s/+3W2v/kw8j/3ra8/+zV2P/s1Nj/9+zu/+XEyv/kw8n/8N3g/+7Z3f+uRk//6Zcw//+6K///uCvJ/7grEYJZ/gKCWf+fgln//4Ja//+JUNX/oTNN/6MxQ/+iLkL/tlxr/+zT1//hvML/4bzC/+zV2f/Sm6T/0Jag//Pj5v/q0dX/0Zeh/8eCjf+lNkr/0HM3//+5K///uCvJ/7grEYJZ/xKCWf/Kgln//4Ja//+JUNX/oTNN/6MxQ/+iLkL/tlxr/+zT1//hvML/4bzC/+3W2v+7Z3T/oi5B/+PBx//TnKX/nyk9/6EsQP+hLkT/wFs8//22K///uCvJ/7grEYJZ/x+CWf/bgln//4Ja//+JUNX/oTNN/6MxQ/+iLkL/tlxr/+vT1//ivcP/4r7D/+3W2v+8aHb/ozFE/+PBxv/s1Nj/1J+n/9Odpv+wTmD/t049//uyLP//uCvJ/7grEYJZ/yCCWf/cgln//4Ja//+JUNX/oTNN/6MxQ/+iLkL/tlxr/+3W2v/Tnqf/052m/+7Z3P+8aHb/ozFE/+PAxv/z5Of/48DG/+K9w/+0WGn/tk08//uxLP//uCvJ/7grEYJZ/xWCWf/Ogln//4Ja//+JUdf/oTNO/6MxQ/+iLkL/tltq//bs7f/v297/7trd//nx8v+7ZnT/ozFE/+XEyf/Voar/ozFE/6Q0R/+iMEX/vlg9//21LP//uCvI/7grEIJZ/wSCWf+pgln//4JZ//+GVOj/nzZc/6MxQv+jMEP/qT9R/8F1gv/EfIj/xHuI/8J3hP+rQ1X/pDNF/9mqsf/MjJf/oi9C/6MxRP+iL0T/zW85//+5K///uCut/7grBYJZ/wCCWf9mgln//oJZ//+CWf3/lkGQ/6QwQf+jMUT/ozBD/6IuQf+hLUH/oS1B/6EuQf+jMEP/ozFE/6g9T/+nOkz/ozFE/6MxRP+mNUP/5ZIy//+6K/v/uCte/7grAIJZ/wCCWf8dgln/1oJZ//+CWf//h1Pk/5w6bf+kMEH/ozFC/6MxQ/+jMUT/ozFE/6MxRP+jMUT/ozFD/6MwQ/+jMEP/ozFE/6IvRP+8VT3/+rEs//+5K53/uCsM/7grAIJZ/wCCWf8Agln/aIJZ//uCWf//gln//4dT5P+WQY7/nzZa/6EzTf+iM0z/ojNM/6IzTP+iM0z/ojNM/6IzTP+iM0z/oTNN/6U4S/vfiTTX/7sqff+4KxD/uCsA/7grAIJZ/wCCWf8Agln/CYJZ/5iCWf//gln//4JZ//+CWf3/hlTm/4lQ1f+KUNP/ilDT/4pQ0/+KUNP/ilDT/4pQ0/+KUNP/ik/S+5RQtIb2qCcZt1dTAP+4KwD/uCsA/7grAIJZ/gCCWf8Agln/AIJZ/xKCWf+Zgln/+4JZ//+CWf//gln//4Ja//+CWv//glr//4Ja//+CWv//glr//4Ja//+CWv/1gVr/hHFh/wnKh3UA/9EjAP+4KwD/uCsAAAAAAAAAAACCWf8Agln/AIJZ/wCCWf8Jgln/aIJZ/9WCWf/9gln//4JZ//+CWf//gln//4JZ//+CWf//gln/+4JZ/8uCWf9Xgln/BIJZ/wCCWf8Agln/AAAAAAAAAAAAAAAAAAAAAAAAAAAAgln+AIJZ/wCCWf8Agln/AIJZ/yOCWf94gln/xIJZ/+6CWf/+gln//YJZ/+qCWf+8gln/bIJZ/xuCWf8Agln/AIJZ/wCCWf8AAAAAAAAAAAAAAAAAAAAAAPgAAwDwAAAA4AAAAOAAAADAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQCAAAcAwAAPACgAAAAgAAAAQAAAAAEAIAAAAAAAABAAAL8yAAC/MgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+4KwD+uCsC/7griv+4K3j/uCsS/7grAP+4KwD/uCsA/7grAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7grAP+4KwD/uCsA/7grAP+4KwD/uCui/7gr/v+4K7v/uCtN/7grB/+4KwD/uCsA/7grAP+4KwD/uCsA/7grAP+4KwD/uCsA/7grAP+4KwD/uCsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/rgrAP+4KwD/uCsA/7grAP+4KwP/uCsc/7grMf+4K7X/uCv//7gr//+4K/T/uCum/7grRf+4KzL/uCsz/7grM/+4KzP/uCsz/7grL/+4Kxr/uCsC/7grAP+4KwD/uCsA/bgqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+5KwD/uCsA/7grAP63KgH/uCs8/7grof+4K9v/uCvu/7gr+f+4K///uCv//7gr//+4K///uCv1/7gr7/+4K+//uCvv/7gr7/+4K+//uCvt/7gr2f+4K5r/uCs1/7ksAP+4KwD/uCsAJBoGAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7grAP+4KwD/uCsD/7grav+4K+r/uCv//7kr//+6K///uiv//7or//+6K///uiv//7or//+5K///uCv//7gr//+4K///uCv//7gr//+4K///uCv//7gr//+4K+X/uCte/7grAf+4KwD/uCsAAAAAAAAAAAAAAAAAAAAAAG5QEwD+tyoA/7grAP+4K1f/uSvy/7or//uyLP/voS//4o4z/9mBNf/WfDb/2YA1/+GMM//tnjD/+bAs//+5K///uSv//7gr//+4K///uCv//7gr//+4K///uCv//7gr//+4K+z/uCtJ/7grAP+4KwAAAAAAAAAAAAAAAAAAAAAAdE//AP+7KwD/vioX/7krzfSoLv/WfTb+u1Q+/6s9Qv+lM0P/ozBE/6IwRP+jMET/pDNE/6k6Qv+3Tj7/0XU3/vCiL///uCv//7kr//+4K///uCr//7gr//+4K///uCv//7gr//+4K8D/uCsQ/7grAAAAAAAAAAAAAAAAAIJZ/wCCWf4A0I1pAPOmLFLZgDX6skdA/6MxRP+iL0T/ozFF/6QzRv+iMEP/ozFE/6MxRP+iLkL/ozFF/6g9Uf+lN0v/rD4+/9F0Nf73qyr//7ku//+7Nf//uS3//7gr//+4K///uCv//7gr9v+4K0T/uCsAAAAAAAAAAACCWf4Agln/AIJZ/wB9XP8eokt9tqU0Q/+iMET/ozFE/6MwQ//Ee4f/2amx/61HWP+iL0L/pTVI/7ljcf+1WGf/5sjN/9elrv+3Xm//uGFv/9KGZv7605L+/+3J/v/FUf//tyn//7gr//+4K///uCv//7grb/+4KwAAAAAAgln+AIJZ/wCCWf8Agln/IIJa/7yUQ5r/ozBB/6MxRP+jMUT/ozFE/8mFkP/79vf/48DG/6k+T/+5Y3H/9+zu/9qrs/716Or///////z4+P/8+Pn/+/f5//79/f///fj//8ld//+3KP//uCv//7gr//+4K///uCt7/7grAAAAAACCWf8Agln/AIJZ/xCCWf+tgln//5RDmf+kMEH/ozFE/6MxRP+jMUT/ozFE/8uKlf/9+vr/05yl/+TCyP/26uz/wXWB//Tn6f/q0NT/zpKc/8+Tnf/OkZv/5MPJ///89v/9xlz//7co//+4K///uCv//7gr//+4K3v/uCsAglj9AIJZ/wCEW/8Agln/fIJZ//6CWf//lEOZ/6QwQf+jMUT/ozFE/6MxRP+kNEb/rkla/+jM0f/68/T/8d/i/8+TnP+yUmL/9urs/9aiq/+hLD//oi5B/6ArPv/Li5b/+/f4/96ZZf78syn//7gr//+4K///uCv//7gre/+4KwCCWf8Agln/AIJZ/zCCWf/lgln//4JZ//+UQ5n/pDBB/6MxRP+jMUT/oi9C/7VZaP/pzdH/4bzC//rz9P/Hgo3/4b3D/9uutv726uz/1aKq/6EsP/+hLUH/oCo+/8uLlv/79/j/vWhu/+WRL///uiv//7gr//+4K///uCt7/7grAIJZ/wCCWf8Agln/jYJZ//+CWf//gln//5RDmf+kMEH/ozFE/6MxRP+iLkH/uWJw//ny8//Xpa3/+fLz/82Pmf/v3N//6MvQ//Xp6//lxMr/w3iF/8N5hv/Cd4T/3ra8//v3+P+3X3D/wVw5//21LP//uCv//7gr//+4K3v/uCsAgln/AIJZ/xqCWf/Xgln//4JZ//+CWf//lEOZ/6QwQf+jMUT/ozFE/6IuQf+4YW//+PDy/9GYof/37e//052m/+/a3v/nyc7/8+Xn///+/v/+/f3//v7+//78/P/+/f3/+vT1/7hgb/+qOj//7qAw//+5K///uCv//7gre/+4KwCCWf8Agln/SoJZ//iCWf//gln//4JZ//+UQ5n/pDBB/6MxRP+jMUT/oi5B/7hhb//48PL/0JWf//bs7f/UoKj/79zf/9+4vv++bnv/wneD/+jL0P/58/T/yomU/8J2gv/Bc4D/qkFT/6MwQ//agTX//7or//+4K///uCt7/7grAIJZ/wCCWf93gln//4JZ//+CWf//gln//5RDmf+kMEH/ozFE/6MxRP+iLkH/uGFv//jw8v/Qlp//9uzu/9SgqP7v3N//26+2/6EtQf+hLUH/26+3//bs7f+tSFn/oCo9/6EsP/+iL0L/oS9E/8loOv//uCv//7gr//+4K3v/uCsAgln/AIJZ/5WCWf//gln//4JZ//+CWf//lEOZ/6QwQf+jMUT/ozFE/6IuQf+4YW//+PDy/9CWn//37O7/1KCo/u/c3//br7b/ozBD/6MxRP/csbj/+O/x/7tmdP+vTFz/sE5e/6tDVP+iL0T/vlk9//21LP//uCv//7gre/+4KwCAWf0Bgln/oIJZ//+CWf//gln//4JZ//+UQ5n/pDBB/6MxRP+jMUT/oi5B/7hhb//48PL/0Jaf//ju8P/Voan+79zf/9uvtv+jMEP/ozFE/9uvt///////+O/x//ft7v/48PH/2Kiw/6IwRf+6Uz7//LMs//+4K///uCt7/7grAH1X+QCCWf+dgln//4JZ//+CWf//gln//5RDmf+kMEH/ozFE/6MxRP+iLkH/uGFv//ny8//MjZf/1KCo/8Z+iv/x3+L/26+2/6MwQ/+jMUT/3LC3//36+v/gusD/2661/9yxuP/HgYz/oi9F/7tVPf/8tCz//7gr//+4K3v/uCsAgln/AIJZ/4qCWf//gln//4JZ//+CWf//lESa/6QwQf+jMUT/ozFE/6IuQf+5YnD//Pj5//Lj5f/q0dX/7dfa///+/v/br7f/ozBD/6MxRP/csbj/9+zu/69MXf+iL0L/ozBE/6MxRP+hL0T/wl88//63K///uCv//7grev+4KwCCWf8Agln/ZIJZ//+CWf//gln//4Ja//+RR6v/ozFC/6MxRP+jMUT/oi9C/7NUY//jwMb/58nO/+fKz//nyc7/58rP/8uLlv+jMUT/ozFE/92zuv/47/H/sE1e/6IvQv+jMUT/ozFE/6IvRP/Pcjj//7kr//+4K///uCto/7grAIJZ/wCCWf80gln/7oJZ//+CWf//glr//4pP0f+hM03/ozFD/6MxRP+jMUT/pDJF/6U3Sf+mN0n/pjdJ/6Y3Sf+mN0n/pTVH/6MxRP+jMUT/wneE/9GYof+qQFL/ozBD/6MxRP+jMUT/pTRD/+OPM///uiv//7gr8P+4Kzj/uCsAgln/AIJZ/wuCWf+7gln//4JZ//+CWf//g1f3/5k9ff+kMEH/ozFE/6MxRP+jMUT/ozFE/6MxRP+jMUT/ozFE/6MxRP+jMUT/ozFE/6MxRP+iMEP/oi9C/6MxRP+jMUT/ozFE/6IwRP+zSED/9qst//+5K///uCus/7grCP+4KwCCWf8Agln/AIJZ/2KCWf/8gln//4JZ//+CWf//iVHY/543Xv+kMEH/ozFE/6MxRP+jMUT/ozFE/6MxRP+jMUT/ozFE/6MxRP+jMUT/ozFE/6MxRP+jMUT/ozFE/6MxRP+jMUT/ojBE/9J1N///uSv//7gr2P+4KzH/uCsA/7grAIJZ/wCCWf8Agln/EoJZ/7+CWf//gln//4JZ//+CWf//ik/R/5w6bP+jMUT/pDBB/6MxQv+jMUL/ozFC/6MxQv+jMUL/ozFC/6MxQv+jMUL/ozFC/6MxQv+jMUL/ozFC/6IvQv+0Sj//9Kcu//+5K8j/uCs8/7grAP+4KwD/uCsAgln+AIJZ/wCCWf8Agln/Q4JZ/+qCWf//gln//4JZ//+CWf//hVXs/5BIr/+ZPX3/nTlo/504Zf+dOGX/nThl/504Zf+dOGX/nThl/504Zf+dOGX/nThl/504Zf+dOGX/njlk99F3Pbj/uypu/7grGv+4KwD/uCsA/7grAAAAAAAAAAAAgln/AIJZ/wCDW/8Agln/aYJZ//WCWf//gln//4JZ//+CWf//glr//4NY+/+EVvP/hVbw/4VW8P+FVvH/hVbx/4VW8f+FVvH/hVbx/4VW8f+FVvH/hVbx/4VW8PyHVeiGxoR8CuukQgD/uCsA/7grAP+4KwAAAAAAAAAAAAAAAAAAAAAAgln/AIJZ/wCCWf8Egln/cYJZ//GCWf//gln//4JZ//+CWf//gln//4JZ//+CWf//gln//4JZ//+CWf//gln//4JZ//+CWf//gln//4JZ//+CWf/5gln/in5c/wuZY8oAAAD/AP+4KwD+uCsAAAAAAAAAAAAAAAAAAAAAAAAAAACCWf8Agln/AIJZ/wCCWf4Cgln/U4JZ/9OCWf//gln//4JZ//+CWf//gln//4JZ//+CWf//gln//4JZ//+CWf//gln//4JZ//+CWf//gln/4IJZ/2mCWf8Hgln/AIJZ/wCDWP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCWP8Agln/AIJZ/wCCWf8Agln/IoJZ/4eCWf/cgln//IJZ//+CWf//gln//4JZ//+CWf//gln//4JZ//+CWf/+gln/5IJZ/5iCWf8ugln/AIJZ/wCCWf8AgFj+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCWP4Agln/AIJZ/gCCWf8Ahl//AIJZ/yiCWf9ygln/t4JZ/+OCWf/6gln//4JZ//yCWf/ogln/v4JZ/36CWf8ygln/A4JZ/wCCWf8Agln/AIJZ/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+AP//8AAAf8AAAB+AAAAPgAAADwAAAA8AAAAOAAAADAAAAAgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAA8AAAAfAAAAf4AAAP/AAAH8=";
    (function loadNewIndex() {
      if (!pageExtensions.get().index)
        return;
      if (currentPageType() !== "index")
        return;
      afterHead(function() {
        const bodyMask = injectCSSList(`
            body {
                display: none;
            }
        `);
        injectCSSList(`
            #com_userbar {
                display: none;
            }

            .tbui_aside_float_bar {
                display: none;
            }
        `);
        waitUtil(() => document.body !== null).then(function() {
          renderPage(indexVue);
          DOMS(".wrap1")[0].remove();
          removeDefault();
          bodyMask.remove();
        });
      });
    })();
    (function setColorTheme() {
      waitUtil(() => document.body !== null, void 0, 4).then(function() {
        setTheme(themeType.get());
      });
    })();
    (function loadBasicStyles() {
      afterHead(() => {
        injectCSSList(palette);
        injectCSSList(materialSymbols);
        injectCSSList(remixedMain);
        injectCSSList(utilClassesCSS);
        document.head.appendChild(templateCreate("link", {
          type: "image/icon",
          rel: "shortcut icon",
          href: favicon
        }));
        document.head.appendChild(templateCreate("meta", {
          httpEquiv: "Content-Security-Policy",
          content: "upgrade-insecure-requests"
        }));
        document.head.appendChild(templateCreate("meta", {
          name: "viewport",
          content: "width=device-width, initial-scale=1.0"
        }));
      });
    })();
    (function writeDynStyle() {
      const theme = themeColor.get();
      const darkRGBA = hexToRGBA(theme.dark);
      const lightRGBA = hexToRGBA(theme.light);
      const darkHSLA = rgbaToHSLA(darkRGBA);
      const lightHSLA = rgbaToHSLA(lightRGBA);
      const dynCSS = parseMultiCSS({
        ":root": {
          "--content-max": wideScreen.get().noLimit ? "100vw" : `${wideScreen.get().maxPX}px`
        },
        ":root .dark-theme": {
          "--tieba-theme-color": theme.dark,
          "--trans-tieba-theme-color": `rgb(${darkRGBA.r} ${darkRGBA.g} ${darkRGBA.b} / 80%)`,
          "--tieba-theme-hover": `hsl(${darkHSLA.h}deg ${parseInt(darkHSLA.s) + 40}% ${parseInt(darkHSLA.l) + 10}%)`,
          "--tieba-theme-active": `hsl(${darkHSLA.h}deg ${parseInt(darkHSLA.s) + 50}% ${parseInt(darkHSLA.l) + 20}%)`,
          "--tieba-theme-background": `rgb(${darkRGBA.r} ${darkRGBA.g} ${darkRGBA.b} / 24%)`,
          "--tieba-theme-fore": `hsl(${darkHSLA.h}deg 100% 75%)`
        },
        ":root .light-theme": {
          "--tieba-theme-color": theme.light,
          "--trans-tieba-theme-color": `rgb(${lightRGBA.r} ${lightRGBA.g} ${lightRGBA.b} / 80%)`,
          "--tieba-theme-hover": `hsl(${lightHSLA.h}deg ${parseInt(lightHSLA.s) - 40}% ${parseInt(lightHSLA.l) - 10}%)`,
          "--tieba-theme-active": `hsl(${lightHSLA.h}deg ${parseInt(lightHSLA.s) - 50}% ${parseInt(lightHSLA.l) - 20}%)`,
          "--tieba-theme-background": `rgb(${lightRGBA.r} ${lightRGBA.g} ${lightRGBA.b} / 24%)`,
          "--tieba-theme-fore": `hsl(${lightHSLA.h}deg 60% 32%)`
        }
      });
      injectCSSList(dynCSS);
      injectCSSList(darkVars);
      injectCSSList(ThemePlus);
    })();
    (function loadUserModules() {
      parseUserModules(
        /* @__PURE__ */ Object.assign({ "./modules/easy-jump/index.ts": () => Promise.resolve().then(() => index$f), "./modules/no-login/index.ts": () => Promise.resolve().then(() => index$d), "./modules/notrans-emojis/index.ts": () => Promise.resolve().then(() => index$b), "./modules/portal/index.ts": () => Promise.resolve().then(() => index$9), "./modules/remixed-theme/index.ts": () => Promise.resolve().then(() => index$7), "./modules/remixed-toolkit/index.ts": () => Promise.resolve().then(() => index$5), "./modules/shield/index.ts": () => Promise.resolve().then(() => index$3), "./modules/tieba-tags/index.ts": () => Promise.resolve().then(() => index$1) }),
        (_, module2) => {
          AllModules().push(module2);
        }
      );
    })();
    (function observing() {
      document.addEventListener("DOMContentLoaded", function() {
        if (currentPageType() === "thread") {
          remixedObservers.postsObserver.observe();
          remixedObservers.commentsObserver.observe();
        }
        if (currentPageType() === "index") {
          remixedObservers.newListObserver.observe();
        }
        if (currentPageType() === "forum") {
          remixedObservers.threadListObserver.observe();
        }
      });
    })();
    window.addEventListener("load", function() {
      checkUpdateAndNotify();
    });
    console.info(REMIXED);
    const index$e = {
      id: "easy-jump",
      name: "直链跳转",
      author: "锯条",
      version: "1.0.2",
      brief: "链接跳转避免二次确认",
      description: `自动跳转至分享链接的原始地址，不再进行中转（不处理被严重警告的链接）`,
      scope: /jump2?.bdimg.com\/safecheck\//,
      runAt: "immediately",
      entry: main$6
    };
    function main$6() {
      afterHead(function() {
        injectCSSRule("html", {
          backgroundColor: "var(--page-background)"
        });
        injectCSSRule("body", {
          display: "none"
        });
      });
      waitUtil(() => DOMS(".link").length > 0).then(function() {
        const link = DOMS(".link")[0].innerText;
        location.href = link;
      });
    }
    const index$f = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: index$e
    }, Symbol.toStringTag, { value: "Module" }));
    const index$c = {
      id: "nologin-tieba",
      name: "免登录浏览",
      author: "锯条",
      version: "1.0",
      brief: "免登录浏览贴吧",
      description: `始终伪装为已登录状态，让免登录浏览和已登录基本一致`,
      scope: ["thread"],
      runAt: "DOMLoaded",
      entry: main$5
    };
    function main$5() {
      if (PageData.user.is_login)
        return;
      PageData.user.is_login = 1;
    }
    const index$d = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: index$c
    }, Symbol.toStringTag, { value: "Module" }));
    const index$a = {
      id: "notrans-emojis",
      name: "别动我的 emoji😠",
      author: "锯条",
      version: "1.0",
      brief: "拒绝替换我的 emoji",
      description: "原版贴吧会将部分emoji表情替换为旧版，该模块会让这些emoji重新跟随系统样式",
      scope: true,
      runAt: "afterHead",
      entry: main$4
    };
    function main$4() {
      const indexRegExp = new RegExp("(?<=nickemoji\\/).*?(?=.png)", "gi");
      const emojis = [
        "º",
        "◎",
        "▫",
        "◆",
        "♤",
        "♀",
        "♂",
        "ლ",
        "♬",
        "☞",
        "☜",
        "✆",
        "☎",
        "♋",
        "Ω",
        "℃",
        "℉",
        "😄",
        "😍",
        "😘",
        "😚",
        "😜",
        "😳",
        "😁",
        "😞",
        "😢",
        "😂",
        "😫",
        "😨",
        "😱",
        "😡",
        "😷",
        "😲",
        "😈",
        "🐷",
        "🐶",
        "🐑",
        "🐵",
        "🐨",
        "🐴",
        "🐼",
        "🐯",
        "🍪",
        "🍺",
        "🍦",
        "🍭",
        "🍗",
        "🍼",
        "🔯",
        "🍒",
        "👀",
        "🐭",
        "😇",
        "😺",
        "😻",
        "🙀",
        "😿",
        "😹",
        "😾",
        "👹",
        "👺",
        "🌞",
        "🌝",
        "🌚",
        "🌜",
        "🌛",
        "👦",
        "👧",
        "🎎",
        "🌸",
        "🍀",
        "🌹",
        "🌻",
        "🌺",
        "🍁",
        "🌿",
        "🍄",
        "🌵",
        "🌴",
        "🌳",
        "🌰",
        "🌱",
        "🌼",
        "🌐",
        "🌙",
        "🌋",
        "🌌",
        "⛅",
        "⚡",
        "☔",
        "⛄",
        "🌀",
        "🌈",
        "🌊",
        "🔥",
        "✨",
        "🌟",
        "💥",
        "💫",
        "💢",
        "💦",
        "💧",
        "💤",
        "💨",
        "🎀",
        "🌂",
        "💄",
        "💕",
        "💖",
        "💞",
        "💘",
        "💌",
        "💋",
        "💝",
        "🎒",
        "🎓",
        "🎏",
        "🎃",
        "👻",
        "🎅",
        "🎄",
        "🎁",
        "🙈",
        "🐒",
        "💯",
        "👯",
        "💍"
      ];
      const transformed = [
        "1-1.png",
        "1-2.png",
        "1-4.png",
        "1-5.png",
        "1-6.png",
        "1-7.png",
        "1-8.png",
        "1-9.png",
        "1-10.png",
        "1-11.png",
        "1-12.png",
        "1-13.png",
        "1-14.png",
        "1-15.png",
        "1-16.png",
        "1-17.png",
        "1-18.png",
        "1-19.png",
        "1-20.png",
        "1-21.png",
        "1-22.png",
        "1-23.png",
        "1-24.png",
        "1-25.png",
        "1-26.png",
        "1-27.png",
        "1-28.png",
        "1-29.png",
        "1-30.png",
        "1-31.png",
        "1-32.png",
        "1-33.png",
        "1-34.png",
        "1-35.png",
        "2-1.png",
        "2-2.png",
        "2-3.png",
        "2-4.png",
        "2-5.png",
        "2-6.png",
        "2-7.png",
        "2-8.png",
        "2-9.png",
        "2-10.png",
        "2-11.png",
        "2-12.png",
        "2-13.png",
        "2-14.png",
        "2-15.png",
        "2-16.png",
        "2-17.png",
        "2-18.png",
        "2-19.png",
        "2-20.png",
        "2-21.png",
        "2-22.png",
        "2-23.png",
        "2-24.png",
        "2-25.png",
        "2-26.png",
        "2-27.png",
        "2-28.png",
        "2-29.png",
        "2-30.png",
        "2-31.png",
        "2-32.png",
        "2-33.png",
        "2-34.png",
        "2-35.png",
        "3-1.png",
        "3-2.png",
        "3-3.png",
        "3-4.png",
        "3-5.png",
        "3-6.png",
        "3-7.png",
        "3-8.png",
        "3-9.png",
        "3-10.png",
        "3-11.png",
        "3-12.png",
        "3-13.png",
        "3-14.png",
        "3-15.png",
        "3-16.png",
        "3-17.png",
        "3-18.png",
        "3-19.png",
        "3-20.png",
        "3-21.png",
        "3-22.png",
        "3-23.png",
        "3-24.png",
        "3-25.png",
        "3-26.png",
        "3-27.png",
        "3-28.png",
        "3-29.png",
        "3-30.png",
        "3-31.png",
        "3-32.png",
        "3-33.png",
        "3-34.png",
        "3-35.png",
        "4-1.png",
        "4-2.png",
        "4-3.png",
        "4-4.png",
        "4-5.png",
        "4-6.png",
        "4-7.png",
        "4-8.png",
        "4-9.png",
        "4-10.png",
        "4-11.png",
        "4-12.png",
        "4-13.png",
        "4-14.png",
        "4-15.png",
        "4-16.png",
        "4-17.png",
        "4-18.png",
        "4-19.png",
        "4-20.png",
        "4-21.png",
        "4-22.png",
        "4-23.png"
      ];
      remixedObservers.commentsObserver.addEvent(() => {
        try {
          forEach(DOMS(`
                .p_author_name:has(.nicknameEmoji),
                .at:has(.nicknameEmoji),
                .lzl_content_main:has(.nicknameEmoji)
            `), (el) => {
            updateEmojis(el);
          });
        } catch (error) {
          forEach(DOMS(".p_author_name, .at, .lzl_content_main"), (el) => {
            if (includes(el.classList, "nicknameEmoji")) {
              updateEmojis(el);
            }
          });
        }
      });
      remixedObservers.newListObserver.addEvent(() => {
        try {
          forEach(DOMS(`
                .new_list .post_author:has(.nicknameEmoji),
                .userinfo_username:has(.nicknameEmoji)
            `), (el) => {
            updateEmojis(el);
          });
        } catch (error) {
          forEach(DOMS(".newlist .post_author, .userinfo_username"), (el) => {
            if (includes(el.classList, "nicknameEmoji")) {
              updateEmojis(el);
            }
          });
        }
      });
      remixedObservers.threadListObserver.addEvent(() => {
        try {
          forEach(DOMS(".threadlist_author a:has(.nicknameEmoji)"), (el) => {
            updateEmojis(el);
          });
        } catch (error) {
          forEach(DOMS(".threadlist_author a"), (el) => {
            if (includes(el.classList, "nicknameEmoji")) {
              updateEmojis(el);
            }
          });
        }
      });
      function updateEmojis(elem) {
        const arrIndex = elem.innerHTML.match(indexRegExp);
        arrIndex == null ? void 0 : arrIndex.forEach((index2) => {
          const emoji = emojis[transformed.indexOf(`${index2}.png`)];
          const arrInner = elem.innerHTML.split(RegExp(
            `<img[^>]*?${index2}.png(?:[^>]*?)*>`,
            "g"
          ));
          elem.innerHTML = arrInner.join(decodeURIComponent(emoji));
        });
      }
    }
    const index$b = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: index$a
    }, Symbol.toStringTag, { value: "Module" }));
    const index$8 = {
      id: "portal",
      name: "传送门",
      author: "锯条",
      version: "1.1",
      brief: "为贴子中的b站番号添加跳转链接",
      description: `该模块可以识别贴子中的 av/BV 号并将其转换为超链接`,
      scope: ["thread"],
      runAt: "immediately",
      entry: main$3
    };
    function main$3() {
      const LINKED_CLASS = "linked";
      const avRegExp = new RegExp("(?<!:\\/\\/www.bilibili.com\\/video\\/)av[1-9]\\d*", "gi");
      const BVRegExp = new RegExp("(?<!:\\/\\/www.bilibili.com\\/video\\/)BV[A-Za-z0-9]{10}", "g");
      document.addEventListener("DOMContentLoaded", () => {
        remixedObservers.commentsObserver.addEvent(biliEnhanced);
      });
      function biliEnhanced() {
        addBiliLinks(".d_post_content");
        addBiliLinks(".lzl_cnt .lzl_content_main");
        function addBiliLinks(selector) {
          forEach(DOMS(selector), (elem) => {
            var _a2, _b, _c, _d;
            if (elem.classList.contains(LINKED_CLASS))
              return;
            elem.classList.add(LINKED_CLASS);
            if (((_a2 = elem.textContent) == null ? void 0 : _a2.toLowerCase().indexOf("av")) !== -1) {
              const avs = (_b = elem.textContent) == null ? void 0 : _b.match(avRegExp);
              bindingLinks(avs, true);
            }
            if (((_c = elem.textContent) == null ? void 0 : _c.indexOf("BV")) !== -1) {
              const BVs = (_d = elem.textContent) == null ? void 0 : _d.match(BVRegExp);
              bindingLinks(BVs);
            }
            function bindingLinks(array, lowerCase = false) {
              if (!array)
                return;
              const hadHyperLink = [];
              forEach(array, (videoID) => {
                if (hadHyperLink.indexOf(videoID) === -1) {
                  hadHyperLink.push(videoID);
                  const htmlArray = elem.innerHTML.split(
                    RegExp(`(?<!://www.bilibili.com/video/)${videoID}`, "g")
                  );
                  if (lowerCase)
                    videoID = videoID.toLowerCase();
                  const linkedID = `<a href='https://www.bilibili.com/video/${videoID}/'>${videoID}</a>`;
                  elem.innerHTML = htmlArray.join(linkedID);
                }
              });
            }
          });
        }
      }
    }
    const index$9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: index$8
    }, Symbol.toStringTag, { value: "Module" }));
    const mainCSS = '@charset "UTF-8";html{padding:0;margin:0;text-align:justify}body{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar]{overflow:hidden}div,p{margin:0}select{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option{cursor:pointer}option:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ{position:fixed!important;top:50%!important;left:50%!important}.dialogJ{transform:translate(-50%,-50%)}.tbui_aside_float_bar li a{font-family:Material Symbols,monospace;font-variation-settings:"FILL" 0,"wght" 400,"GRAD" 0,"opsz" 40;-webkit-user-select:none;-moz-user-select:none;user-select:none}@keyframes animation-fade-in{0%{opacity:0}to{opacity:1}}.fade-in-elem{animation:animation-fade-in ease .3s forwards}.tbui_aside_float_bar{border:none!important;background:none!important}.tbui_aside_float_bar li{width:40px;height:40px;border-radius:24px;margin:8px 0;background-color:var(--light-background)}.tbui_aside_float_bar li:hover{background-color:var(--default-hover)}.tbui_aside_float_bar li:active{background-color:var(--default-active)}.tbui_aside_float_bar li a{width:40px!important;height:40px!important;background:none!important}.tbui_aside_float_bar li a{border-radius:24px}.tbui_aside_float_bar a{width:40px!important;height:40px!important}.tbui_aside_float_bar a{color:var(--minimal-fore);font-size:24px;line-height:40px;text-align:center}.tbui_aside_float_bar .tbui_fbar_auxiliaryCare a{height:40px!important;background:none!important}.tbui_fbar_auxiliaryCare a:after{content:"accessibility_new"}.tbui_fbar_top a:after{content:"arrow_upward"}.tbui_fbar_post a:after{content:"chat";font-size:22px}.tbui_fbar_feedback a:after{content:"report";font-size:26px}.tbui_aside_float_bar li.tbui_fbar_feedback a,.tbui_aside_float_bar .tbui_fbar_feedback a,.tbui_aside_float_bar .tbui_fbar_feedback a:hover{background:none!important}.tbui_aside_float_bar .tbui_fbar_down,.tbui_aside_float_bar .tbui_fbar_props,.tbui_aside_float_bar .tbui_fbar_tsukkomi,.tbui_aside_float_bar .tbui_fbar_share,.tbui_aside_float_bar .tbui_fbar_favor,.tbui_aside_float_bar .tbui_fbar_refresh{display:none}.p_tools a{padding:0 10px;background:none;vertical-align:bottom}.p_tools span{display:none}.p_tools .p_putup:before,.p_tools .tb_icon_ypic:before,.p_tools .tb_icon_turnleft:before,.p_tools .tb_icon_turnright:before{margin-right:4px;font-family:Material Symbols,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;font-size:14px;vertical-align:bottom}.p_tools .p_putup:before{content:"zoom_out"}.p_tools .tb_icon_ypic:before{content:"zoom_out_map"}.p_tools .tb_icon_turnleft:before{content:"turn_left"}.p_tools .tb_icon_turnright:before{content:"turn_right"}';
    const homeCSS = 'body{background-color:var(--page-background);color:var(--default-fore)}.head_inner{background-color:var(--default-background)}.u_menu_item a{color:var(--default-fore)}.head_inner .search_logo{left:72px;width:60px;height:60px;background-image:var(--img-tieba-icon)}.search_top{border:none}.search_nav a:link,.search_nav a:hover,.search_nav a:visited,.u_menu_item a:hover,.u_menu_item a:visited{color:var(--default-fore)}.search_main{padding-bottom:96px}.search_bright .search_inp_border{border-color:var(--border-color);border-bottom-left-radius:8px;border-top-left-radius:8px;color:var(--default-fore)}.search_bright .search_inp_border:focus{border-color:var(--tieba-theme-color)}.search_bright .search_btn{border-color:var(--trans-tieba-theme-color);border-radius:8px;background-color:var(--tieba-theme-background);color:var(--tieba-theme-fore)}.search_bright .search_btn_enter_ba{background-color:var(--tieba-theme-color);border-bottom-left-radius:0;border-top-left-radius:0;color:var(--default-background)}.search_bright .search_btn:visited{color:var(--tieba-theme-fore)}.search_bright .search_btn_enter_ba:visited{background-color:var(--tieba-theme-color);color:var(--default-background)}.search_bright .search_btn:hover{border-color:var(--trans-tieba-theme-color);background-color:var(--tieba-theme-background);box-shadow:0 0 0 2px var(--trans-tieba-theme-color)}.search_bright .search_btn_enter_ba:hover{background-color:var(--tieba-theme-color);color:var(--default-background)}.suggestion{border-color:var(--border-color);border-radius:0 0 16px 16px;background-color:var(--elem-color);box-shadow:0 10px 20px #0000004d;color:var(--default-fore)}.suggestion .break_tip{background-color:var(--default-background)}.suggestion .highlight{color:var(--tieba-theme-color)}.suggestion .operation_title{color:var(--default-fore)}.suggestion .forum_image{border-radius:8px}.suggestion .forum_name{color:var(--highlight-fore)}.suggestion .on{background-color:var(--light-background)}.page-container .top-sec{display:none}.page-container .content-sec{background:none}.page-container .left-sec{border-radius:24px;border-top:none;background:none;background-color:var(--elem-color)}.f-d-w{border-radius:24px;background-color:var(--elem-color)}.f-d-w .f-d-item{background:none}.aggregate_entrance_wrap{display:none}.u-f-t .gap{border:none;background:none}.f-d-w .all{background:none}.forum_rcmd{border:0;border-radius:24px;background-color:var(--elem-color)}.region_bright .region_header{color:var(--default-fore)}.page-container .left-sec .region_bright{border-radius:24px}.my_tieba_mod .media_left,.my_tieba_mod .media-left{border:none}.media_left img,.media-left img{border-radius:16px}#nameValue,#j_tcharge_dialog{color:var(--default-fore)}#onekey_sign .onekey_btn,#onekey_sign a.onekey_btn{border-radius:8px;margin-right:-5px;background:none;background-color:var(--tieba-theme-color);color:var(--elem-color);text-align:center}#onekey_sign .onekey_btn:after{content:"一键签到"}#onekey_sign a.signed_btn .icon_signed{margin-top:2px;background:var(--svg-checkmark);background-repeat:no-repeat;background-size:20px;filter:drop-shadow(var(--elem-color) 0 9999px);transform:translateY(-9999px)}#onekey_sign .onekey_btn:hover{box-shadow:0 0 10px var(--tieba-theme-color)}.u-f-w{padding-bottom:20px}.left-cont-fixed{position:relative;bottom:0}.u-f-w .sign,.u-f-w .unsign,.always-forum-item .sign,.always-forum-item .unsign{border-radius:8px;background:none;background-color:var(--light-background);color:var(--default-fore)}.u-f-w .sign,.always-forum-item .sign{background-color:var(--tieba-theme-background);color:var(--tieba-theme-fore)}.u-f-w .sign,.u-f-w .unsign{margin-bottom:8px}.u-f-w .sign:hover,.u-f-w .unsign:hover,.always-forum-item .sign:hover,.always-forum-item .unsign:hover{background:none;background-color:var(--tieba-theme-color);box-shadow:0 0 10px var(--tieba-theme-color);color:var(--elem-color);-webkit-text-decoration:none;text-decoration:none}.u-f-w .more{border:none;border-radius:8px;background:none;background-color:var(--elem-color);box-shadow:none;color:var(--default-fore)}.more-txt{color:var(--default-fore)}.u-f-w .more-hover{width:188px;margin:auto;background-color:var(--tieba-theme-color);box-shadow:0 0 10px var(--tieba-theme-color);color:var(--elem-color)}.u-f-w .more-hover .more-txt,.u-f-w .more:hover .more-txt{margin-left:60px;color:var(--elem-color)}.always-forum-title{border:none;margin-top:10px}#alwayforum-wraper{background-color:var(--elem-color)}.pop-up-frame{border:none;background-color:var(--elem-color);border-radius:24px 24px 24px 0;box-shadow:none}.always-forum-close{display:none}.always-forum-item .addnewforumbtn{width:110px;padding-left:0;border-radius:8px;background:none;background-color:var(--tieba-theme-background);color:var(--tieba-theme-fore);font-size:20px;text-align:center}.always-forum-item .addnewforumbtn:after{content:"+"}.always-forum-item .addnewforumbtn:hover{background-color:var(--tieba-theme-color);box-shadow:0 0 10px var(--tieba-theme-color);color:var(--elem-color)}.tbui_scroll_panel .tbui_scroll_button{width:6px;border:none;border-radius:24px;background-color:var(--very-light-background)}.tbui_scroll_panel .tbui_scroll_bar{width:6px;background:none}.forum_rcmd .class_title>div{color:var(--default-fore)}.rcmd_forum_item .forum_name{color:var(--default-fore)}.rcmd_forum_item .rcmd_forum_logo{border:none;border-radius:16px;background:none}.page-container .r-left-sec,.sub_nav_wrap,.title-tag-wraper,.thread-name-wraper,.n_reply{width:780px}.n_txt{width:720px;color:var(--light-fore)}.sub_nav_wrap{background:none;background-color:var(--default-background);box-shadow:none}.sub_nav_list a.cur{border:none;color:var(--tieba-theme-color)}.sub_nav_list .nav_hover{width:56px!important}.sub_nav_list .nav_hover{border-bottom:3px solid var(--tieba-theme-color)}.sub_nav_list li.sub_nav_line{background:none}.page-container .r-right-sec{display:none}.item_hd{border:none;border-radius:24px;background-color:var(--default-background);color:var(--default-fore)}.item_hd .title{color:var(--default-fore)}.topic_list .topic_item .topic_flag_hot{border-radius:4px}.item .item_hd{border:none;background-color:var(--default-background);color:var(--default-fore)}.item .item_hd .title{color:var(--default-fore)}.notice-wrap-fixed{background-color:var(--default-color);border-bottom-left-radius:24px;border-bottom-right-radius:24px}.notice,.notice img{border-radius:24px}.new_list .title{color:var(--tieba-theme-color)}.new_list .title:hover{color:var(--tieba-theme-color);-webkit-text-decoration:underline;text-decoration:underline}.title-tag-wraper a{padding:4px 10px;border-radius:24px;background-color:var(--light-background);color:var(--light-fore);font-size:12px}.title-tag-wraper a:hover{color:var(--light-fore);-webkit-text-decoration:none;text-decoration:none}.list-post-num{top:0;padding:4px 10px;border:none;border-radius:16px;background-color:var(--tieba-theme-background);color:var(--tieba-theme-fore)}.list-triangle-border,.list-triangle-body{display:none}.new_list .post_author{padding:0;margin-bottom:24px;background:none;color:var(--default-fore);-webkit-text-decoration:none;text-decoration:none}.new_list .time{padding:0;background:none}.topic-tag{display:none}.n_img img{border:none;border-radius:16px;cursor:pointer}.n_img li{border-radius:16px}.n_img li .feed_highlight{background:none;cursor:pointer}.media_box{border:none;border-radius:16px;background-color:var(--light-background)}.media_box img{border-radius:16px;cursor:pointer}.ui_btn{border:none;border-radius:24px;background:none;background-color:var(--tieba-theme-color);color:var(--default-background)}.ui_btn:hover{-webkit-text-decoration:none!important;text-decoration:none!important}.ui_btn:hover{background:none;background-color:var(--tieba-theme-color);box-shadow:0 0 10px var(--tieba-theme-color);color:var(--default-background)}.btn_more{width:200px;height:auto;height:initial;border-radius:24px;background:none;background-color:var(--tieba-theme-background)}.btn_more:hover,.data_error_bar a:hover,.btn_more a:hover{background:none!important;background-color:var(--tieba-theme-color)!important;color:var(--default-background)!important}.data_error_bar a,.btn_more a{border:none;color:var(--tieba-theme-fore)}.bottom-bg{background:none}.footer{border-top:1px solid var(--light-background);background-color:var(--light-background)}.f-d-w,.left-cont-wraper .ufw-gap,#data_loading img{display:none}';
    const postsCSS = '.d_name a:hover,#container .content a.at:hover{-webkit-text-decoration:none;text-decoration:none}.l_reply_num{color:inherit!important}#j_navtab_game,.nav_list .more-config-navtab,#j_navtab_wanle{display:none}.nav_wrap_add_border{border:none}#head{background:none;background-color:transparent}#container .content{border-radius:24px;background:transparent none repeat 0 0 / auto auto padding-box border-box scroll;background:initial}.card_top_wrap{background:none!important;background-color:var(--elem-color)!important}.card_top_wrap{border-radius:24px 24px 0 0}.card_top_theme2{border:none;margin-right:0}#novel-ranking .novel-ranking-frs-body,.novel-award-aside{display:none}.card_head,.plat_head_theme2 .plat_picbox{top:-32px!important;width:64px!important;height:64px!important;padding:0!important;padding:initial!important;border:4px solid var(--border-color)!important;border-radius:24px!important;background:none!important}.card_head,.plat_head_theme2 .plat_picbox{overflow:hidden}.card_head_img,.plat_head_theme2 .plat_picbox img{width:64px!important;height:64px!important}.card_title,.plat_title_h3{margin:5px 20px 0}.card_top_theme2 .card_title_fname,.plat_title_h3,.plat_title_h3:hover,.plat_title_h3:visited{color:var(--highlight-fore)}.islike_focus{margin-top:4px!important}.islike_focus{border-radius:24px;background:none;background-color:var(--tieba-theme-color);color:var(--elem-color);font-size:14px;line-height:28px;text-align:center}.islike_focus:after{content:"关注"}.cancel_focus{width:72px;border:2px solid var(--trans-tieba-theme-color);border-radius:24px;background:none;background-color:var(--tieba-theme-background);color:var(--tieba-theme-fore);font-size:14px;line-height:28px;text-align:center}.cancel_focus:after{content:"已关注"}.card_top_right{margin-top:20px}.sign_box_bright{width:140px!important;height:40px!important}.sign_box_bright{border:2px solid var(--trans-tieba-theme-color);border-radius:24px;background:none;background-color:var(--tieba-theme-color);color:var(--default-background);font-size:18px;line-height:40px;text-align:center}.sign_btn_bright:before{color:var(--elem-color);content:"签到"}.sign_box_bright_signed{background-color:var(--tieba-theme-background);text-align:inherit}.sign_today_date,.sign_month_lack_days{display:none}.sign_keep_span{width:140px!important}.sign_keep_span{height:40px}.sign_keep_span,.sign_mod_bright .sign_keep_span{margin:0;margin:initial;color:var(--tieba-theme-fore);font-size:12px;text-align:center}.sign_box_bright_signed:before{content:none!important}.sign_mod_bright .sign_keep_span:before{content:"已签到 | "}.jump_input_bright{padding:0 10px;border-color:var(--border-color);border-radius:16px}.left_section{background:none}.core_title_wrap_bright{border-color:var(--border-color);-webkit-backdrop-filter:blur(24px);backdrop-filter:blur(24px);background-color:var(--trans-default-background)}.core_title_theme_bright,.core_title_absolute_bright .core_title_theme_bright{border-color:var(--border-color);background:none}.left_section .core_title_absolute_bright{-webkit-backdrop-filter:blur(24px);backdrop-filter:blur(24px);background-color:var(--trans-default-background)}.core_title_txt{margin-left:24px;background:none}.tittle_fill_dom.filled{background-color:var(--default-background)}.core_title h1{margin-left:0;color:var(--highlight-fore)}.nav_wrap{background-image:none!important}.nav_wrap{border-color:var(--border-color);background-color:var(--light-background)}.nav_list a.nav_icon,.nav_list .tbnav_arrow{padding-left:22px;background:transparent none repeat 0 0 / auto auto padding-box border-box scroll;background:initial}.nav_wrap,.nav_list .space,.nav_list .focus,.nav_list li:hover,.nav_list li:hover .tbnav_tab_inner,.nav_list .focus .tbnav_tab_inner{background:transparent none repeat 0 0 / auto auto padding-box border-box scroll;background:initial}.nav_list a{color:var(--default-fore)}span.tP{color:var(--highlight-fore)!important}.thread_theme_5{width:auto;width:initial;border-color:var(--border-color);border-right:none;border-left:none;background-color:var(--light-background)}.btn_sub,.btn-sub,.btn-sub-b,.core_title_btns li a,.p_favthr_main{border:none;border-radius:8px;background:none;background-color:var(--tieba-theme-background);color:var(--tieba-theme-fore)}.btn_sub:hover,.btn-sub:hover,.btn-sub-b:hover,.btn_sub:active,.btn-sub:active,.btn-sub-b:active,.btn_sub:focus,.btn-sub:focus,.btn-sub-b:focus{background-color:var(--tieba-theme-color);color:var(--default-background)}.l_lzonly:hover,.p_favthr_main:hover{background-color:var(--tieba-theme-color)!important;color:var(--default-background)!important}#quick_reply{display:none}.d_lzonly_bdaside,.p_favthr_main p,.j_quick_reply,.j_lzl_p a{color:inherit}.j_quick_reply{padding-left:0;padding-left:initial}.l_post_bright{width:auto;width:initial;border-color:var(--border-color);background:none}.p_author_face{background:none!important}.p_author_face{border:none}.icon_relative img{border-radius:16px}.d_name .p_author_name{color:var(--tieba-theme-fore)}.novel-level-icon{display:none}.d_badge_bright,.user_level .badge{border:1px solid var(--border-color);border-radius:24px;background-color:var(--light-background)}.user_level .badge_name{color:inherit}.d_badge_bright .d_badge_title{padding-left:4px;color:var(--default-fore)}.d_badge_bright .d_badge_lv,.user_level .badge_index{background-image:none!important}.d_badge_bright .d_badge_lv,.user_level .badge_index{background-color:var(--tieba-theme-background);color:var(--tieba-theme-fore)}.d_badge_lv,.user_level .badge_index{top:auto!important;top:initial!important;left:60px!important;width:auto!important;width:initial!important;height:8px!important;padding:0 4px!important;margin:12px 4px!important;font-family:inherit!important;line-height:2px!important}.d_badge_lv,.user_level .badge_index{border-radius:16px;font-size:14px;font-style:italic}.d_badge_icon1 .d_badge_lv,.tieba-lvl-green{background-color:var(--level-green-background)!important;color:var(--level-green-fore)!important}.d_badge_icon2 .d_badge_lv,.d_badge_icon2_1 .d_badge_lv,.d_badge_icon2_2 .d_badge_lv,.tieba-lvl-blue{background-color:var(--level-blue-background)!important;color:var(--level-blue-fore)!important}.d_badge_icon3 .d_badge_lv,.d_badge_icon3_1 .d_badge_lv,.d_badge_icon3_2 .d_badge_lv,.tieba-lvl-yellow{background-color:var(--level-yellow-background)!important;color:var(--level-yellow-fore)!important}.d_badge_icon4 .d_badge_lv,.d_badge_icon4_1 .d_badge_lv,.d_badge_icon4_2 .d_badge_lv,.tieba-lvl-orange{background-color:var(--level-orange-background)!important;color:var(--level-orange-fore)!important}.d_badge_bawu1 .d_badge_lv,.d_badge_bawu2 .d_badge_lv{text-indent:inherit!important}.d_author .d_pb_icons,.icon_book_link_icon{display:none}.region_bright{border:none;margin-top:12px;background:none;background-color:var(--elem-color)}.region_bright .region_title{color:var(--default-fore)!important}#celebrity{display:none}.balv_mod .media_left,.balv_mod .media-left{border:none}.right_section .tieba_notice{background:none}.topic_list_box{display:none;background-color:var(--default-background)}.pb_content{border:none;background:none;background-color:var(--elem-color)}.notice-icon,.right_section .tieba_notice{padding-left:0!important;padding-left:initial!important;background:none!important}.tieba_notice li{background:none}.p_content{border:none;background-color:var(--default-background)}.forbid-speech-banner{border-top:none}.BDE_Image{border-radius:24px}.BDE_Image:first-child{margin-top:8px}.share_btn_wrapper,.post-tail-wrap .icon-jubao{display:none}.post-tail-wrap .icon-jubao:after{content:"举报"}.post-tail-wrap .tail-info{color:var(--minimal-fore)}.j_jb_ele .tail-info,.complaint{color:var(--tieba-theme-fore)!important}.complaint{padding-right:4px;background:none}.complaint:after{content:"举报"}.post-tail-wrap .question-image:hover:before{border-color:var(--border-color);border-radius:8px;background-color:var(--light-background);color:var(--default-fore)}.post_bubble_top,.post_bubble_bottom{display:none}.post_bubble_middle{background:none!important}.post_bubble_middle{width:auto;width:initial;padding:0;padding:initial}.save_face_bg_2{display:none}.replace_div .replace_tip{border-color:var(--border-color);background-color:var(--elem-color)}.achievement_medal_section{display:none}.l_post_bright .d_post_content_main .d_sign_split{border-bottom:1px solid var(--border-color)}.d_post_content_main{background-color:var(--default-background)!important}.lzl_p_p{border:none}.lzl_p_p img{border-radius:8px}.core_reply_wrapper{border:1px solid var(--border-color)!important;border-radius:16px!important;margin-bottom:16px!important;background:none!important;background-color:var(--very-light-background)!important;color:var(--default-fore)!important}.core_reply_content li{border-top:0;border-top:initial}.core_reply_content li.first_no_border{margin-top:6px}.lzl_content_main{color:var(--default-fore)}.l_post_bright .core_reply_wrapper .core_reply_border_top,.core_reply_border_bottom,.l_post_bright .core_reply_wrapper .core_reply_content{border:none;background:none}.lzl_link_fold{display:none!important;border:1px solid var(--border-color)!important;border-bottom:none!important;background-color:var(--very-light-background)!important}.lzl_link_fold{border-radius:8px 8px 0 0;color:var(--tieba-theme-fore)}.core_reply div.hideLzl{background:none;background-color:var(--very-light-background)}.core_reply_wrapper .loading_reply{display:none}.lzl_cnt .lzl_s_r{color:var(--tieba-theme-fore)}.lzl_li_pager_s .lzl_more,.lzl_more span{color:var(--light-fore)}.j_lzl_m{color:var(--tieba-theme-fore)}.lzl_cnt .lzl_time{color:var(--minimal-fore)}.lzl_jb_in,.user-jubao-button{background:none;color:var(--tieba-theme-fore)}.lzl_jb_in:after,.user-jubao-button:after{content:"举报"}.lzl_cnt .lzl_content_main{display:block}.d_post_content a,.lzl_cnt .lzl_content_main a:not(.at){margin:auto 2px;color:var(--tieba-theme-fore);transition:.4s}.pager_theme_5 a,.pager_theme_5 span,.jump_btn_bright{border-color:var(--default-background);border-radius:8px;background:none;background-color:var(--default-background);color:var(--minimal-fore)}.pager_theme_5 a:hover,.jump_btn_bright:hover{border-color:var(--tieba-theme-color);background-color:var(--tieba-theme-color);color:var(--default-background)}.thread_theme_7{width:auto;width:initial;border-color:var(--border-color);background-color:var(--light-background)}#pb-footer-header{background-color:var(--default-background)}#tb_rich_poster_container{width:auto;width:initial;border-radius:24px;background-color:var(--default-background)}.poster_head_text a.cur{color:var(--highlight-fore)!important}.edui-editor-body{border-color:var(--border-color)!important}.edui-editor-body{border-radius:16px;background:none}.edui-container .edui-editor-body.body-container-focus,.edui-container .edui-editor-body.body-container-focus .edui-body-container{border-color:var(--tieba-theme-color)!important}.old_style_wrapper{border-color:var(--border-color);border-radius:24px;background-color:var(--elem-color)}.edui-editor-body .edui-body-container{width:auto!important;width:initial!important}.edui-editor-body .edui-body-container{border-radius:16px;background:var(--default-background)}.edui-toolbar .edui-btn-toolbar,.edui-container .edui-toolbar{margin-top:4px;background-color:var(--elem-color)}.pb_footer{width:auto;width:initial;border:none;border-color:var(--border-color);background:none}.save-to-quick-reply-btn{border-color:var(--border-color);background:none;background-color:var(--light-background);color:inherit}.save-to-quick-reply-btn span{color:var(--tieba-theme-fore)}.footer{display:none}.skin_normal .wrap2{background:none;background-color:var(--page-background)}#lcsas-container{display:none}.user-hide-post-down,.user-hide-post-up{background-color:var(--light-fore);background-position:center;background-repeat:no-repeat;background-size:16px;-webkit-mask:var(--svg-arrow-down-circle);mask:var(--svg-arrow-down-circle);opacity:0}#selectsearch-icon{display:none}.ui_card_wrap{background:none}.ui_card_content{border-color:var(--border-color);border-radius:16px;background:none;box-shadow:0 0 20px #0003}.card_userinfo_wrap{background:none;background-color:var(--default-background)}.card_userinfo_left .userinfo_head{background:none}.j_avatar img{width:92px;height:92px;border:4px solid var(--border-color);border-radius:24px;-webkit-backdrop-filter:blur(24px);backdrop-filter:blur(24px)}.card_userinfo_middle .userinfo_sex{background:none}.userinfo_sex_male:after{content:"♂"}.userinfo_sex_female:after{content:"♀"}.ui_card_wrap .ui_white_down,.ui_card_wrap .ui_white_up,.card_userinfo_guide{display:none}.user_card_loading{background-color:var(--default-background)}.user_card_loading img{display:none}.plat_head_theme2,.plat_header{border:none;background-color:transparent;background-color:initial}';
    const barCSS = '.threadlist_title a,.threadlist_title a:hover,.threadlist_title a:visited{color:var(--tieba-theme-fore)!important}.u_menu_item a{color:inherit!important}.card_banner,.plat_recom_carousel{display:none!important}.search_main{padding-bottom:0;padding-bottom:initial}.search_bright{margin-bottom:36px}.search_bright .search_logo_fixed{width:36px;height:36px;margin-left:56px;background-color:#0000;background-image:var(--img-tieba-icon);background-repeat:no-repeat}.search_main_fixed{border-color:var(--border-color);-webkit-backdrop-filter:blur(24px);backdrop-filter:blur(24px);background-color:var(--trans-default-background);box-shadow:0 0 20px #0000001a}.card_top_theme{border:none!important}#content{width:982px}.card_top_theme .card_top{padding-left:120px!important}.card_title_fname{color:var(--tieba-theme-fore)!important}.card_title_fname{font-weight:700}.card_slogan{color:var(--light-fore)!important}.islike_focus{background-color:var(--tieba-theme-color)!important;background-image:none!important}.cancel_focus{background:none!important;background-color:var(--tieba-theme-background)!important}.sign_box_bright,.sign_box_bright_hover{background:none!important;background-color:var(--tieba-theme-color)!important}.sign_box_bright_signed,.sign_box_bright_noclass_hover{background:none!important;background-color:var(--tieba-theme-background)!important}.sign_mod_bright .sign_keep_span{margin:0!important;margin:initial!important;text-align:center!important}.forum_content{border-color:var(--border-color)!important;border-right:none!important;background:none!important;background-color:var(--elem-color)!important}.nav_wrap{border-color:var(--border-color)!important}.nav_list li.focus{background:none!important}.nav_list a{color:inherit!important}.j_tabnav_tab:hover{background:none}.nav_list a:hover,.nav_list a:focus{background-color:var(--elem-color)!important}.search_internal_input{height:24px!important;border-color:var(--border-color)!important;color:var(--default-fore)!important}.search_internal_input{border-radius:8px 0 0 8px}.search_internal_btn{height:26px!important;background-color:var(--tieba-theme-color)!important;background-image:none!important;vertical-align:middle!important}.search_internal_btn{border-radius:0 8px 8px 0}.search_internal_btn:after{color:var(--default-background);content:"search";font-family:Material Symbols;font-size:18px;font-weight:700;line-height:26px;text-align:center}.aside_region{border-bottom:none!important}.aside_region .region_header{color:var(--default-fore)!important}.my_tieba .media_left,.my_tieba .media-left{border:none!important}.my_current_forum .badge{border:1px solid var(--border-color)!important;background-color:var(--light-background)!important;color:var(--default-fore)!important}.my_current_forum .badge_name{color:var(--default-fore)!important}.media_top img,.media-top img{border-radius:16px}.aside_media_horizontal a,.aside-media-horizontal a{color:var(--tieba-theme-fore)!important}.threadlist_bright li.thread_top_list_folder,.threadlist_bright li.thread_top_list_folder:hover{background-color:var(--very-light-background)!important}.threadlist_bright>li{border:none!important;background-color:var(--default-background)!important}.threadlist_bright>li:hover{background-color:var(--trans-light-background)!important}.j_th_tit{color:var(--tieba-theme-fore);font-weight:700}.threadlist_bright .threadlist_abs_onlyline,.threadlist_bright .threadlist_abs{color:var(--default-fore)!important}.vpic_wrap img:not([style]){opacity:0}.threadlist_bright .threadlist_media li{border-radius:8px!important}.threadlist_media li:hover .threadlist_pic_highlight{display:none!important}.threadlist_media li:hover .threadlist_pic_highlight,.vpic_wrap img{border-radius:8px}.threadlist_bright .media_disp{border:none!important;background:none!important}.threadlist_bright .threadlist_video{border-radius:8px}.threadlist_rep_num{height:auto!important;height:initial!important;background:none!important;background-color:var(--tieba-theme-background)!important}.threadlist_rep_num{border-radius:24px;color:var(--tieba-theme-fore);font-weight:700}.pagination-default .pagination-item{border:none!important;background-color:var(--light-background)!important;color:var(--light-fore)!important}.pagination-default .pagination-item{border-radius:8px}.pagination-default .pagination-current{border:none!important;background-color:var(--tieba-theme-color)!important;color:var(--default-background)!important}.pagination-default .pagination-item:not(.pagination-current):hover{border:none!important;background-color:var(--trans-light-background)!important}#tb_rich_poster_container{width:982px!important;background-color:var(--very-light-background)!important}#tb_rich_poster_container{border-radius:0 0 24px 24px;margin-left:-1px}.tb_rich_poster .poster_body .editor_textfield{border-color:var(--border-color)!important;background-color:var(--default-background)!important;color:var(--default-fore)!important}.tb_rich_poster .poster_body .editor_textfield{border-radius:8px}.tb_rich_poster .poster_body .editor_textfield:focus{border-color:var(--tieba-theme-color)!important}.old_style_wrapper{border-color:var(--border-color)!important;background-color:var(--elem-color)!important}.old_style_wrapper .edui-editor-body,.edui-container .edui-toolbar{background:none!important}.edui-editor-body .edui-body-container{border-color:var(--border-color)!important;background-color:var(--default-background)!important}.frs_content_footer_pagelet{background:none!important}.footer{display:none!important}.icon_author{background-image:none!important}.icon_author:after{content:"person";font-family:Material Symbols;font-style:normal}.icon_replyer{background-image:none!important}.icon_replyer:after{content:"comment";font-family:Material Symbols;font-style:normal}';
    const errorCSS = ".search-form{background-color:var(--default-background)}.search-form p{display:none}.page404{background-color:var(--default-background)}.main-title{color:var(--default-fore)}.main-title a{color:var(--tieba-theme-fore)}.app_download_box,#error_404_iframe{display:none}";
    const userButtonCSS = "html{padding:0;margin:0;text-align:justify}body{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar]{overflow:hidden}div,p{margin:0}select{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option{cursor:pointer}option:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ{position:fixed!important;top:50%!important;left:50%!important}.dialogJ{transform:translate(-50%,-50%)}@keyframes kf-fade-in{0%{opacity:0}to{opacity:1}}@keyframes kf-fade-out{0%{opacity:1}to{opacity:0}}@keyframes kf-dialog-in{0%{opacity:0;transform:scale(1.2)}to{opacity:1;transform:scale(1)}}@keyframes kf-zoom-in{0%{transform:scale(.72)}to{transform:scale(1)}}@keyframes kf-fade-zoom-in{0%{opacity:0;transform:scale(.72)}to{opacity:1;transform:scale(1)}}";
    const floatBarCSS = 'html{padding:0;margin:0;text-align:justify}body{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar]{overflow:hidden}div,p{margin:0}select{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option{cursor:pointer}option:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ{position:fixed!important;top:50%!important;left:50%!important}.dialogJ{transform:translate(-50%,-50%)}.tbui_aside_float_bar{background-color:var(--very-light-background)!important}.tbui_aside_float_bar{bottom:20px;left:calc(50% + var(--content-max) / 2 + 20px);display:flex;overflow:hidden;width:-moz-max-content;width:max-content;flex-direction:column;border-radius:8px;margin-left:0;gap:4px;box-shadow:0 0 10px #00000003}body.dark-theme .tbui_aside_float_bar{box-shadow:0 0 16px #0003}@media (max-width: var(--content-max)){.tbui_aside_float_bar{bottom:0;left:calc(100% - 40px)}}.tbui_aside_float_bar .tbui_aside_fbar_button{margin:0!important}.tbui_aside_float_bar .tbui_aside_fbar_button{border-radius:0;background-color:var(--default-background);transition:.4s}.tbui_aside_float_bar .tbui_aside_fbar_button a{border-radius:0}.tbui_aside_float_bar .tbui_aside_fbar_button[style*="visibility: hidden"]{margin-top:-4px!important}.tbui_aside_float_bar .tbui_aside_fbar_button[style*="visibility: hidden"]{height:0}';
    const floatMessageCSS = "html{padding:0;margin:0;text-align:justify}body{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar]{overflow:hidden}div,p{margin:0}select{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option{cursor:pointer}option:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ{position:fixed!important;top:50%!important;left:50%!important}.dialogJ{transform:translate(-50%,-50%)}@keyframes kf-fade-in{0%{opacity:0}to{opacity:1}}@keyframes kf-fade-out{0%{opacity:1}to{opacity:0}}@keyframes kf-dialog-in{0%{opacity:0;transform:scale(1.2)}to{opacity:1;transform:scale(1)}}@keyframes kf-zoom-in{0%{transform:scale(.72)}to{transform:scale(1)}}@keyframes kf-fade-zoom-in{0%{opacity:0;transform:scale(.72)}to{opacity:1;transform:scale(1)}}.float-message{position:fixed;z-index:99999;display:none;overflow:hidden;box-sizing:border-box;padding:4px 6px;border:1px solid var(--border-color);border-radius:6px;background-color:var(--default-background);font-size:14px;transition:.3s;box-shadow:0 0 10px #00000003;animation:kf-fade-in .3s}body.dark-theme .float-message{box-shadow:0 0 16px #0003}.float-message .float-content{display:flex;overflow:auto}";
    const _hoisted_1$4 = {
      key: 0,
      class: "menu-separator"
    };
    const _hoisted_2$4 = {
      key: 0,
      class: "icon"
    };
    const _hoisted_3$3 = { class: "menu-title" };
    const _hoisted_4$3 = {
      key: 0,
      class: "menu-inner"
    };
    const _sfc_main$4 = /* @__PURE__ */ defineComponent({
      __name: "dropdown-menu",
      props: {
        menuItems: {},
        blurEffect: { type: Boolean }
      },
      emits: ["RequestClose"],
      setup(__props, { emit: __emit }) {
        const props = __props;
        const emit2 = __emit;
        onMounted(() => {
          setTimeout(() => {
            window.addEventListener("click", () => {
              setTimeout(() => {
                emit2("RequestClose");
              }, 100);
            });
            window.addEventListener("focusin", (ev) => {
              if (!findParentByClass(ev.target, "dropdown-menu")) {
                emit2("RequestClose");
              }
            });
          }, 100);
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["dropdown-menu", _ctx.blurEffect ? "blur-effect" : ""])
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(props.menuItems, (menuItem) => {
              return openBlock(), createElementBlock(Fragment, null, [
                typeof menuItem === "string" ? (openBlock(), createElementBlock("div", _hoisted_1$4)) : (openBlock(), createBlock(_sfc_main$Q, {
                  key: 1,
                  class: "menu-item",
                  "is-anchor": menuItem.href !== void 0,
                  href: menuItem.href ? menuItem.href : "javascript:;",
                  onClick: menuItem.click,
                  target: menuItem.href ? "_blank" : "",
                  "no-border": ""
                }, {
                  default: withCtx(() => [
                    menuItem.icon ? (openBlock(), createElementBlock("div", _hoisted_2$4, toDisplayString(menuItem.icon), 1)) : createCommentVNode("", true),
                    createBaseVNode("div", _hoisted_3$3, [
                      createTextVNode(toDisplayString(menuItem.title) + " ", 1),
                      menuItem.innerText ? (openBlock(), createElementBlock("span", _hoisted_4$3, toDisplayString(menuItem.innerText), 1)) : createCommentVNode("", true)
                    ])
                  ]),
                  _: 2
                }, 1032, ["is-anchor", "href", "onClick", "target"]))
              ], 64);
            }), 256))
          ], 2);
        };
      }
    });
    const DropdownMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$4, [["__scopeId", "data-v-00bee924"]]);
    const _withScopeId$2 = (n) => (pushScopeId("data-v-18e85ac3"), n = n(), popScopeId(), n);
    const _hoisted_1$3 = {
      id: "nav-bar",
      class: "nav-bar"
    };
    const _hoisted_2$3 = { class: "left-container" };
    const _hoisted_3$2 = ["src"];
    const _hoisted_4$2 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("p", { class: "nav-title" }, "贴吧", -1));
    const _hoisted_5$2 = { class: "right-container" };
    const _hoisted_6$1 = { class: "middle-container" };
    const _sfc_main$3 = /* @__PURE__ */ defineComponent({
      __name: "nav-bar",
      setup(__props) {
        const navAvatar = ref();
        const userPortrait = ref("");
        const middleMenu = ref({});
        const userMenu = ref([]);
        const extendMenu = ref([]);
        init();
        onMounted(async function() {
          {
            waitUtil(() => userPortrait.value !== "").then(function() {
              if (navAvatar.value !== void 0)
                navAvatar.value.src = tiebaAPI.URL_profile(userPortrait.value);
            });
          }
        });
        async function init() {
          await waitUtil(() => PageData !== void 0).then(() => {
            userPortrait.value = PageData.user.portrait;
            loadNavMenuContent();
          });
        }
        async function login() {
          const loginButton = DOMS(".u_login");
          const directLoginButton = DOMS("#TANGRAM__PSP_24__submit");
          if (directLoginButton.length > 0) {
            const confirmDirect = await messageBox({
              title: "快速登录",
              message: "检测到快速登录入口，是否尝试直接登录？",
              type: "OkCancel"
            });
            if (confirmDirect === "positive") {
              directLoginButton[0].click();
            } else {
              regularLogin();
            }
          } else {
            regularLogin();
          }
          function regularLogin() {
            loginButton.length > 0 ? DOMS("a", loginButton[0])[0].click() : cannotLogin();
          }
          function cannotLogin() {
            toast({ message: "未检测到可用的登录入口，请刷新重试", type: "warning" });
          }
        }
        function loadNavMenuContent() {
          middleMenu.value = {
            "消息": [
              {
                title: "查看私信",
                href: "/im/pcmsg"
              },
              {
                title: "查看回复",
                href: `/i/sys/jump?u=${userPortrait.value}&type=replyme`
              },
              {
                title: "查看 @",
                href: `/i/sys/jump?u=${userPortrait.value}&type=atme`
              },
              "separator",
              {
                title: "查看好友申请",
                href: `/i/sys/jump?u=${userPortrait.value}&type=friendapply`
              },
              {
                title: "查看新粉丝",
                href: `/i/sys/jump?u=${userPortrait.value}&type=fans`
              },
              "separator",
              {
                title: "我的收藏",
                href: `/i/sys/jump?u=${userPortrait.value}&type=storethread`
              },
              {
                title: "我的通知",
                href: "/sysmsg/index?type=notity"
              }
            ],
            "更多": [
              {
                title: "账号设置",
                href: "//passport.baidu.com/?center&tpl=tb&aid=6&default_tab=3#3,0"
              },
              {
                title: "贴吧设置",
                href: `/home/profile?un=${PageData.user.name_url}`
              },
              "separator",
              {
                title: "服务中心",
                href: "//tieba.baidu.com/pmc"
              },
              {
                title: "问题反馈",
                href: "//tieba.baidu.com/hermes/feedback"
              }
            ]
          };
          userMenu.value = [
            {
              title: "我的贴吧",
              href: `/home/main?id=${userPortrait.value}&fr=userbar`
            },
            {
              title: "我的收藏",
              href: `/i/sys/jump?un=${PageData.user.user_name}${PageData.user.name_url}&type=storethread&st_mod=userbar&fr=tb0_pb`
            }
          ];
          PageData.user.is_login ? userMenu.value.push("separator", {
            title: "退出登录",
            click() {
              DOMS("a", "a", DOMS(".u_logout")[0])[0].click();
            }
          }) : userMenu.value.push("separator", {
            title: "登录",
            click() {
              login();
            }
          });
          extendMenu.value = [
            {
              title: "脚本设置",
              click() {
                renderDialog(Settings);
              }
            },
            {
              title: "检查更新",
              click() {
                checkUpdateAndNotify(true);
              }
            },
            "separator",
            {
              title: "源代码仓库",
              innerText: "GitHub",
              href: GithubRepo
            },
            {
              title: "源代码仓库",
              innerText: "Gitee",
              href: GiteeRepo
            },
            {
              title: "切换至 GreasyFork",
              href: "https://greasyfork.org/zh-CN/scripts/460113"
            }
          ];
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$3, [
            createBaseVNode("div", _hoisted_2$3, [
              createVNode(_sfc_main$Q, {
                class: "nav-button nav-title-container",
                "is-anchor": "",
                href: "/",
                "no-border": ""
              }, {
                default: withCtx(() => [
                  createBaseVNode("img", {
                    src: unref(getResource)("/assets/images/main/icon64.png"),
                    alt: "",
                    class: "nav-icon"
                  }, null, 8, _hoisted_3$2),
                  _hoisted_4$2
                ]),
                _: 1
              })
            ]),
            createBaseVNode("div", _hoisted_5$2, [
              createBaseVNode("div", _hoisted_6$1, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(middleMenu.value, (menu, key) => {
                  return openBlock(), createBlock(_sfc_main$Q, {
                    class: "menu-container middle-menu-container",
                    "no-border": ""
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(key) + " ", 1),
                      createVNode(DropdownMenu, { "menu-items": menu }, null, 8, ["menu-items"])
                    ]),
                    _: 2
                  }, 1024);
                }), 256))
              ]),
              createVNode(_sfc_main$Q, {
                class: "nav-button menu-container avatar-button",
                "shadow-border": ""
              }, {
                default: withCtx(() => [
                  createBaseVNode("img", {
                    ref_key: "navAvatar",
                    ref: navAvatar,
                    class: "nav-avatar"
                  }, null, 512),
                  createVNode(DropdownMenu, {
                    "menu-items": userMenu.value
                  }, null, 8, ["menu-items"])
                ]),
                _: 1
              }),
              createVNode(_sfc_main$Q, {
                class: "nav-button menu-container nav-menu icon",
                "shadow-border": "",
                "no-border": ""
              }, {
                default: withCtx(() => [
                  createTextVNode(" menu "),
                  createVNode(DropdownMenu, {
                    "menu-items": extendMenu.value,
                    style: { "font-family": "initial" }
                  }, null, 8, ["menu-items"])
                ]),
                _: 1
              })
            ])
          ]);
        };
      }
    });
    const navBarVue = /* @__PURE__ */ _export_sfc$1(_sfc_main$3, [["__scopeId", "data-v-18e85ac3"]]);
    const navBarCSS = "#com_userbar{display:none}";
    function _navBar() {
      injectCSSList(navBarCSS);
      waitUtil(() => DOMS("#com_userbar").length > 0).then(function() {
        const elder = DOMS("#com_userbar")[0];
        const navWrapper = createVNode("div", {
          "id": "nav-wrapper",
          "class": "nav-wrapper"
        }, null);
        insertJSX(navWrapper, document.body, elder);
        renderComponent(navBarVue, DOMS("#nav-wrapper")[0]);
      });
    }
    const _hoisted_1$2 = { id: "thread-editor" };
    const _hoisted_2$2 = { id: "thread-editor-toolbar" };
    const _sfc_main$2 = /* @__PURE__ */ defineComponent({
      __name: "thread-editor",
      props: {
        ueditor: {},
        type: { default: "thread" }
      },
      setup(__props) {
        const props = __props;
        const editorSlot = ref();
        const originParent = ref();
        onMounted(async function() {
          var _a2;
          if (!editorSlot.value)
            return;
          originParent.value = props.ueditor.parentElement;
          editorSlot.value.appendChild(props.ueditor);
          await waitUtil(() => DOMS(".edui-editor-body").length > 0);
          const toolbar = DOMS(".edui-toolbar")[0];
          const editorBody = DOMS(".edui-editor-body")[0];
          if (toolbar.compareDocumentPosition(editorBody) & Node.DOCUMENT_POSITION_FOLLOWING) {
            (_a2 = toolbar.parentNode) == null ? void 0 : _a2.insertBefore(editorBody, toolbar);
          }
          DOMS("#ueditor_replace")[0].focus();
        });
        onUnmounted(async function() {
          unload();
        });
        function submit() {
          DOMS(".j_submit", "a")[0].click();
          unload();
        }
        function unload() {
          if (!originParent.value)
            return;
          if (!editorSlot.value)
            return;
          originParent.value.appendChild(DOMS(".edui-container")[0]);
          unloadDialog();
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$2, [
            createVNode(_sfc_main$Q, {
              id: "thread-editor-exit",
              class: "icon",
              "shadow-border": "",
              onClick: unload
            }, {
              default: withCtx(() => [
                createTextVNode("close ")
              ]),
              _: 1
            }),
            _ctx.type === "thread" ? (openBlock(), createBlock(_sfc_main$7, {
              key: 0,
              class: "title-editor",
              placeholder: "输入标题",
              "lodash-style": ""
            })) : createCommentVNode("", true),
            createBaseVNode("div", {
              ref_key: "editorSlot",
              ref: editorSlot,
              id: "thread-editor-slot"
            }, null, 512),
            createBaseVNode("div", _hoisted_2$2, [
              createVNode(_sfc_main$Q, {
                id: "thread-editor-submit",
                "shadow-border": "",
                "theme-style": "",
                onClick: submit
              }, {
                default: withCtx(() => [
                  createTextVNode("发表")
                ]),
                _: 1
              })
            ])
          ]);
        };
      }
    });
    const ThreadEditor = /* @__PURE__ */ _export_sfc$1(_sfc_main$2, [["__scopeId", "data-v-9c94de19"]]);
    const _withScopeId$1 = (n) => (pushScopeId("data-v-521b9a21"), n = n(), popScopeId(), n);
    const _hoisted_1$1 = {
      id: "toggle-panel",
      class: "toggle-panel"
    };
    const _hoisted_2$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "panel-info" }, [
      /* @__PURE__ */ createBaseVNode("div", { class: "panel-title" }),
      /* @__PURE__ */ createBaseVNode("div", { class: "panel-desc" })
    ], -1));
    const _hoisted_3$1 = { class: "toggle-wrapper" };
    const _hoisted_4$1 = { class: "toggle-container" };
    const _hoisted_5$1 = { class: "toggle-name" };
    const _sfc_main$1 = /* @__PURE__ */ defineComponent({
      __name: "toggle-panel",
      props: {
        toggles: {}
      },
      setup(__props) {
        const props = __props;
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1$1, [
            _hoisted_2$1,
            createBaseVNode("div", _hoisted_3$1, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(props.toggles, (toggle) => {
                return openBlock(), createElementBlock("div", _hoisted_4$1, [
                  createVNode(ToggleButton, {
                    class: "panel-button",
                    "default-value": toggle.defaultValue,
                    "icon-type": "",
                    "shadow-border": "",
                    onClick: toggle.event
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(toggle.icon), 1)
                    ]),
                    _: 2
                  }, 1032, ["default-value", "onClick"]),
                  createBaseVNode("div", _hoisted_5$1, toDisplayString(toggle.name), 1)
                ]);
              }), 256))
            ])
          ]);
        };
      }
    });
    const togglePanelVue = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["__scopeId", "data-v-521b9a21"]]);
    class TiebaComponent {
      constructor(selector, type, parent) {
        __publicField(this, "selector");
        __publicField(this, "type");
        __publicField(this, "parent");
        this.selector = selector;
        this.type = type;
        this.parent = parent;
      }
      get() {
        if (!this.parent)
          return DOMS(this.selector, this.type)[0];
        else
          return DOMS(this.selector, this.type, this.parent)[0];
      }
    }
    const floatButtonMap = {
      "auxiliary": "tbui_fbar_auxiliaryCare",
      "down": "tbui_fbar_down",
      "post": "tbui_fbar_post",
      "props": "tbui_fbar_props",
      "tsukkomi": "tbui_fbar_tsukkomi",
      "share": "tbui_fbar_share",
      "favor": "tbui_fbar_favor",
      "feedback": "tbui_fbar_feedback",
      "top": "tbui_fbar_top",
      "other": "*"
    };
    class FloatBar extends TiebaComponent {
      /**
       * 获取当前页面的 float buttons
       * @returns FloatBarButton[]
       */
      buttons() {
        if (!this.get())
          return [];
        return Array.from(DOMS(".tbui_aside_fbar_button", "li", floatBar.get())).map((el) => ({
          el,
          type: function() {
            for (let i = 0; i < el.classList.length; i++) {
              const cls = el.classList[i];
              if (!cls.includes("tbui_fbar_"))
                continue;
              const key = findKey(floatButtonMap, (value) => value === cls);
              if (key) {
                return key;
              }
            }
            return "other";
          }()
        }));
      }
      add(type, event, className, icon, index2 = 0) {
        const anchor = templateCreate("a", {
          href: "javascript:;"
        });
        const el = templateCreate("li", {
          class: "tbui_aside_fbar_button"
        }, [anchor]);
        el.addEventListener("click", event);
        if (type !== "other") {
          el.classList.add(floatButtonMap[type]);
        }
        if (className)
          el.classList.add(className);
        floatBar.get().insertBefore(el, floatBar.get().children[index2]);
        setFloatButtonIcon(anchor, icon);
        return {
          el,
          type
        };
        function setFloatButtonIcon(el2, icon2) {
          el2.classList.add("icon");
          el2.classList.add("tbui_aside_fbar_button");
          el2.innerHTML = icon2 ? icon2 : "";
        }
      }
      remove(param) {
        switch (typeof param) {
          case "string": {
            const el = DOMS(param, "li", floatBar.get())[0];
            el.remove();
            break;
          }
          case "number": {
            const el = floatBar.get().children[param];
            el.remove();
            break;
          }
        }
      }
    }
    const floatBar = new FloatBar(".tbui_aside_float_bar", "ul");
    function threadParser(param) {
      let dom;
      if (typeof param === "string")
        dom = new DOMParser().parseFromString(transEmojiFromDOMString(param), "text/html");
      else
        dom = param;
      const postWrappers = DOMS(".l_post", "div", dom.body);
      const contents = DOMS(".d_post_content", "div", dom.body);
      const dAuthors = DOMS(".d_author", "div", dom.body);
      const avatars = DOMS(".p_author_face", "a", dom.body);
      const nameAnchors = DOMS(".p_author_name", "a", dom.body);
      const levels = DOMS(".d_badge_lv", "div", dom.body);
      const badgeTitles = DOMS(".d_badge_title", "div", dom.body);
      const replyButtons = DOMS(".lzl_link_unfold", "a", dom.body);
      const locations = map(DOMS(".post-tail-wrap span:first-child, .ip-location", "span", dom.body), (el) => el.innerText);
      const platforms = map(DOMS(".tail-info a, .p_tail_wap", "a", dom.body), (el) => el.innerText);
      const floors = map(DOMS(".j_jb_ele + .tail-info + .tail-info, .p_tail li:first-child span", "span", dom.body), (el) => el.innerText);
      const times = map(DOMS(".post-tail-wrap span:nth-last-child(2), .p_tail li:last-child span", "span", dom.body), (el) => el.innerText);
      const threadContents = [];
      for (let i = 0; i < contents.length; i++) {
        contents[i].classList.add("floor-content");
        avatars[i].classList.add("floor-avatar");
        nameAnchors[i].classList.add("floor-name");
        threadContents.push({
          post: contents[i],
          replyButton: replyButtons[i],
          dataField: defaults$1(postWrappers[i].getAttribute("data-field"), ""),
          isLouzhu: DOMS(".louzhubiaoshi_wrap", dAuthors[i]).length > 0,
          profile: {
            avatar: avatars[i],
            nameAnchor: nameAnchors[i],
            level: parseInt(levels[i].innerText),
            badgeTitle: badgeTitles[i].innerText
          },
          tail: {
            location: locations[i],
            platform: platforms[i],
            floor: floors[i],
            time: times[i]
          }
        });
      }
      const thread2 = {
        displayWrapper: DOMS(".wrap2", "div", dom.body)[0],
        title: PageData.thread.title,
        reply: parseInt(DOMS(".l_reply_num span:nth-child(1)", "span", dom.body)[0].innerText),
        pages: PageData.pager.total_page,
        lzOnlyButton: DOMS("#lzonly_cntn", "a", dom.body)[0],
        favorButton: DOMS(".j_favor", "a", dom.body)[0],
        cotents: threadContents,
        forum: {
          info: {
            name: PageData.forum.forum_name
            // followersDisplay: DOMS(".card_menNum", "span", dom.body)[0].innerText,
            // postsDisplay: DOMS(".card_infoNum", "span", dom.body)[0].innerText,
          },
          components: {
            nameAnchor: DOMS(".card_title_fname", "a", dom.body)[0],
            iconContainer: DOMS(".card_head a, .plat_picbox", "a", dom.body)[0],
            followButton: DOMS(".card_head .focus_btn", "a", dom.body)[0],
            signButton: DOMS(".j_sign_box", "a", dom.body)[0]
          }
        },
        pager: {
          listPager: DOMS(".pb_list_pager", "li", dom.body)[0],
          jumper: {
            textbox: DOMS(".jump_input_bright", "input", dom.body)[0],
            submitButton: DOMS(".jump_btn_bright", "button", dom.body)[0]
          }
        }
      };
      return thread2;
    }
    const compactCSS = "body[compact-layout] #j_p_postlist{gap:0}body[compact-layout] .core_reply_content li.first_no_border{margin-top:-4px}";
    const threadCSS = 'html{padding:0;margin:0;text-align:justify}body{padding:0;margin:0;font-family:var(--code-zh)}body[no-scrollbar]{overflow:hidden}div,p{margin:0}select{padding:1px 8px;border:1px solid var(--border-color);border-radius:8px;cursor:pointer}option{cursor:pointer}option:checked{background-color:var(--tieba-theme-color);color:var(--default-background)}a{color:inherit;-webkit-text-decoration:none;text-decoration:none}.dialogJ{position:fixed!important;top:50%!important;left:50%!important}.dialogJ{transform:translate(-50%,-50%)}.lzl_cnt .at,.lzl_cnt .lzl_content_main a,.content-wrapper .author-container .floor-name{color:var(--tieba-theme-fore);transition:.4s}.d_post_content a,.lzl_cnt .lzl_content_main a:not(.at){color:var(--tieba-theme-fore);text-decoration:underline;-webkit-text-decoration:underline solid currentColor;text-decoration:underline solid currentColor;text-decoration-thickness:1.2px;-webkit-text-decoration:underline 1.2px;text-decoration:underline 1.2px;transition:.4s}.lzl_cnt .at:hover,.lzl_cnt .lzl_content_main a:hover,.content-wrapper .author-container .floor-name:hover,.d_post_content a:hover{background-color:var(--default-hover)}.d_post_content a:hover,.lzl_cnt .lzl_content_main a:hover:not(.at){text-decoration:underline;-webkit-text-decoration:underline solid rgba(0,0,0,0);text-decoration:underline solid rgba(0,0,0,0);text-decoration-thickness:1.2px;-webkit-text-decoration:underline 1.2px rgba(0,0,0,0);text-decoration:underline 1.2px rgba(0,0,0,0)}.lzl_cnt .at:active,.lzl_cnt .lzl_content_main a:active,.content-wrapper .author-container .floor-name:active,.d_post_content a:active{background-color:var(--default-active)}.lzl_p_p img,.content-wrapper .author-container .floor-avatar img{-o-object-fit:contain;object-fit:contain}@keyframes kf-fade-in{0%{opacity:0}to{opacity:1}}@keyframes kf-fade-out{0%{opacity:1}to{opacity:0}}@keyframes kf-dialog-in{0%{opacity:0;transform:scale(1.2)}to{opacity:1;transform:scale(1)}}@keyframes kf-zoom-in{0%{transform:scale(.72)}to{transform:scale(1)}}@keyframes kf-fade-zoom-in{0%{opacity:0;transform:scale(.72)}to{opacity:1;transform:scale(1)}}body{background-color:var(--page-background);overflow-x:hidden}body.special_conf_skin{background:var(--page-background)}.wrap1,.wrap1 .wrap2{background:none!important;background-color:transparent!important}.head_inner{display:none}#container{width:100%;max-width:100%;max-width:var(--content-max);box-sizing:border-box;margin-top:120px}#container .content{width:100%}#container .content .pb_content{position:relative;width:100%;border-top:6px solid var(--tieba-theme-color);background-color:var(--default-background);box-shadow:0 12px 80px -32px #0006}#container .content .pb_content:before{position:absolute;top:-30px;right:0;left:0;width:100%;height:24px;background:linear-gradient(to top,var(--tieba-theme-color),transparent);content:"";opacity:.2}#container .tittle_fill_dom,.card_top_wrap,.nav_wrap,.p_thread{display:none}.core_title_wrap_bright{display:none!important}.lzl_cnt .at{padding:2px 0;color:var(--default-fore);font-size:14px;font-weight:700}.lzl_cnt .lzl_content_main img{vertical-align:text-bottom}#j_p_postlist{display:flex;box-sizing:border-box;flex-direction:column;padding:24px;gap:16px}#j_p_postlist .save_face_bg{display:none}#j_p_postlist .l_post_bright{border:none}#j_p_postlist .l_post_bright .d_post_content_main{background-color:transparent!important;background-color:initial!important}#j_p_postlist .l_post_bright .d_post_content_main{width:100%;padding:0}#j_p_postlist .l_post_bright .d_post_content_main .p_content{min-height:0;min-height:initial;padding:0;margin-bottom:-42px;background-color:transparent;background-color:initial}#j_p_postlist .l_post_bright .d_post_content_main .p_content .shield-tip{background:none}#j_p_postlist .l_post_bright .d_post_content_main .p_content .d_post_content{background-color:transparent!important;background-color:initial!important}#j_p_postlist .l_post_bright .d_post_content_main .p_content .d_post_content{padding:0;font-size:16px;grid-area:content}#j_p_postlist .l_post_bright .d_post_content_main .p_content .replace_div{width:auto!important}#j_p_postlist .l_post_bright .d_post_content_main .p_content .BDE_Smiley{width:24px;height:24px;vertical-align:text-bottom}#j_p_postlist .l_post_bright .d_post_content_main .p_content .BDE_Image{display:flex;width:auto;max-height:540px;border-radius:12px;margin:6px auto}#j_p_postlist .l_post_bright .d_post_content_main .core_reply{margin-right:0;margin-right:initial}#j_p_postlist .l_post_bright .d_post_content_main .core_reply .core_reply_tail{margin-top:0}#j_p_postlist .l_post_bright .d_post_content_main .core_reply .core_reply_wrapper{border:none!important;background-color:transparent!important;background-color:initial!important}#j_p_postlist .l_post_bright .d_post_content_main .core_reply .core_reply_wrapper{width:100%}#j_p_postlist .l_post_bright .d_post_content_main .core_reply .core_reply_wrapper .core_reply_content{padding:0 0 0 36px}#j_p_postlist .l_post_bright .d_post_content_main .core_reply .core_reply_wrapper .core_reply_content .lzl_single_post{animation:kf-fade-in .4s}#j_p_postlist .l_post_bright .d_post_content_main .core_reply .core_reply_wrapper .core_reply_content .lzl_single_post:not(.first_no_border){padding-top:0;margin-top:0}#j_p_postlist .l_post_bright .d_post_content_main .core_reply .core_reply_wrapper .core_reply_content .edui-container{width:auto!important}#j_p_postlist .l_post_bright .d_post_content_main .core_reply .core_reply_wrapper .core_reply_content .edui-container{max-height:64px}#j_p_postlist .l_post_bright .d_post_content_main .core_reply .core_reply_wrapper .core_reply_content .edui-container .edui-editor-body{height:-moz-max-content!important;height:max-content!important}#j_p_postlist .l_post_bright .d_post_content_main .core_reply .core_reply_wrapper .core_reply_content .edui-container .edui-editor-body{overflow:hidden;max-height:72px;padding:6px;border-radius:6px}#j_p_postlist .l_post_bright .d_post_content_main .core_reply .core_reply_wrapper .core_reply_content .edui-container .edui-editor-body .edui-body-container{min-height:16px!important}#j_p_postlist .l_post_bright .d_post_content_main .core_reply .core_reply_wrapper .core_reply_content .edui-container .edui-editor-body .edui-body-container{max-height:64px;padding-left:0;border-radius:6px;font-size:14px;overflow-y:auto}#j_p_postlist .l_post_bright .d_post_content_main .core_reply .core_reply_wrapper .core_reply_content .lzl_panel_wrapper{width:100%}#j_p_postlist .l_post_bright .d_post_content_main .core_reply .core_reply_wrapper .core_reply_content .lzl_panel_wrapper .lzl_panel_submit{background:none}.main-wrapper{display:flex;max-width:80%;flex-direction:column;padding:8px;margin:48px auto auto}@media (min-width: 1200px){.main-wrapper{max-width:60%}}.left_section{width:100%}.right_section{display:none}.title-wrapper{display:flex;box-sizing:border-box;align-items:flex-end;justify-content:space-between;margin:36px 0;gap:8px}@media (max-width: var(--content-max)){.title-wrapper{padding:0 24px}}.title-wrapper .thread-title{max-width:40%;font-size:32px;line-height:36px;text-align:left;-webkit-text-decoration:underline 3px var(--tieba-theme-color);text-decoration:underline 3px var(--tieba-theme-color)}.title-wrapper .forum-container{display:flex;overflow:hidden;width:-moz-max-content;width:max-content;height:-moz-max-content;height:max-content;align-items:center;border-radius:8px;background-color:var(--trans-light-background);gap:8px}body.custom-background .title-wrapper .forum-container{-webkit-backdrop-filter:blur(24px);backdrop-filter:blur(24px)}body.dark-theme body.custom-background .title-wrapper .forum-container{-webkit-backdrop-filter:blur(24px) brightness(.8);backdrop-filter:blur(24px) brightness(.8)}.title-wrapper .forum-container:last-child{padding-right:8px}.title-wrapper .forum-container .forum-icon{width:36px;height:36px}.title-wrapper .forum-container .forum-name{color:var(--highlight-fore);font-size:14px;font-weight:700}.title-wrapper .forum-container .forum-info{display:flex;flex-direction:column;justify-content:center}.title-wrapper .forum-container .forum-info .forum-members{display:flex;gap:8px}.title-wrapper .forum-container .button-container{display:flex;align-items:center}.title-wrapper .forum-container .button-container .forum-button{padding:0 4px;background-color:transparent;color:var(--tieba-theme-color);font-size:16px;font-weight:700}.title-wrapper .forum-container .button-container .forum-button:not(:hover):not(:active):not(:focus){box-shadow:none}.forum-mask-wrapper{position:relative;z-index:-1;display:flex;justify-content:center;-webkit-user-select:none;-moz-user-select:none;user-select:none}@keyframes mask-fade-in{0%{opacity:0}to{opacity:.1}}.forum-mask-wrapper .forum-mask{position:absolute;top:-320px;width:480px;height:480px;border-radius:480px;animation:mask-fade-in 1s ease-in-out;filter:blur(60px);opacity:.1;-webkit-user-select:none;-moz-user-select:none;user-select:none}.content-wrapper{display:flex;width:100%;flex-direction:column;gap:16px}.content-wrapper .author-container{display:grid;margin-bottom:8px;grid-gap:6px;gap:6px;grid-template:"avatar name" auto "avatar tags" auto/36px 1fr}.content-wrapper .author-container .floor-avatar{width:-moz-max-content!important;width:max-content!important;height:-moz-max-content!important;height:max-content!important;padding:0!important}.content-wrapper .author-container .floor-avatar{overflow:hidden;grid-area:avatar}.content-wrapper .author-container .floor-avatar img{width:36px;height:36px;border-radius:8px}.content-wrapper .author-container .floor-name{width:-moz-fit-content;width:fit-content;color:var(--highlight-fore);font-size:14px;font-weight:700;grid-area:name}.content-wrapper .author-container .badge-container{display:flex;margin-top:-4px;gap:4px;grid-area:tags}.content-wrapper .author-container .badge-container .floor-badge{display:flex;width:-moz-fit-content;width:fit-content;padding:0 6px;border-radius:6px;background-color:var(--trans-light-background);color:var(--light-fore);gap:6px}.content-wrapper .author-container .badge-container .floor-badge .badge-level{font-weight:700}.content-wrapper .floor-wrapper{display:grid;grid-template:"avatar name" auto "avatar tags" auto "content content" 1fr "footer footer" auto "comments comments" auto/36px 1fr}.content-wrapper .floor-wrapper .floor-avatar{width:-moz-max-content!important;width:max-content!important;height:-moz-max-content!important;height:max-content!important;padding:0!important}.content-wrapper .floor-wrapper .floor-avatar{overflow:hidden;grid-area:avatar}.content-wrapper .floor-wrapper .floor-avatar img{width:36px;border-radius:8px}.content-wrapper .floor-wrapper .floor-name{width:-moz-fit-content;width:fit-content;margin:0 8px 4px;font-size:14px;grid-area:name}.content-wrapper .floor-wrapper .floor-badge{display:flex;width:-moz-fit-content;width:fit-content;padding:0 6px;border-radius:6px;margin:0 8px 8px;background-color:var(--trans-light-background);color:var(--light-fore);gap:6px;grid-area:tags}.content-wrapper .floor-wrapper .floor-badge .badge-level{font-weight:700}.content-wrapper .floor-wrapper .floor-content{padding:8px 0;font-size:16px;grid-area:content}.content-wrapper .floor-wrapper .floor-content .BDE_Smiley{width:24px;height:24px;vertical-align:sub}.content-wrapper .floor-wrapper .floor-info{display:flex;justify-content:flex-end;color:var(--light-fore);gap:12px;grid-area:footer}.content-wrapper .floor-wrapper .floor-comments{width:100%;grid-area:comments}.content-wrapper .floor-wrapper .floor-comments .core_reply_wrapper{width:100%}#ueditor_replace{overflow:hidden}#thread-jsx-components{position:absolute;display:flex;width:100%;max-width:var(--content-max);box-sizing:border-box;flex-direction:column;padding:8px 24px 16px;background-color:var(--default-background);gap:12px}#thread-jsx-components .dummy-button{width:100%;padding:6px 0 0;border:none;border-radius:0;border-bottom:3px solid var(--border-color);background-color:transparent;box-shadow:none;color:var(--minimal-fore);cursor:text;font-size:16px;text-align:justify}#thread-jsx-components .dummy-button:hover{border-color:var(--light-background)}#thread-jsx-components .dummy-button:focus{border-color:var(--tieba-theme-color)}.pb_footer,.svelte-zmnt4x{display:none}.wrap2{padding-bottom:0!important}.head_ad_pop{display:none!important}.plat_head,.star_nav_wrap{display:none}';
    async function thread() {
      if (currentPageType() !== "thread")
        return;
      injectCSSList(threadCSS);
      injectCSSList(compactCSS);
      await waitUtil(() => document.body !== void 0).then(function() {
        if (compactLayout.get()) {
          document.body.toggleAttribute("compact-layout");
        }
      });
      waitUtil(() => floatBar.get() !== void 0).then(function() {
        floatBar.add("other", function() {
          renderDialog(togglePanelVue, {
            toggles: [{
              icon: "favorite",
              name: "收藏",
              defaultValue: function() {
                return DOMS(".j_favor, #j_favthread .p_favthr_main")[0].innerText === "收藏" ? false : true;
              }(),
              event() {
                DOMS(".j_favor, #j_favthread .p_favthr_main")[0].click();
              }
            }, {
              icon: "face_6",
              name: "只看楼主",
              defaultValue: function() {
                return DOMS("#lzonly_cntn")[0].innerText === "只看楼主" ? false : true;
              }(),
              event() {
                DOMS("#lzonly_cntn")[0].click();
              }
            }, {
              icon: "compare_arrows",
              name: "紧凑布局",
              defaultValue: (() => compactLayout.get())(),
              event() {
                document.body.toggleAttribute("compact-layout");
                compactLayout.set(!compactLayout.get());
              }
            }]
          });
        }, "module-settings", "menu");
        document.body.insertBefore(templateCreate("div", {
          class: "vue-module-control",
          style: "display: none;"
        }), document.body.firstChild);
      });
      const content = DOMS(".content", "div")[0];
      DOMS("#pb_content", "div")[0];
      const postList = DOMS("#j_p_postlist")[0];
      createContents();
      async function createContents() {
        var _a2;
        const threadList = (await waitUtil(() => DOMS("#j_p_postlist").length > 0).then(() => DOMS("#j_p_postlist")))[0];
        threadList.classList.add("content-wrapper");
        let thread2 = threadParser(document);
        const forumIconLink = thread2.forum.components.iconContainer.children[0].src;
        insertJSX(createVNode("div", {
          "id": "title-wrapper",
          "class": "title-wrapper"
        }, [createVNode("h3", {
          "class": "thread-title"
        }, [thread2.title]), createVNode("div", {
          "class": "forum-container"
        }, [createVNode("img", {
          "class": "forum-icon",
          "src": forumIconLink,
          "alt": ""
        }, null), createVNode("a", {
          "class": "forum-name",
          "href": `/f?kw=${PageData.forum.name_url}`,
          "target": "_blank"
        }, [PageData.forum.forum_name, createTextVNode(" 吧")]), createVNode("div", {
          "class": "button-container"
        }, [createVNode(_sfc_main$Q, {
          "class": "icon forum-button add-forum-button",
          "shadow-border": true
        }, {
          default: () => [PageData.user.is_like ? "check" : "add"]
        })])])]), DOMS(".content")[0], DOMS("#pb_content")[0]);
        bindFloatMessage(DOMS(".forum-container")[0], `关注 ${PageData.forum.member_count}，帖子 ${PageData.forum.post_num}`);
        DOMS(".add-forum-button", "button")[0].addEventListener("click", function() {
          DOMS("#j_head_focus_btn", "button")[0].click();
        });
        (_a2 = DOMS(".sign-in-button", "button")[0]) == null ? void 0 : _a2.addEventListener("click", function() {
          DOMS(".j_signbtn", "button")[0].click();
        });
        remixedObservers.postsObserver.addEvent(function() {
          if (DOMS(".d_author").length === 0)
            return;
          thread2 = threadParser(document);
          forEach(DOMS(".d_post_content_main", "div", threadList), (floor, i) => {
            const authorContainer = createAuthorContainer(i);
            floor.insertBefore(authorContainer, floor.firstChild);
          });
          forEach(DOMS(".d_author"), (el) => el.remove());
        });
        function createAuthorContainer(index2) {
          const authorContainer = templateCreate("div", {
            class: "author-container"
          });
          thread2.cotents[index2].profile.nameAnchor.classList.add("anchor");
          authorContainer.appendChild(thread2.cotents[index2].profile.avatar);
          authorContainer.appendChild(thread2.cotents[index2].profile.nameAnchor);
          const badgeContainer = appendJSX(createVNode("div", {
            "class": "badge-container"
          }, null), authorContainer);
          appendJSX(createVNode("div", {
            "class": `floor-badge level-${levelToClass(thread2.cotents[index2].profile.level)}`
          }, [createVNode("div", {
            "class": "badge-level"
          }, [thread2.cotents[index2].profile.level]), createVNode("div", {
            "class": "badge-title"
          }, [thread2.cotents[index2].profile.badgeTitle])]), badgeContainer.el);
          if (thread2.cotents[index2].isLouzhu)
            appendJSX(createVNode("div", {
              "class": "floor-badge"
            }, [createTextVNode("楼主")]), badgeContainer.el);
          return authorContainer;
        }
        const avatarObserver = new IntersectionObserver(function(entries, observer) {
          forEach(entries, function(entry) {
            if (entry.isIntersecting) {
              const avatar = entry.target.children[0];
              const lazyLink = avatar.getAttribute("data-tb-lazyload");
              if (avatar.src !== lazyLink) {
                if (lazyLink)
                  avatar.src = lazyLink;
                else
                  observer.unobserve(entry.target);
              } else {
                observer.unobserve(entry.target);
              }
            }
          });
        }, {
          root: null,
          rootMargin: "0px",
          threshold: 0.5
        });
        forEach(thread2.cotents, (content2) => {
          avatarObserver.observe(content2.profile.avatar);
        });
        remixedObservers.postsObserver.addEvent(function() {
          forEach(DOMS(".BDE_Image", "img"), function(el) {
            if (!el.classList.contains("image-component")) {
              el.classList.add("image-component");
              el.onclick = function() {
                renderDialog(imagesViewerVue, {
                  content: el.src
                });
              };
            }
          });
        });
        remixedObservers.commentsObserver.addEvent(() => {
          forEach(DOMS(".lzl_cnt"), (el) => {
            forEach(el.childNodes, (node) => {
              if (node)
                node.nodeType === 3 ? node.remove() : void 0;
            });
          });
        });
      }
      const currPage = ref(PageData.pager.cur_page);
      const createPager = () => createVNode(ElPagination, {
        "current-page": currPage.value,
        "onUpdate:current-page": ($event) => currPage.value = $event,
        "background": true,
        "page-size": 1,
        "pager-count": 11,
        "total": PageData.pager.total_page,
        "defaultCurrentPage": PageData.pager.cur_page,
        "layout": "prev, pager, next, jumper, ->",
        "style": "margin-bottom: 6px;"
      }, null);
      watch(currPage, (newValue) => {
        const search = new URLSearchParams(location.search);
        search.set("pn", newValue.toString());
        location.href = `${location.pathname}?${search.toString()}`;
      });
      insertJSX(createPager(), postList, postList.firstChild);
      createTextbox();
      async function createTextbox() {
        await waitUtil(() => floatBar.get() !== void 0);
        await waitUtil(() => DOMS("#ueditor_replace").length > 0);
        if (!some(floatBar.buttons(), {
          type: "post"
        })) {
          floatBar.add("post", showEditor, void 0, void 0, 2);
        }
        const postButton = find$1(floatBar.buttons(), (button) => {
          return button.type === "post";
        });
        postButton == null ? void 0 : postButton.el.addEventListener("click", showEditor);
        appendJSX(createVNode("div", {
          "id": "thread-jsx-components"
        }, [createPager(), createVNode(_sfc_main$Q, {
          "class": "dummy-button",
          "noBorder": true,
          "onClick": showEditor
        }, {
          default: () => [createTextVNode("回复帖子")]
        })]), content);
        function showEditor() {
          const ueditor = function() {
            if (DOMS(".edui-container").length > 0)
              return DOMS(".edui-container")[0];
            return DOMS("#ueditor_replace")[0];
          }();
          renderDialog(ThreadEditor, {
            ueditor,
            type: "reply"
          }, {
            forced: true,
            blurEffect: false,
            darker: true
          });
        }
      }
    }
    _navBar();
    const index$6 = {
      id: "remixed-theme",
      name: "Tieba Remix 主题",
      author: "锯条",
      version: "0.3",
      brief: "更现代的主题样式",
      description: `包含新的样式、昼夜主题及其自动切换等功能`,
      scope: true,
      runAt: "immediately",
      entry: main$2
    };
    const themeSheets = [];
    function main$2() {
      themeSheets.push(injectCSSList(mainCSS));
      themeSheets.push(injectCSSList(postsCSS));
      themeSheets.push(injectCSSList(homeCSS));
      themeSheets.push(injectCSSList(errorCSS));
      themeSheets.push(injectCSSList(userButtonCSS));
      themeSheets.push(injectCSSList(floatBarCSS));
      themeSheets.push(injectCSSList(floatMessageCSS));
      if (pageExtensions.get().thread)
        thread();
      fadeInElems.push(".tbui_aside_float_bar .svg-container");
      fadeInElems.push(".d_badge_bright .d_badge_lv, .user_level .badge_index");
      fadeInElems.forEach((selector) => {
        injectCSSRule(selector, {
          opacity: "0"
        });
      });
      setCustomBackground();
      if (location.href.indexOf("kw=") !== -1) {
        themeSheets.push(injectCSSList(barCSS));
      }
      document.addEventListener("DOMContentLoaded", () => {
        DOMS(".post-tail-wrap .icon-jubao").forEach((elem) => {
          elem.removeAttribute("src");
          elem.after("举报");
        });
        remixedObservers.postsObserver.addEvent(() => {
          DOMS(".d_badge_lv").forEach((elem) => {
            if (elem.textContent === "") {
              let parent = elem;
              while (!parent.classList.contains("l_badge")) {
                if (parent.parentElement)
                  parent = parent.parentElement;
              }
              parent.style.display = "none";
            }
          });
        });
      });
      window.addEventListener("load", () => {
        fadeInLoad(".tbui_aside_float_bar .svg-container");
        remixedObservers.postsObserver.addEvent(() => {
          const lvlClassHead = "tieba-lvl-";
          const lvlGreen = `${lvlClassHead}green`;
          const lvlBlue = `${lvlClassHead}blue`;
          const lvlYellow = `${lvlClassHead}yellow`;
          const lvlOrange = `${lvlClassHead}orange`;
          DOMS(
            ".d_badge_bawu1 .d_badge_lv, .d_badge_bawu2 .d_badge_lv, .badge_index"
          ).forEach((elem) => {
            if (elem.className.indexOf(lvlClassHead) !== -1)
              return;
            const lvl = parseInt(defaults$1(elem.textContent, "0"));
            if (lvl >= 1 && lvl <= 3) {
              elem.classList.add(lvlGreen);
            } else if (lvl >= 4 && lvl <= 9) {
              elem.classList.add(lvlBlue);
            } else if (lvl >= 10 && lvl <= 15) {
              elem.classList.add(lvlYellow);
            } else if (lvl >= 16) {
              elem.classList.add(lvlOrange);
            }
          });
          fadeInLoad(".d_badge_bright .d_badge_lv, .user_level .badge_index");
        });
        themeSheets.forEach((sheet) => {
          document.head.appendChild(sheet);
        });
      });
    }
    const index$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: index$6
    }, Symbol.toStringTag, { value: "Module" }));
    const index$4 = {
      id: "remixed-toolkit",
      name: "实用工具库",
      author: "锯条",
      version: "1.0",
      brief: "优化原版贴吧体验的一组功能",
      description: "这是一个轻量级的工具库，包含了诸如自动展开长图等实用功能。",
      scope: true,
      runAt: "immediately",
      settings: {
        "auto-expand": {
          title: "自动展开长图",
          description: `该功能会自动将帖子中所有的长图片自动展开，无需手动操作`,
          widgets: [{
            type: "toggle",
            init: () => toolkitRef.value["auto-expand"],
            event() {
              toolkitRef.value["auto-expand"] = !toolkitRef.value["auto-expand"];
              toolkitToogles.set(toolkitRef.value);
            }
          }]
        }
      },
      entry: function() {
        for (const key in toolkitFeatures) {
          const k = key;
          if (toolkitRef.value[k])
            toolkitFeatures[k]();
        }
      }
    };
    const toolkitFeatures = {
      /**
       * 自动展开长图
       */
      "auto-expand"() {
        remixedObservers.postsObserver.addEvent(() => {
          forEach(DOMS(".replace_tip"), (el) => {
            el.click();
          });
        });
      }
    };
    const toolkitToogles = new UserKey("toolkitToogles", {
      "auto-expand": true
    });
    const toolkitRef = ref(toolkitToogles.get());
    const index$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: index$4
    }, Symbol.toStringTag, { value: "Module" }));
    const shieldList = new UserKey("shieldList", []);
    const _withScopeId = (n) => (pushScopeId("data-v-bb897aee"), n = n(), popScopeId(), n);
    const _hoisted_1 = { class: "shield-container" };
    const _hoisted_2 = {
      key: 0,
      class: "words-container"
    };
    const _hoisted_3 = { class: "icon" };
    const _hoisted_4 = {
      key: 1,
      class: "empty-list-container"
    };
    const _hoisted_5 = { class: "shield-controls" };
    const _hoisted_6 = { class: "submit-controls" };
    const _hoisted_7 = { class: "regex-check" };
    const _hoisted_8 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("label", { for: "use-regex" }, "正则表达式", -1));
    const _hoisted_9 = { class: "user-scope" };
    const _hoisted_10 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("label", { for: "user-scope" }, "屏蔽用户名", -1));
    const _sfc_main = /* @__PURE__ */ defineComponent({
      __name: "module.shield",
      setup(__props) {
        const shieldListRef = ref(shieldList.get());
        const inputRule = ref("");
        const useRegex = ref(false);
        const scope = ref("posts");
        function inputKeyPress(e) {
          if (e.key === "Enter") {
            e.preventDefault();
            updateShieldList();
          }
        }
        function removeAll() {
          shieldListRef.value.length = 0;
          shieldList.remove();
        }
        function updateShieldList() {
          if (inputRule.value.length <= 0)
            return;
          const sh = {
            rule: inputRule.value,
            type: useRegex.value ? "regex" : "string",
            scope: scope.value,
            switch: true
          };
          shieldListRef.value.push(sh);
          inputRule.value = "";
          shieldList.set(shieldListRef.value);
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", _hoisted_1, [
            shieldListRef.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_2, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(shieldListRef.value, (sh) => {
                return openBlock(), createBlock(_sfc_main$Q, {
                  class: normalizeClass(["shield-elem", { "content-scope": sh.scope === "posts", "user-scope": sh.scope === "users" }])
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_3, toDisplayString(sh.scope === "posts" ? "chat" : "account_circle"), 1),
                    createTextVNode(" " + toDisplayString(sh.rule), 1)
                  ]),
                  _: 2
                }, 1032, ["class"]);
              }), 256)),
              createVNode(_sfc_main$Q, {
                class: "remove-all shield-elem icon",
                onClick: removeAll
              }, {
                default: withCtx(() => [
                  createTextVNode("delete")
                ]),
                _: 1
              })
            ])) : (openBlock(), createElementBlock("div", _hoisted_4, "当前没有记录屏蔽规则")),
            createBaseVNode("div", _hoisted_5, [
              createVNode(_sfc_main$7, {
                modelValue: inputRule.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => inputRule.value = $event),
                "muti-lines": true,
                class: "shield-input",
                placeholder: "输入屏蔽规则",
                onKeypress: inputKeyPress
              }, null, 8, ["modelValue"]),
              createBaseVNode("div", _hoisted_6, [
                createBaseVNode("div", _hoisted_7, [
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => useRegex.value = $event),
                    id: "use-regex",
                    type: "checkbox"
                  }, null, 512), [
                    [vModelCheckbox, useRegex.value]
                  ]),
                  _hoisted_8
                ]),
                createBaseVNode("div", _hoisted_9, [
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => scope.value = $event),
                    id: "user-scope",
                    type: "checkbox"
                  }, null, 512), [
                    [vModelCheckbox, scope.value]
                  ]),
                  _hoisted_10
                ]),
                createVNode(_sfc_main$Q, {
                  class: "submit-button",
                  "shadow-border": true,
                  "theme-style": true,
                  onClick: updateShieldList
                }, {
                  default: withCtx(() => [
                    createTextVNode("确定 ")
                  ]),
                  _: 1
                })
              ])
            ])
          ]);
        };
      }
    });
    const moduleShieldVue = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["__scopeId", "data-v-bb897aee"]]);
    const index$2 = {
      id: "shield",
      name: "贴吧屏蔽",
      author: "锯条",
      version: "1.2",
      brief: "眼不见为净",
      description: `用户自定义屏蔽规则，符合规则的贴子和楼层将不会显示在首页、看贴页面和进吧页面。支持正则匹配`,
      scope: true,
      runAt: "immediately",
      settings: {
        "shield-controls": {
          title: "管理屏蔽规则",
          description: `这些屏蔽规则将会在首页（旧版）、看贴页面生效，会自动隐藏所有符合匹配规则的贴子和楼层。`,
          widgets: [{
            type: "component",
            component: markRaw(moduleShieldVue)
          }]
        }
      },
      entry: main$1
    };
    function matchShield(obj, str) {
      if (obj.ignoreCase === void 0)
        obj.ignoreCase = true;
      if (obj.type === "string") {
        if (obj.ignoreCase) {
          obj.rule = obj.rule.toLowerCase();
          str = str.toLowerCase();
        }
        if (str.indexOf(obj.rule) !== -1) {
          return true;
        }
      }
      if (obj.type === "regex") {
        let regex;
        if (obj.ignoreCase) {
          regex = new RegExp(obj.rule, "i");
        } else {
          regex = new RegExp(obj.rule);
        }
        if (regex.test(str)) {
          return true;
        }
      }
      return false;
    }
    function shieldElementsBySelector(observer, parentSelector, subSelector) {
      observer.addEvent(() => {
        DOMS(parentSelector).forEach((elem) => {
          var _a2;
          let isMatch = false;
          const content = (_a2 = elem.querySelector(subSelector)) == null ? void 0 : _a2.textContent;
          if (content === null || content === void 0)
            return;
          for (const sh of shieldList.get()) {
            if (matchShield(sh, content)) {
              isMatch = true;
              break;
            }
          }
          if (isMatch) {
            elem.style.display = "none";
          }
        });
      });
    }
    function main$1() {
      shieldElementsBySelector(remixedObservers.postsObserver, ".l_post_bright", ".d_post_content");
      shieldElementsBySelector(remixedObservers.newListObserver, ".new_list li", ".n_txt");
      shieldElementsBySelector(remixedObservers.postsObserver, ".l_post_bright", ".d_name a");
      shieldElementsBySelector(remixedObservers.commentsObserver, ".lzl_single_post", ".lzl_cnt .j_user_card");
      shieldElementsBySelector(remixedObservers.threadListObserver, ".j_feed_li", ".post_author");
    }
    const index$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: index$2
    }, Symbol.toStringTag, { value: "Module" }));
    const tagCSS = ':root{--myself-theme-background: rgba(25, 110, 153, .2);--myself-theme-fore: rgb(16, 73, 101);--cengzhu-theme-background: rgba(255, 89, 107, .2);--cengzhu-theme-fore: rgb(178, 62, 90)}@media (prefers-color-scheme: dark){:root{--myself-theme-background: rgba(34, 135, 204, .2);--myself-theme-fore: rgb(40, 160, 242);--cengzhu-theme-background: rgba(204, 71, 103, .2);--cengzhu-theme-fore: rgb(255, 89, 118)}}.tag-elem{display:inline-block}.tag-elem:after{padding:2px 6px;border-radius:4px;margin:0 4px;background-color:var(--trans-light-background);color:var(--light-fore);font-size:12px;font-weight:400}.tieba-tags-me:after{content:"我"}.tieba-tags-lz:after{content:"楼主"}.tieba-tags-cz:after{content:"层主"}';
    const index = {
      id: "tieba-tags",
      name: "楼中楼标签",
      author: "锯条",
      version: "2.0.1",
      brief: "优化楼中楼浏览体验",
      description: `为楼中楼的楼主、层主等用户添加特殊标签`,
      scope: ["thread"],
      runAt: "loaded",
      entry: main
    };
    function main() {
      const TAGGED = "is-tagged";
      const TB_TAG = "tag-elem";
      const MY_TAG = "tieba-tags-me";
      const LZ_TAG = "tieba-tags-lz";
      const CZ_TAG = "tieba-tags-cz";
      const louzhu = PageData.thread.author;
      const myPortrait = PageData.user.portrait;
      const myUserName = PageData.user.user_name;
      let louzhuPortrait = getLouzhuPortrait(document);
      injectCSSList(tagCSS);
      (async () => {
        if (!louzhuPortrait) {
          const response = await fetch(location.href.split("?")[0], {
            mode: "cors",
            credentials: "include"
          });
          if (response.ok) {
            await response.text().then((value) => {
              const fpDOC = new DOMParser().parseFromString(value, "text/html");
              louzhuPortrait = getLouzhuPortrait(fpDOC);
            });
          }
        }
      })().then(() => {
        remixedObservers.commentsObserver.addEvent(createTagsAll);
      });
      function getLouzhuPortrait(doc2) {
        const j_tags = doc2.getElementsByClassName("j_louzhubiaoshi");
        if (j_tags.length > 0) {
          const targetFloor = findParentByClass(j_tags[0], "l_post_bright");
          if (targetFloor) {
            const dataAttr = targetFloor.getAttribute("data-field");
            if (dataAttr !== null) {
              const dataField = JSON.parse(dataAttr);
              return split(dataField.author.portrait, "?")[0];
            }
          }
        }
        return void 0;
      }
      function createTagsAll() {
        forEach(DOMS(".lzl_cnt .at"), (elem) => {
          if (elem.classList.contains(TAGGED))
            return;
          elem.classList.add(TAGGED);
          let isLouzhu = false;
          let isMe = false;
          const username = elem.getAttribute("username");
          if (userClassify(myUserName, myPortrait)) {
            isMe = true;
            addTag(elem, MY_TAG);
          }
          if (!isMe) {
            if (userClassify(louzhu, louzhuPortrait)) {
              isLouzhu = true;
              addTag(elem, LZ_TAG);
            }
          }
          if (!isMe && !isLouzhu) {
            const floor = findParentByClass(elem, "l_post_bright");
            if (floor !== null) {
              const cengzhuCard = floor.getElementsByClassName("p_author_name")[0];
              const cengzhu = cengzhuCard.textContent;
              if (cengzhu) {
                if (elem.textContent === cengzhu) {
                  addTag(elem, CZ_TAG);
                }
              }
            }
          }
          function userClassify(un2, portrait) {
            if (username === un2 && un2 !== "") {
              return true;
            } else if (indexOf(["", " "], username) !== -1) {
              const targetPortrait = elem.getAttribute("portrait");
              if (targetPortrait !== null && portrait) {
                if (targetPortrait === portrait) {
                  return true;
                }
              } else {
                return dataClassify();
              }
            } else if (username === null) {
              return dataClassify();
            }
            return false;
            function dataClassify() {
              const dataAttr = elem.getAttribute("data-field");
              if (dataAttr !== null) {
                const dataField = JSON.parse(dataAttr.replace(/'/g, '"'));
                if (portrait) {
                  if (dataField.id === portrait) {
                    return true;
                  }
                } else {
                  if (dataField.un === un2) {
                    return true;
                  }
                }
              }
              return false;
            }
          }
        });
        function addTag(elem, className) {
          elem.appendChild(
            templateCreate("div", {
              class: `${TB_TAG} ${className}`
            })
          );
        }
      }
    }
    const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: index
    }, Symbol.toStringTag, { value: "Module" }));
  })();

})();